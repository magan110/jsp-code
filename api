class ApiResponse<T> {
  final bool success;
  final T? data;
  final String message;
  final List<String> errors;
  final int? statusCode;

  ApiResponse({
    required this.success,
    this.data,
    this.message = '',
    this.errors = const [],
    this.statusCode,
  });

  factory ApiResponse.fromJson(
    Map<String, dynamic> json,
    T Function(dynamic)? fromJsonT,
  ) {
    return ApiResponse<T>(
      success: json['success'] ?? false,
      data: json['data'] != null && fromJsonT != null
          ? fromJsonT(json['data'])
          : json['data'],
      message: json['message'] ?? '',
      errors: json['errors'] != null
          ? List<String>.from(json['errors'])
          : [],
      statusCode: json['statusCode'],
    );
  }
}

class ProcessTypeOption {
  final String value;
  final String label;
  final bool selected;

  ProcessTypeOption({
    required this.value,
    required this.label,
    this.selected = false,
  });

  factory ProcessTypeOption.fromJson(Map<String, dynamic> json) {
    return ProcessTypeOption(
      value: json['value'] ?? '',
      label: json['label'] ?? '',
      selected: json['selected'] ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'value': value,
      'label': label,
      'selected': selected,
    };
  }
}

class DocumentOption {
  final String value;
  final String label;

  DocumentOption({
    required this.value,
    required this.label,
  });

  factory DocumentOption.fromJson(Map<String, dynamic> json) {
    return DocumentOption(
      value: json['value'] ?? '',
      label: json['label'] ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'value': value,
      'label': label,
    };
  }
}

class ActivityOption {
  final String value;
  final String label;

  ActivityOption({
    required this.value,
    required this.label,
  });

  factory ActivityOption.fromJson(Map<String, dynamic> json) {
    return ActivityOption(
      value: json['value'] ?? '',
      label: json['label'] ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'value': value,
      'label': label,
    };
  }
}

class ActivityDetails {
  final String activityNo;
  final String activityDate;
  final String activityName;
  final String meetDate;
  final String meetVenue;
  final String activityCity;
  final String district;
  final double maxBudget;
  final String areaCode;
  final String retailerCode;

  ActivityDetails({
    required this.activityNo,
    required this.activityDate,
    required this.activityName,
    required this.meetDate,
    required this.meetVenue,
    required this.activityCity,
    required this.district,
    required this.maxBudget,
    required this.areaCode,
    required this.retailerCode,
  });

  factory ActivityDetails.fromJson(Map<String, dynamic> json) {
    return ActivityDetails(
      activityNo: json['activityNo'] ?? '',
      activityDate: json['activityDate'] ?? '',
      activityName: json['activityName'] ?? '',
      meetDate: json['meetDate'] ?? '',
      meetVenue: json['meetVenue'] ?? '',
      activityCity: json['activityCity'] ?? '',
      district: json['district'] ?? '',
      maxBudget: (json['maxBudget'] ?? 0.0).toDouble(),
      areaCode: json['areaCode'] ?? '',
      retailerCode: json['retailerCode'] ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'activityNo': activityNo,
      'activityDate': activityDate,
      'activityName': activityName,
      'meetDate': meetDate,
      'meetVenue': meetVenue,
      'activityCity': activityCity,
      'district': district,
      'maxBudget': maxBudget,
      'areaCode': areaCode,
      'retailerCode': retailerCode,
    };
  }
}

class RetailerDetails {
  final String name;
  final String sapCode;
  final String mobileNo;
  final String stockistName;
  final String district;
  final String city;
  final String pinCode;
  final String kycStatus;

  RetailerDetails({
    required this.name,
    required this.sapCode,
    required this.mobileNo,
    required this.stockistName,
    required this.district,
    required this.city,
    required this.pinCode,
    required this.kycStatus,
  });

  factory RetailerDetails.fromJson(Map<String, dynamic> json) {
    return RetailerDetails(
      name: json['name'] ?? '',
      sapCode: json['sapCode'] ?? '',
      mobileNo: json['mobileNo'] ?? '',
      stockistName: json['stockistName'] ?? '',
      district: json['district'] ?? '',
      city: json['city'] ?? '',
      pinCode: json['pinCode'] ?? '',
      kycStatus: json['kycStatus'] ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'sapCode': sapCode,
      'mobileNo': mobileNo,
      'stockistName': stockistName,
      'district': district,
      'city': city,
      'pinCode': pinCode,
      'kycStatus': kycStatus,
    };
  }
}

class PainterDetails {
  final String mobileNo;
  final String type;
  final String name;

  PainterDetails({
    required this.mobileNo,
    required this.type,
    required this.name,
  });

  factory PainterDetails.fromJson(Map<String, dynamic> json) {
    return PainterDetails(
      mobileNo: json['mobileNo'] ?? '',
      type: json['type'] ?? '',
      name: json['name'] ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'mobileNo': mobileNo,
      'type': type,
      'name': name,
    };
  }
}

class ExpenseDetailData {
  final String expnsTye;
  final String expnsAmt;
  final String expnsBil;
  final String expAmtEx;

  ExpenseDetailData({
    required this.expnsTye,
    required this.expnsAmt,
    required this.expnsBil,
    this.expAmtEx = '0',
  });

  factory ExpenseDetailData.fromJson(Map<String, dynamic> json) {
    return ExpenseDetailData(
      expnsTye: json['expnsTye'] ?? '',
      expnsAmt: json['expnsAmt'] ?? '',
      expnsBil: json['expnsBil'] ?? '',
      expAmtEx: json['expAmtEx'] ?? '0',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'expnsTye': expnsTye,
      'expnsAmt': expnsAmt,
      'expnsBil': expnsBil,
      'expAmtEx': expAmtEx,
    };
  }
}

class ExpertMeetClaimFormData {
  final String procType;
  final String docuNumb;
  final String catActNo;
  final String areaCode;
  final String randNmSt;
  final List<ProcessTypeOption> processTypeOptions;
  final List<DocumentOption> documentOptions;
  final List<ActivityOption> activityOptions;
  final ActivityDetails? activityDetails;
  final RetailerDetails? retailerDetails;
  final List<PainterDetails> painters;
  final List<ExpenseDetailData> expenseDetails;

  ExpertMeetClaimFormData({
    this.procType = 'A',
    this.docuNumb = '',
    this.catActNo = '',
    this.areaCode = '',
    this.randNmSt = '',
    this.processTypeOptions = const [],
    this.documentOptions = const [],
    this.activityOptions = const [],
    this.activityDetails,
    this.retailerDetails,
    this.painters = const [],
    this.expenseDetails = const [],
  });

  factory ExpertMeetClaimFormData.fromJson(Map<String, dynamic> json) {
    return ExpertMeetClaimFormData(
      procType: json['procType'] ?? 'A',
      docuNumb: json['docuNumb'] ?? '',
      catActNo: json['catActNo'] ?? '',
      areaCode: json['areaCode'] ?? '',
      randNmSt: json['randNmSt'] ?? '',
      processTypeOptions: json['processTypeOptions'] != null
          ? List<ProcessTypeOption>.from(
              json['processTypeOptions']
                  .map((x) => ProcessTypeOption.fromJson(x)))
          : [],
      documentOptions: json['documentOptions'] != null
          ? List<DocumentOption>.from(
              json['documentOptions'].map((x) => DocumentOption.fromJson(x)))
          : [],
      activityOptions: json['activityOptions'] != null
          ? List<ActivityOption>.from(
              json['activityOptions'].map((x) => ActivityOption.fromJson(x)))
          : [],
      activityDetails: json['activityDetails'] != null
          ? ActivityDetails.fromJson(json['activityDetails'])
          : null,
      retailerDetails: json['retailerDetails'] != null
          ? RetailerDetails.fromJson(json['retailerDetails'])
          : null,
      painters: json['painters'] != null
          ? List<PainterDetails>.from(
              json['painters'].map((x) => PainterDetails.fromJson(x)))
          : [],
      expenseDetails: json['expenseDetails'] != null
          ? List<ExpenseDetailData>.from(
              json['expenseDetails'].map((x) => ExpenseDetailData.fromJson(x)))
          : [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'procType': procType,
      'docuNumb': docuNumb,
      'catActNo': catActNo,
      'areaCode': areaCode,
      'randNmSt': randNmSt,
      'processTypeOptions': processTypeOptions.map((x) => x.toJson()).toList(),
      'documentOptions': documentOptions.map((x) => x.toJson()).toList(),
      'activityOptions': activityOptions.map((x) => x.toJson()).toList(),
      'activityDetails': activityDetails?.toJson(),
      'retailerDetails': retailerDetails?.toJson(),
      'painters': painters.map((x) => x.toJson()).toList(),
      'expenseDetails': expenseDetails.map((x) => x.toJson()).toList(),
    };
  }
}

class ExpenseSubmissionDetail {
  final String expnsBil;
  final String expnsAmt;
  final String expAmtEx;

  ExpenseSubmissionDetail({
    required this.expnsBil,
    required this.expnsAmt,
    this.expAmtEx = '0',
  });

  factory ExpenseSubmissionDetail.fromJson(Map<String, dynamic> json) {
    return ExpenseSubmissionDetail(
      expnsBil: json['expnsBil'] ?? '',
      expnsAmt: json['expnsAmt'] ?? '',
      expAmtEx: json['expAmtEx'] ?? '0',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'expnsBil': expnsBil,
      'expnsAmt': expnsAmt,
      'expAmtEx': expAmtEx,
    };
  }
}

class ExpertMeetClaimSubmission {
  final String procType;
  final String docuNumb;
  final String catActNo;
  final String areaCode;
  final String loginIdM;
  final String pendWith;
  final String randNmSt;
  final String zoneCode;
  final String meetDate;
  final List<ExpenseSubmissionDetail> expenseDetails;

  ExpertMeetClaimSubmission({
    this.procType = 'A',
    this.docuNumb = '',
    required this.catActNo,
    required this.areaCode,
    required this.loginIdM,
    this.pendWith = '',
    this.randNmSt = '',
    this.zoneCode = '',
    this.meetDate = '',
    this.expenseDetails = const [],
  });

  factory ExpertMeetClaimSubmission.fromJson(Map<String, dynamic> json) {
    return ExpertMeetClaimSubmission(
      procType: json['procType'] ?? 'A',
      docuNumb: json['docuNumb'] ?? '',
      catActNo: json['catActNo'] ?? '',
      areaCode: json['areaCode'] ?? '',
      loginIdM: json['loginIdM'] ?? '',
      pendWith: json['pendWith'] ?? '',
      randNmSt: json['randNmSt'] ?? '',
      zoneCode: json['zoneCode'] ?? '',
      meetDate: json['meetDate'] ?? '',
      expenseDetails: json['expenseDetails'] != null
          ? List<ExpenseSubmissionDetail>.from(json['expenseDetails']
              .map((x) => ExpenseSubmissionDetail.fromJson(x)))
          : [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'procType': procType,
      'docuNumb': docuNumb,
      'catActNo': catActNo,
      'areaCode': areaCode,
      'loginIdM': loginIdM,
      'pendWith': pendWith,
      'randNmSt': randNmSt,
      'zoneCode': zoneCode,
      'meetDate': meetDate,
      'expenseDetails': expenseDetails.map((x) => x.toJson()).toList(),
    };
  }
}

class BudgetValidationResponse {
  final bool isValid;
  final double maxBudget;
  final double requestedAmount;
  final double remainingBudget;

  BudgetValidationResponse({
    required this.isValid,
    required this.maxBudget,
    required this.requestedAmount,
    required this.remainingBudget,
  });

  factory BudgetValidationResponse.fromJson(Map<String, dynamic> json) {
    return BudgetValidationResponse(
      isValid: json['isValid'] ?? false,
      maxBudget: (json['maxBudget'] ?? 0.0).toDouble(),
      requestedAmount: (json['requestedAmount'] ?? 0.0).toDouble(),
      remainingBudget: (json['remainingBudget'] ?? 0.0).toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'isValid': isValid,
      'maxBudget': maxBudget,
      'requestedAmount': requestedAmount,
      'remainingBudget': remainingBudget,
    };
  }
}








import 'dart:convert';
import 'package:http/http.dart' as http;
import '../models/expert_meet_claim_models.dart';
import '../utils/app_logger.dart';

class ExpertMeetClaimService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  // Base URL configuration
  static String get baseUrl => 'http://10.4.64.23:8521';

  // Generic HTTP request method
  static Future<Map<String, dynamic>> _makeRequest({
    required String method,
    required String endpoint,
    Map<String, dynamic>? body,
    Map<String, String>? headers,
    Duration? timeout,
  }) async {
    try {
      _logger.info('Making $method request to $endpoint');

      final uri = Uri.parse('$baseUrl$endpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        ...?headers,
      };

      http.Response response;
      final timeoutDuration = timeout ?? _defaultTimeout;

      switch (method.toUpperCase()) {
        case 'GET':
          response = await http.get(uri, headers: requestHeaders).timeout(timeoutDuration);
          break;
        case 'POST':
          response = await http
              .post(uri, headers: requestHeaders, body: jsonEncode(body ?? <String, dynamic>{}))
              .timeout(timeoutDuration);
          break;
        case 'PUT':
          response = await http
              .put(uri, headers: requestHeaders, body: jsonEncode(body ?? <String, dynamic>{}))
              .timeout(timeoutDuration);
          break;
        case 'DELETE':
          response = await http.delete(uri, headers: requestHeaders).timeout(timeoutDuration);
          break;
        default:
          throw Exception('Unsupported HTTP method: $method');
      }

      _logger.debug('Response ${response.statusCode} for $method $endpoint');
      _logger.debug('Response body: ${response.body}');

      final parsed = _safeJson(response.body);

      if (response.statusCode >= 200 && response.statusCode < 300) {
        return {
          'success': true,
          'data': parsed,
          'statusCode': response.statusCode,
        };
      } else {
        final msg = _extractErrorMessage(parsed, fallback: response.reasonPhrase ?? 'Request failed');
        return {
          'success': false,
          'error': msg,
          'statusCode': response.statusCode,
          'data': parsed,
        };
      }
    } catch (e) {
      _logger.error('Request failed', e);
      return {'success': false, 'error': 'Network error: $e', 'statusCode': 0};
    }
  }

  // Extract error message from API response
  static String _extractErrorMessage(Map<String, dynamic> json, {String fallback = 'Request failed'}) {
    final title = json['title']?.toString();
    final detail = json['detail']?.toString();
    String combined = (title ?? '').trim();
    if (detail != null && detail.isNotEmpty) {
      combined = combined.isEmpty ? detail : '$combined â€” $detail';
    }

    if (json['errors'] is Map) {
      final errs = json['errors'] as Map;
      final parts = <String>[];
      errs.forEach((k, v) {
        if (v is List && v.isNotEmpty) {
          parts.add('$k: ${v.join("; ")}');
        } else if (v != null) {
          parts.add('$k: $v');
        }
      });
      if (parts.isNotEmpty) {
        final flat = parts.join(' | ');
        combined = combined.isEmpty ? flat : '$combined | $flat';
      }
    }

    if (combined.isNotEmpty) return combined;

    if (json['message'] != null) return json['message'].toString();
    if (json['error'] != null) return json['error'].toString();

    return fallback;
  }

  // Safe JSON parsing
  static Map<String, dynamic> _safeJson(String body) {
    try {
      final parsed = json.decode(body);
      return parsed is Map<String, dynamic>
          ? parsed
          : <String, dynamic>{'raw': parsed};
    } catch (_) {
      return <String, dynamic>{'raw': body};
    }
  }

  /// Get form data for expert meet claim
  ///
  /// [procType] - Process type (A=Add, U=Update, D=Delete)
  /// [docuNumb] - Document number (for update/delete)
  /// [catActNo] - Activity number
  /// [areaCode] - Area code
  /// [loginIdM] - Login ID
  static Future<ApiResponse<ExpertMeetClaimFormData>> getFormData({
    String procType = 'A',
    String docuNumb = '',
    String catActNo = '',
    String areaCode = '',
    String loginIdM = '',
  }) async {
    try {
      _logger.info('Fetching expert meet claim form data');

      final queryParams = <String, String>{
        'procType': procType,
        'docuNumb': docuNumb,
        'catActNo': catActNo,
        'areaCode': areaCode,
        'loginIdM': loginIdM,
      };

      // Remove empty parameters
      queryParams.removeWhere((key, value) => value.isEmpty);

      final queryString = queryParams.entries
          .map((e) => '${Uri.encodeComponent(e.key)}=${Uri.encodeComponent(e.value)}')
          .join('&');

      final endpoint = '/api/ExpertMeetClaim/form-data${queryString.isNotEmpty ? '?$queryString' : ''}';

      final result = await _makeRequest(
        method: 'GET',
        endpoint: endpoint,
      );

      if (result['success'] == true) {
        final formData = ExpertMeetClaimFormData.fromJson(result['data'] ?? {});
        return ApiResponse<ExpertMeetClaimFormData>(
          success: true,
          data: formData,
          message: 'Form data loaded successfully',
          statusCode: result['statusCode'],
        );
      } else {
        return ApiResponse<ExpertMeetClaimFormData>(
          success: false,
          message: result['error'] ?? 'Failed to load form data',
          statusCode: result['statusCode'],
        );
      }
    } catch (e) {
      _logger.error('Failed to fetch form data', e);
      return ApiResponse<ExpertMeetClaimFormData>(
        success: false,
        message: 'Failed to fetch form data: $e',
      );
    }
  }

  /// Submit expert meet claim
  ///
  /// [submission] - The claim submission data
  static Future<ApiResponse<String>> submitClaim(
    ExpertMeetClaimSubmission submission,
  ) async {
    try {
      _logger.info('Submitting expert meet claim');

      final result = await _makeRequest(
        method: 'POST',
        endpoint: '/api/ExpertMeetClaim/submit',
        body: submission.toJson(),
      );

      if (result['success'] == true) {
        final docuNumb = result['data'] is String ? result['data'] : result['data']?['docuNumb'] ?? '';
        return ApiResponse<String>(
          success: true,
          data: docuNumb,
          message: result['data']?['message'] ?? 'Claim submitted successfully',
          statusCode: result['statusCode'],
        );
      } else {
        return ApiResponse<String>(
          success: false,
          message: result['error'] ?? 'Failed to submit claim',
          errors: result['data']?['errors'] != null
              ? List<String>.from(result['data']['errors'])
              : [],
          statusCode: result['statusCode'],
        );
      }
    } catch (e) {
      _logger.error('Failed to submit claim', e);
      return ApiResponse<String>(
        success: false,
        message: 'Failed to submit claim: $e',
      );
    }
  }

  /// Validate budget for activity
  ///
  /// [activityNo] - Activity number
  /// [totalAmount] - Total amount to validate
  static Future<ApiResponse<BudgetValidationResponse>> validateBudget({
    required String activityNo,
    required double totalAmount,
  }) async {
    try {
      _logger.info('Validating budget for activity: $activityNo');

      final queryParams = {
        'activityNo': activityNo,
        'totalAmount': totalAmount.toString(),
      };

      final queryString = queryParams.entries
          .map((e) => '${Uri.encodeComponent(e.key)}=${Uri.encodeComponent(e.value)}')
          .join('&');

      final endpoint = '/api/ExpertMeetClaim/validate-budget?$queryString';

      final result = await _makeRequest(
        method: 'GET',
        endpoint: endpoint,
      );

      if (result['success'] == true) {
        final validation = BudgetValidationResponse.fromJson(result['data'] ?? {});
        return ApiResponse<BudgetValidationResponse>(
          success: true,
          data: validation,
          message: result['data']?['message'] ?? 'Budget validation completed',
          statusCode: result['statusCode'],
        );
      } else {
        return ApiResponse<BudgetValidationResponse>(
          success: false,
          message: result['error'] ?? 'Failed to validate budget',
          statusCode: result['statusCode'],
        );
      }
    } catch (e) {
      _logger.error('Failed to validate budget', e);
      return ApiResponse<BudgetValidationResponse>(
        success: false,
        message: 'Failed to validate budget: $e',
      );
    }
  }

  /// Load activity details when activity is selected
  ///
  /// [catActNo] - Activity number
  /// [loginIdM] - Login ID
  static Future<ApiResponse<ExpertMeetClaimFormData>> loadActivityDetails({
    required String catActNo,
    String loginIdM = '',
  }) async {
    try {
      _logger.info('Loading activity details for: $catActNo');

      return await getFormData(
        procType: 'A',
        catActNo: catActNo,
        loginIdM: loginIdM,
      );
    } catch (e) {
      _logger.error('Failed to load activity details', e);
      return ApiResponse<ExpertMeetClaimFormData>(
        success: false,
        message: 'Failed to load activity details: $e',
      );
    }
  }

  /// Load existing claim data for update/delete
  ///
  /// [procType] - Process type (U=Update, D=Delete)
  /// [docuNumb] - Document number
  /// [loginIdM] - Login ID
  static Future<ApiResponse<ExpertMeetClaimFormData>> loadExistingClaim({
    required String procType,
    required String docuNumb,
    String loginIdM = '',
  }) async {
    try {
      _logger.info('Loading existing claim: $docuNumb');

      return await getFormData(
        procType: procType,
        docuNumb: docuNumb,
        loginIdM: loginIdM,
      );
    } catch (e) {
      _logger.error('Failed to load existing claim', e);
      return ApiResponse<ExpertMeetClaimFormData>(
        success: false,
        message: 'Failed to load existing claim: $e',
      );
    }
  }

  /// Test connectivity to the expert meet claim API
  static Future<Map<String, dynamic>> testConnectivity() async {
    try {
      _logger.info('Testing expert meet claim API connectivity');

      final result = await _makeRequest(
        method: 'GET',
        endpoint: '/api/ExpertMeetClaim/form-data',
        timeout: const Duration(seconds: 10),
      );

      return {
        'success': result['success'],
        'statusCode': result['statusCode'],
        'message': result['success']
            ? 'Expert meet claim API is accessible'
            : 'Expert meet claim API is not accessible: ${result['error']}',
      };
    } catch (e) {
      _logger.error('Expert meet claim API connectivity test failed', e);
      return {
        'success': false,
        'error': 'Connectivity test failed: $e',
      };
    }
  }
}









import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import '../../../core/widgets/file_upload_widget.dart';
import '../../../core/widgets/custom_back_button.dart';
import '../../../core/services/expert_meet_claim_service.dart';
import '../../../core/models/expert_meet_claim_models.dart';

class ExpertMeetClaimPage extends StatefulWidget {
  const ExpertMeetClaimPage({super.key});

  @override
  _ExpertMeetClaimPageState createState() => _ExpertMeetClaimPageState();
}

class _ExpertMeetClaimPageState extends State<ExpertMeetClaimPage>
    with TickerProviderStateMixin {
  // Form controllers
  final _formKey = GlobalKey<FormState>();
  final _activityNoController = TextEditingController();
  final _budgetController = TextEditingController();
  final _retailerNameController = TextEditingController();
  final _sapCodeController = TextEditingController();
  final _retailerMobileController = TextEditingController();
  final _stockistNameController = TextEditingController();
  final _billNoController = TextEditingController();
  final _totalAmountController = TextEditingController(text: '0');

  // Date controllers
  final _planDateController = TextEditingController();
  final _actualDateController = TextEditingController();

  // State variables
  bool _showPainterDetails = false;
  String? _uploadedImagePath;
  List<Painter> _painters = [];
  bool _isSubmitting = false;
  bool _isLoading = false;

  // API data
  String? _selectedProcessType;
  String? _selectedActivity;
  String? _selectedDocument;
  final String _loginIdM = 'TEST_USER'; // Replace with actual login ID
  final String _areaCode = '001'; // Replace with actual area code
  final String _zoneCode = 'Z001'; // Replace with actual zone code
  ExpertMeetClaimFormData? _formData;

  // Dropdown values
  List<ProcessTypeOption> _processTypeOptions = [];
  List<ActivityOption> _activityOptions = [];
  List<DocumentOption> _documentOptions = [];

  // Animation controllers
  late AnimationController _mainController;
  late AnimationController _fabController;
  late Animation<double> _fadeAnimation;
  late Animation<Offset> _slideAnimation;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _mainController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );
    _fabController = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(
        parent: _mainController,
        curve: const Interval(0.0, 0.5, curve: Curves.easeOut),
      ),
    );
    _slideAnimation =
        Tween<Offset>(begin: const Offset(0, 0.3), end: Offset.zero).animate(
          CurvedAnimation(
            parent: _mainController,
            curve: const Interval(0.2, 0.7, curve: Curves.easeOutCubic),
          ),
        );
    _scaleAnimation = Tween<double>(begin: 0.95, end: 1.0).animate(
      CurvedAnimation(
        parent: _mainController,
        curve: const Interval(0.3, 0.8, curve: Curves.easeOutCubic),
      ),
    );
    _mainController.forward();
    _fabController.forward();
    _loadFormData();
  }

  @override
  void dispose() {
    _mainController.dispose();
    _fabController.dispose();
    _activityNoController.dispose();
    _budgetController.dispose();
    _retailerNameController.dispose();
    _sapCodeController.dispose();
    _retailerMobileController.dispose();
    _stockistNameController.dispose();
    _billNoController.dispose();
    _totalAmountController.dispose();
    _planDateController.dispose();
    _actualDateController.dispose();
    super.dispose();
  }

  // Handle file upload
  void _onFileUploaded(String? filePath) {
    setState(() {
      _uploadedImagePath = filePath;
    });
  }


  // Add painter to list
  void _addPainter() {
    setState(() {
      _painters.add(Painter(mobileNo: '', type: 'Type A', name: ''));
    });
  }

  // Remove painter from list
  void _removePainter(int index) {
    setState(() {
      _painters.removeAt(index);
    });
  }

  // Load form data from API
  Future<void> _loadFormData() async {
    setState(() {
      _isLoading = true;
    });

    try {
      final response = await ExpertMeetClaimService.getFormData(
        procType: _selectedProcessType ?? 'A',
        loginIdM: _loginIdM,
        areaCode: _areaCode,
        docuNumb: _selectedDocument ?? '',
        catActNo: _selectedActivity ?? '',
      );

      if (response.success && response.data != null) {
        setState(() {
          _formData = response.data;
          _processTypeOptions = response.data!.processTypeOptions;
          _activityOptions = response.data!.activityOptions;
          _documentOptions = response.data!.documentOptions;

          // Update form fields with loaded data
          if (response.data!.activityDetails != null) {
            _budgetController.text = response.data!.activityDetails!.maxBudget.toString();
            _planDateController.text = response.data!.activityDetails!.meetDate;
          }

          // Load painter details
          _painters.clear();
          for (var painter in response.data!.painters) {
            _painters.add(Painter(
              mobileNo: painter.mobileNo,
              type: painter.type,
              name: painter.name,
            ));
          }

          // Load retailer details
          if (response.data!.retailerDetails != null) {
            final retailer = response.data!.retailerDetails!;
            _retailerNameController.text = retailer.name;
            _sapCodeController.text = retailer.sapCode;
            _retailerMobileController.text = retailer.mobileNo;
            _stockistNameController.text = retailer.stockistName;
          }
        });
      } else {
        _showErrorSnackBar(response.message);
      }
    } catch (e) {
      _showErrorSnackBar('Failed to load form data: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  // Submit form
  Future<void> _submitForm() async {
    if (!_validateForm()) {
      return;
    }

    setState(() {
      _isSubmitting = true;
    });

    try {
      // Validate budget first
      final budgetValid = await _validateBudget();
      if (!budgetValid) {
        return;
      }

      // Prepare expense details
      List<ExpenseSubmissionDetail> expenseDetails = [];
      if (_billNoController.text.isNotEmpty && _totalAmountController.text.isNotEmpty) {
        expenseDetails.add(ExpenseSubmissionDetail(
          expnsBil: _billNoController.text,
          expnsAmt: _totalAmountController.text,
        ));
      }

      // Create submission object
      final submission = ExpertMeetClaimSubmission(
        procType: _selectedProcessType ?? 'A',
        docuNumb: _selectedDocument ?? '',
        catActNo: _selectedActivity ?? '',
        areaCode: _areaCode,
        loginIdM: _loginIdM,
        zoneCode: _zoneCode,
        meetDate: _actualDateController.text,
        expenseDetails: expenseDetails,
      );

      final response = await ExpertMeetClaimService.submitClaim(submission);

      if (response.success) {
        _showSuccessSnackBar('${response.message}${response.data != null ? ' Document No: ${response.data}' : ''}');
        _clearForm();
        await _loadFormData(); // Reload form data
      } else {
        String errorMessage = response.message;
        if (response.errors.isNotEmpty) {
          errorMessage += '\n${response.errors.join('\n')}';
        }
        _showErrorSnackBar(errorMessage);
      }
    } catch (e) {
      _showErrorSnackBar('Failed to submit claim: $e');
    } finally {
      setState(() {
        _isSubmitting = false;
      });
    }
  }

  // Clear form after successful submission
  void _clearForm() {
    _formKey.currentState?.reset();
    _activityNoController.clear();
    _budgetController.clear();
    _retailerNameController.clear();
    _sapCodeController.clear();
    _retailerMobileController.clear();
    _stockistNameController.clear();
    _billNoController.clear();
    _totalAmountController.text = '0';
    _planDateController.clear();
    _actualDateController.clear();
    _painters.clear();
    _uploadedImagePath = null;
    _selectedProcessType = null;
    _selectedActivity = null;
    _selectedDocument = null;
    setState(() {});
  }

  // Show success snackbar
  void _showSuccessSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.check_circle, color: Colors.white, size: 20),
            const SizedBox(width: 8),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.green,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 5),
      ),
    );
  }

  // Show error snackbar
  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.error, color: Colors.white, size: 20),
            const SizedBox(width: 8),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.red,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 5),
      ),
    );
  }

  // Handle activity selection
  Future<void> _onActivitySelected(String? activityValue) async {
    if (activityValue != null && activityValue != _selectedActivity) {
      setState(() {
        _selectedActivity = activityValue;
        _isLoading = true;
      });

      try {
        final response = await ExpertMeetClaimService.loadActivityDetails(
          catActNo: activityValue,
          loginIdM: _loginIdM,
        );

        if (response.success && response.data != null) {
          setState(() {
            _formData = response.data;

            // Update form fields with activity data
            if (response.data!.activityDetails != null) {
              final activity = response.data!.activityDetails!;
              _budgetController.text = activity.maxBudget.toString();
              _planDateController.text = activity.meetDate;
            }

            // Update painter details
            _painters.clear();
            for (var painter in response.data!.painters) {
              _painters.add(Painter(
                mobileNo: painter.mobileNo,
                type: painter.type,
                name: painter.name,
              ));
            }

            // Update retailer details
            if (response.data!.retailerDetails != null) {
              final retailer = response.data!.retailerDetails!;
              _retailerNameController.text = retailer.name;
              _sapCodeController.text = retailer.sapCode;
              _retailerMobileController.text = retailer.mobileNo;
              _stockistNameController.text = retailer.stockistName;
            }
          });
        }
      } catch (e) {
        _showErrorSnackBar('Failed to load activity details: $e');
      } finally {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  // Validate budget before submission
  Future<bool> _validateBudget() async {
    if (_selectedActivity == null || _totalAmountController.text.isEmpty) {
      return true; // Skip validation if no activity or amount
    }

    try {
      final totalAmount = double.tryParse(_totalAmountController.text) ?? 0.0;
      if (totalAmount <= 0) return true;

      final response = await ExpertMeetClaimService.validateBudget(
        activityNo: _selectedActivity!,
        totalAmount: totalAmount,
      );

      if (response.success && response.data != null) {
        if (!response.data!.isValid) {
          _showErrorSnackBar(
            'Budget exceeded! Max budget: ${response.data!.maxBudget}, '
            'Requested: ${response.data!.requestedAmount}',
          );
          return false;
        }
        return true;
      } else {
        _showErrorSnackBar('Failed to validate budget: ${response.message}');
        return false;
      }
    } catch (e) {
      _showErrorSnackBar('Budget validation error: $e');
      return false;
    }
  }

  // Enhanced form validation
  bool _validateForm() {
    if (!_formKey.currentState!.validate()) {
      return false;
    }

    // Check if process type is selected
    if (_selectedProcessType == null) {
      _showErrorSnackBar('Please select a process type');
      return false;
    }

    // Check if document is selected for update/delete
    if ((_selectedProcessType == 'U' || _selectedProcessType == 'D') &&
        _selectedDocument == null) {
      _showErrorSnackBar('Please select a document number');
      return false;
    }

    // Check if activity is selected
    if (_selectedActivity == null) {
      _showErrorSnackBar('Please select an activity');
      return false;
    }

    // Check if actual date is provided
    if (_actualDateController.text.isEmpty) {
      _showErrorSnackBar('Please select the actual meeting date');
      return false;
    }

    // Check if expense details are provided
    if (_billNoController.text.isEmpty || _totalAmountController.text.isEmpty) {
      _showErrorSnackBar('Please provide expense details (Bill No and Amount)');
      return false;
    }

    // Validate amount
    final amount = double.tryParse(_totalAmountController.text);
    if (amount == null || amount <= 0) {
      _showErrorSnackBar('Please enter a valid amount');
      return false;
    }

    return true;
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final isDesktop = constraints.maxWidth > 1200;
        final isTablet =
            constraints.maxWidth > 800 && constraints.maxWidth <= 1200;

        return Scaffold(
          backgroundColor: const Color(0xFFF8FAFC),
          appBar: _buildModernAppBar(),
          body: Stack(
            children: [
              FadeTransition(
                opacity: _fadeAnimation,
                child: SlideTransition(
                  position: _slideAnimation,
                  child: Container(
                    decoration: const BoxDecoration(color: Color(0xFFF8FAFC)),
                    child: SingleChildScrollView(
                      padding: EdgeInsets.symmetric(
                        horizontal: isDesktop ? 48 : (isTablet ? 32 : 24),
                        vertical: 24,
                      ),
                      child: Center(
                        child: ConstrainedBox(
                          constraints: BoxConstraints(
                            maxWidth: isDesktop ? 1400 : double.infinity,
                          ),
                          child: ScaleTransition(
                            scale: _scaleAnimation,
                            child: Form(
                              key: _formKey,
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  _buildAnimatedHeader(),
                                  const SizedBox(height: 32),
                                  // Main Content - Two columns on desktop
                                  if (isDesktop)
                                    _buildDesktopLayout()
                                  else
                                    _buildMobileLayout(),
                                  const SizedBox(height: 48),
                                  _buildAnimatedSubmitButton(),
                                  const SizedBox(height: 48),
                                ],
                              ),
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ),
              // Loading overlay
              if (_isLoading)
                Container(
                  color: Colors.black54,
                  child: const Center(
                    child: CircularProgressIndicator(
                      color: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildDesktopLayout() {
    return Column(
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Left Column
            Expanded(
              child: Column(
                children: [
                  // Activity Details
                  _buildActivityDetailsSection(),
                  const SizedBox(height: 24),
                  // Experts Meet Details
                  _buildExpertsMeetDetailsSection(),
                ],
              ),
            ),
            const SizedBox(width: 24),
            // Right Column
            Expanded(
              child: Column(
                children: [
                  // Painter Details
                  _buildPainterDetailsSection(),
                  const SizedBox(height: 24),
                  // Expense Details
                  _buildExpenseDetailsSection(),
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildMobileLayout() {
    return Column(
      children: [
        // Activity Details
        _buildActivityDetailsSection(),
        const SizedBox(height: 24),
        // Experts Meet Details
        _buildExpertsMeetDetailsSection(),
        const SizedBox(height: 24),
        // Painter Details
        _buildPainterDetailsSection(),
        const SizedBox(height: 24),
        // Expense Details
        _buildExpenseDetailsSection(),
      ],
    );
  }

  PreferredSizeWidget _buildModernAppBar() {
    return AppBar(
      elevation: 0,
      backgroundColor: Colors.white,
      foregroundColor: const Color(0xFF1E3A8A),
      systemOverlayStyle: const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.dark,
      ),
      leading: CustomBackButton(
        onPressed: () => Navigator.pushNamedAndRemoveUntil(
          context,
          '/home',
          (route) => false,
        ),
      ),
      title: Text(
        'Expert Meet Claim',
        style: TextStyle(
          fontWeight: FontWeight.w600,
          fontSize: 20,
          color: const Color(0xFF1E3A8A),
        ),
      ),
      actions: [
        IconButton(
          icon: const Icon(
            Icons.help_outline_rounded,
            color: Color(0xFF1E3A8A),
          ),
          onPressed: () => _showHelpDialog(),
        ),
      ],
    );
  }

  Widget _buildAnimatedHeader() {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(32),
      decoration: BoxDecoration(
        gradient: const LinearGradient(
          colors: [Color(0xFF1E3A8A), Color(0xFF3B82F6)],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.blue.withOpacity(0.15),
            blurRadius: 20,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: const Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Expert Meet Claim',
            style: TextStyle(
              fontSize: 32,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          SizedBox(height: 12),
          Text(
            'Submit your expert meet expenses',
            style: TextStyle(fontSize: 18, color: Colors.white70),
          ),
        ],
      ),
    );
  }

  Widget _buildActivityDetailsSection() {
    return _buildModernSection(
      title: 'Activity Details',
      icon: Icons.event_note_outlined,
      children: [
        _buildProcessTypeDropdown(),
        const SizedBox(height: 20),
        if (_selectedProcessType == 'U' || _selectedProcessType == 'D') ...
        [
          _buildDocumentDropdown(),
          const SizedBox(height: 20),
        ],
        _buildActivityDropdown(),
        const SizedBox(height: 20),
        _buildModernTextField(
          controller: _budgetController,
          label: 'Total Max Budget',
          icon: Icons.account_balance_wallet_outlined,
          isRequired: true,
          isNumber: true,
        ),
      ],
    );
  }

  Widget _buildExpertsMeetDetailsSection() {
    return _buildModernSection(
      title: 'Experts Meet Details',
      icon: Icons.groups_outlined,
      children: [
        _buildModernDateField(
          controller: _planDateController,
          label: 'Plan Date',
          icon: Icons.event_outlined,
        ),
        const SizedBox(height: 20),
        _buildModernDateField(
          controller: _actualDateController,
          label: 'Actual Date',
          icon: Icons.event_available_outlined,
          isRequired: true,
        ),
      ],
    );
  }

  Widget _buildPainterDetailsSection() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 16,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        children: [
          // Header
          InkWell(
            onTap: () {
              setState(() {
                _showPainterDetails = !_showPainterDetails;
              });
            },
            child: Container(
              padding: const EdgeInsets.all(24),
              decoration: BoxDecoration(
                color: const Color(0xFFF8FAFC),
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(16),
                ),
              ),
              child: Row(
                children: [
                  Container(
                    width: 48,
                    height: 48,
                    decoration: BoxDecoration(
                      color: const Color(0xFF1E3A8A).withOpacity(0.1),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      Icons.person_outline,
                      color: const Color(0xFF1E3A8A),
                      size: 24,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Text(
                      'Click Here to see Painter Details',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: const Color(0xFF1F2937),
                      ),
                    ),
                  ),
                  Icon(
                    _showPainterDetails ? Icons.expand_less : Icons.expand_more,
                    color: const Color(0xFF1E3A8A),
                  ),
                ],
              ),
            ),
          ),
          // Content
          if (_showPainterDetails)
            Padding(
              padding: const EdgeInsets.all(24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Retailer Details Section
                  _buildModernSubSection(
                    title: 'Retailer Details',
                    icon: Icons.store_outlined,
                    children: [
                      _buildModernTextField(
                        controller: _retailerNameController,
                        label: 'Name',
                        icon: Icons.person_outline_rounded,
                        isRequired: true,
                      ),
                      const SizedBox(height: 20),
                      _buildModernTextField(
                        controller: _sapCodeController,
                        label: 'SAP Code',
                        icon: Icons.qr_code_outlined,
                        isRequired: true,
                      ),
                      const SizedBox(height: 20),
                      _buildModernTextField(
                        controller: _retailerMobileController,
                        label: 'Mobile No',
                        icon: Icons.phone_outlined,
                        isRequired: true,
                        isPhone: true,
                      ),
                      const SizedBox(height: 20),
                      _buildModernTextField(
                        controller: _stockistNameController,
                        label: 'Stockist Name',
                        icon: Icons.business_outlined,
                        isRequired: true,
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  // Painter List Section
                  _buildModernSubSection(
                    title: 'Painter List',
                    icon: Icons.people_outlined,
                    children: [
                      _painters.isEmpty
                          ? _buildEmptyPainterState()
                          : Column(
                              children: _painters.asMap().entries.map((entry) {
                                int index = entry.key;
                                return _buildPainterCard(index);
                              }).toList(),
                            ),
                      const SizedBox(height: 20),
                      // Add Painter Button
                      SizedBox(
                        width: double.infinity,
                        height: 56,
                        child: ElevatedButton.icon(
                          onPressed: _addPainter,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: const Color(0xFF1E3A8A),
                            foregroundColor: Colors.white,
                            elevation: 0,
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(12),
                            ),
                          ),
                          icon: const Icon(Icons.add_circle_outline),
                          label: const Text(
                            'Add Painter',
                            style: TextStyle(fontSize: 16),
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildExpenseDetailsSection() {
    return _buildModernSection(
      title: 'Enter Expanse Details (Tea & Snacks)',
      icon: Icons.receipt_long_outlined,
      children: [
        _buildModernTextField(
          controller: _billNoController,
          label: 'Bill No',
          icon: Icons.receipt_outlined,
        ),
        const SizedBox(height: 20),
        _buildModernTextField(
          controller: _totalAmountController,
          label: 'Total Amount',
          icon: Icons.currency_exchange_outlined,
          isNumber: true,
        ),
        const SizedBox(height: 20),
        // Image Upload Section
        FileUploadWidget(
          label: 'Image 1',
          icon: Icons.image,
          onFileSelected: _onFileUploaded,
          allowedExtensions: ['jpg', 'jpeg', 'png'],
          maxSizeInMB: 10.0,
          currentFilePath: _uploadedImagePath,
        ),
      ],
    );
  }

  Widget _buildModernSection({
    required String title,
    required IconData icon,
    required List<Widget> children,
    bool isOptional = false,
  }) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.04),
            blurRadius: 16,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Section Header
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: const Color(0xFFF8FAFC),
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            child: Row(
              children: [
                Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                    color: const Color(0xFF1E3A8A).withOpacity(0.1),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(icon, color: const Color(0xFF1E3A8A), size: 24),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: const TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                          color: Color(0xFF1F2937),
                        ),
                      ),
                      if (isOptional)
                        Text(
                          'Optional',
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.grey.shade500,
                          ),
                        ),
                    ],
                  ),
                ),
              ],
            ),
          ),
          // Section Content
          Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: children,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildModernSubSection({
    required String title,
    required IconData icon,
    required List<Widget> children,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              width: 36,
              height: 36,
              decoration: BoxDecoration(
                color: const Color(0xFF1E3A8A).withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(icon, color: const Color(0xFF1E3A8A), size: 20),
            ),
            const SizedBox(width: 12),
            Text(
              title,
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
                color: Color(0xFF1F2937),
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),
        ...children,
      ],
    );
  }

  Widget _buildModernDropdown({
    required String? value,
    required String label,
    required IconData icon,
    required List<String> items,
    required void Function(String?) onChanged,
    bool isRequired = true,
  }) {
    return DropdownButtonFormField<String>(
      value: value,
      decoration: InputDecoration(
        labelText: isRequired ? '$label *' : label,
        prefixIcon: Icon(icon, color: Colors.grey.shade600),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF1E3A8A), width: 2),
        ),
        filled: true,
        fillColor: const Color(0xFFF8FAFC),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 16,
        ),
      ),
      items: items.map((String item) {
        return DropdownMenuItem<String>(
          value: item,
          child: Container(color: Colors.white, child: Text(item)),
        );
      }).toList(),
      onChanged: onChanged,
      validator: (selectedValue) {
        if (isRequired && (selectedValue == null || selectedValue.isEmpty)) {
          return 'Please select $label';
        }
        return null;
      },
      dropdownColor: Colors.white,
      style: const TextStyle(color: Colors.black87, fontSize: 16),
      icon: const Icon(Icons.arrow_drop_down, color: Colors.grey),
    );
  }

  Widget _buildModernTextField({
    required TextEditingController controller,
    required String label,
    required IconData icon,
    bool isPhone = false,
    bool isNumber = false,
    bool isRequired = true,
    bool readOnly = false,
  }) {
    return TextFormField(
      controller: controller,
      readOnly: readOnly,
      decoration: InputDecoration(
        labelText: isRequired ? '$label *' : label,
        prefixIcon: Icon(icon, color: Colors.grey.shade600),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF1E3A8A), width: 2),
        ),
        filled: true,
        fillColor: const Color(0xFFF8FAFC),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 16,
        ),
      ),
      keyboardType: isNumber
          ? TextInputType.number
          : isPhone
          ? TextInputType.phone
          : TextInputType.text,
      validator: (value) {
        if (isRequired && (value == null || value.trim().isEmpty)) {
          return 'Please enter $label';
        }
        return null;
      },
    );
  }

  Widget _buildModernDateField({
    required TextEditingController controller,
    required String label,
    required IconData icon,
    bool isRequired = true,
  }) {
    return TextFormField(
      controller: controller,
      decoration: InputDecoration(
        labelText: isRequired ? '$label *' : label,
        prefixIcon: Icon(icon, color: Colors.grey.shade600),
        suffixIcon: const Icon(
          Icons.calendar_today_rounded,
          color: Colors.grey,
        ),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF1E3A8A), width: 2),
        ),
        filled: true,
        fillColor: const Color(0xFFF8FAFC),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 16,
        ),
      ),
      readOnly: true,
      onTap: () async {
        final date = await showDatePicker(
          context: context,
          initialDate: DateTime.now(),
          firstDate: DateTime(1900),
          lastDate: DateTime(2100),
          builder: (context, child) {
            return Theme(
              data: Theme.of(context).copyWith(
                colorScheme: const ColorScheme.light(
                  primary: Color(0xFF1E3A8A),
                ),
              ),
              child: child!,
            );
          },
        );
        if (date != null) {
          controller.text = DateFormat('yyyy-MM-dd').format(date);
        }
      },
      validator: (value) {
        if (isRequired && (value == null || value.isEmpty)) {
          return 'Please enter $label';
        }
        return null;
      },
    );
  }

  Widget _buildAnimatedSubmitButton() {
    return SizedBox(
      width: double.infinity,
      height: 56,
      child: ElevatedButton(
        onPressed: _isSubmitting ? null : _submitForm,
        style: ElevatedButton.styleFrom(
          backgroundColor: const Color(0xFF1E3A8A),
          foregroundColor: Colors.white,
          elevation: 0,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
        ),
        child: _isSubmitting
            ? const Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: Colors.white,
                    ),
                  ),
                  SizedBox(width: 16),
                  Text('Submitting...', style: TextStyle(color: Colors.white)),
                ],
              )
            : const Text(
                'Submit',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
      ),
    );
  }

  Widget _buildEmptyPainterState() {
    return Container(
      padding: const EdgeInsets.all(32),
      decoration: BoxDecoration(
        color: Colors.grey.shade50,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.shade200),
      ),
      child: Column(
        children: [
          Icon(Icons.people_outline, size: 64, color: Colors.grey.shade400),
          const SizedBox(height: 16),
          Text(
            'No Painters Added',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.w600,
              color: Colors.grey.shade600,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'Add painters to include them in this expert meet claim',
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: Colors.grey.shade500),
          ),
        ],
      ),
    );
  }

  Widget _buildPainterCard(int index) {
    return Container(
      margin: const EdgeInsets.only(bottom: 16),
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: const Color(0xFF1E3A8A).withOpacity(0.1)),
        boxShadow: [
          BoxShadow(
            color: const Color(0xFF1E3A8A).withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header with painter number and delete button
          Row(
            children: [
              Container(
                width: 40,
                height: 40,
                decoration: BoxDecoration(
                  color: const Color(0xFF1E3A8A).withOpacity(0.1),
                  borderRadius: BorderRadius.circular(20),
                ),
                child: Center(
                  child: Text(
                    '${index + 1}',
                    style: TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                      color: const Color(0xFF1E3A8A),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  'Painter ${index + 1}',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: const Color(0xFF1F2937),
                  ),
                ),
              ),
              IconButton(
                onPressed: () => _removePainter(index),
                icon: Icon(Icons.delete_outline, color: Colors.red.shade400),
                style: IconButton.styleFrom(
                  backgroundColor: Colors.red.shade50,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                tooltip: 'Remove Painter',
              ),
            ],
          ),
          const SizedBox(height: 20),
          // Form fields
          Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Mobile Number *',
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                        color: Colors.grey.shade700,
                      ),
                    ),
                    const SizedBox(height: 8),
                    TextFormField(
                      initialValue: _painters[index].mobileNo,
                      onChanged: (value) {
                        _painters[index].mobileNo = value;
                      },
                      keyboardType: TextInputType.phone,
                      decoration: InputDecoration(
                        hintText: 'Enter mobile number',
                        prefixIcon: Icon(
                          Icons.phone,
                          size: 20,
                          color: Colors.grey.shade600,
                        ),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(color: Colors.grey.shade300),
                        ),
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(color: Colors.grey.shade300),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(
                            color: const Color(0xFF1E3A8A),
                            width: 2,
                          ),
                        ),
                        filled: true,
                        fillColor: Colors.grey.shade50,
                        contentPadding: const EdgeInsets.symmetric(
                          horizontal: 12,
                          vertical: 12,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Painter Type *',
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                        color: Colors.grey.shade700,
                      ),
                    ),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<String>(
                      value: _painters[index].type,
                      items: ['Type A', 'Type B', 'Type C'].map((type) {
                        return DropdownMenuItem(value: type, child: Text(type));
                      }).toList(),
                      onChanged: (value) {
                        setState(() {
                          _painters[index].type = value!;
                        });
                      },
                      decoration: InputDecoration(
                        hintText: 'Select type',
                        prefixIcon: Icon(
                          Icons.category,
                          size: 20,
                          color: Colors.grey.shade600,
                        ),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(color: Colors.grey.shade300),
                        ),
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(color: Colors.grey.shade300),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8),
                          borderSide: BorderSide(
                            color: const Color(0xFF1E3A8A),
                            width: 2,
                          ),
                        ),
                        filled: true,
                        fillColor: Colors.grey.shade50,
                        contentPadding: const EdgeInsets.symmetric(
                          horizontal: 12,
                          vertical: 12,
                        ),
                      ),
                      dropdownColor: Colors.white,
                    ),
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          // Name field (full width)
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Painter Name *',
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                  color: Colors.grey.shade700,
                ),
              ),
              const SizedBox(height: 8),
              TextFormField(
                initialValue: _painters[index].name,
                onChanged: (value) {
                  _painters[index].name = value;
                },
                decoration: InputDecoration(
                  hintText: 'Enter painter name',
                  prefixIcon: Icon(
                    Icons.person,
                    size: 20,
                    color: Colors.grey.shade600,
                  ),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: Colors.grey.shade300),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: Colors.grey.shade300),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(
                      color: const Color(0xFF1E3A8A),
                      width: 2,
                    ),
                  ),
                  filled: true,
                  fillColor: Colors.grey.shade50,
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 12,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _showHelpDialog() {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(
                Icons.help_outline_rounded,
                size: 48,
                color: Color(0xFF1E3A8A),
              ),
              const SizedBox(height: 16),
              Text(
                'Expert Meet Claim Help',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: const Color(0xFF1F2937),
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'Fill in all required fields marked with *. '
                'Upload receipts for expense claims.',
                textAlign: TextAlign.center,
                style: TextStyle(color: Colors.grey.shade600),
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () => Navigator.pop(context),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF1E3A8A),
                    foregroundColor: Colors.white,
                  ),
                  child: const Text(
                    'Got it',
                    style: TextStyle(color: Colors.white),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Build process type dropdown
  Widget _buildProcessTypeDropdown() {
    final processTypes = {
      'A': 'Add',
      'U': 'Update',
      'D': 'Delete',
    };

    return DropdownButtonFormField<String>(
      value: _selectedProcessType,
      decoration: InputDecoration(
        labelText: 'Process Type *',
        prefixIcon: Icon(Icons.edit_outlined, color: Colors.grey.shade600),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey.shade300),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF1E3A8A), width: 2),
        ),
        filled: true,
        fillColor: const Color(0xFFF8FAFC),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 16,
        ),
      ),
      items: processTypes.entries.map((entry) {
        return DropdownMenuItem<String>(
          value: entry.key, // Pass API value (A, U, D)
          child: Container(
            color: Colors.white,
            child: Text(entry.value), // Display user-friendly label
          ),
        );
      }).toList(),
      onChanged: (value) async {
        setState(() {
          _selectedProcessType = value;
          _selectedDocument = null;
          _selectedActivity = null;
        });
        await _loadFormData();
      },
      validator: (selectedValue) {
        if (selectedValue == null || selectedValue.isEmpty) {
          return 'Please select Process Type';
        }
        return null;
      },
      dropdownColor: Colors.white,
      style: const TextStyle(color: Colors.black87, fontSize: 16),
      icon: const Icon(Icons.arrow_drop_down, color: Colors.grey),
    );
  }

  // Build document dropdown (for update/delete)
  Widget _buildDocumentDropdown() {
    final items = _documentOptions.map((option) => option.value).toList();
    return _buildModernDropdown(
      value: _selectedDocument,
      label: 'Document Number',
      icon: Icons.description_outlined,
      items: items,
      onChanged: (value) async {
        setState(() {
          _selectedDocument = value;
        });
        if (value != null) {
          await _loadFormData();
        }
      },
      isRequired: true,
    );
  }

  // Build activity dropdown
  Widget _buildActivityDropdown() {
    final items = _activityOptions.map((option) => option.value).toList();
    return _buildModernDropdown(
      value: _selectedActivity,
      label: 'Refer. Activity No',
      icon: Icons.qr_code_outlined,
      items: items,
      onChanged: _onActivitySelected,
      isRequired: true,
    );
  }
}

// Painter model
class Painter {
  String mobileNo;
  String type;
  String name;
  Painter({required this.mobileNo, required this.type, required this.name});
}

// Activity Selection Dialog
class ActivitySelectionDialog extends StatelessWidget {
  final List<String> options;
  const ActivitySelectionDialog({super.key, required this.options});

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: const Color(0xFFF8FAFC),
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            child: const Text(
              'Select Activity',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: Color(0xFF1F2937),
              ),
            ),
          ),
          Expanded(
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: options.length,
              itemBuilder: (context, index) {
                return Container(
                  color: Colors.white,
                  child: ListTile(
                    title: Text(options[index]),
                    onTap: () {
                      Navigator.of(context).pop(options[index]);
                    },
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

