// lib/core/services/contractor_service.dart
import 'dart:async';

import '../models/contractor_models.dart';
import '../utils/app_logger.dart';
import 'api_service.dart';

class ContractorService {
  static final AppLogger _logger = AppLogger();

  // Static caches
  static List<String>? _contractorTypes;
  static List<String>? _emiratesList;

  // -------------------------------
  // Registration
  // -------------------------------
  static Future<ContractorRegistrationResponse> registerContractor(
    ContractorRegistrationRequest request,
  ) async {
    try {
      _logger.info(
        'Registering contractor: ${(request.firstName ?? '').trim()} ${(request.lastName ?? '').trim()}',
      );

      final raw = await ApiService.registerContractor(request.toJson());
      _logger.debug('Register response raw: $raw');

      // Normalize payload to a single map `p`
      Map<String, dynamic> p = {};
      if (raw is Map<String, dynamic>) {
        if (raw.containsKey('success') ||
            raw.containsKey('contractorId') ||
            raw.containsKey('message')) {
          p = raw;
        } else if (raw['data'] is Map<String, dynamic>) {
          p = (raw['data'] as Map<String, dynamic>);
          // bubble up top-level fields if missing
          p = {
            ...p,
            if (!p.containsKey('success') && raw['success'] != null)
              'success': raw['success'],
            if (!p.containsKey('message') && raw['message'] != null)
              'message': raw['message'],
            if (!p.containsKey('error') && raw['error'] != null)
              'error': raw['error'],
            if (!p.containsKey('contractorId') && raw['contractorId'] != null)
              'contractorId': raw['contractorId'],
            if (!p.containsKey('timestamp') && raw['timestamp'] != null)
              'timestamp': raw['timestamp'],
          };
        }
      }

      final success = p['success'] == true;
      final contractorId = p['contractorId']?.toString();
      final error = (p['error'] ?? (raw is Map ? raw['error'] : null))?.toString();
      final timestampRaw =
          (p['timestamp'] ?? (raw is Map ? raw['timestamp'] : null))?.toString();
      final ts = DateTime.tryParse(timestampRaw ?? '') ?? DateTime.now();

      final message = (p['message'] ??
              error ??
              (success ? 'Contractor registered successfully' : 'Registration failed'))
          .toString();

      return ContractorRegistrationResponse(
        success: success,
        message: message,
        contractorId: contractorId,
        error: error,
        timestamp: ts,
      );
    } catch (e) {
      _logger.error('Contractor registration failed: $e');
      return ContractorRegistrationResponse(
        success: false,
        message: 'Registration failed: $e',
        error: e.toString(),
        timestamp: DateTime.now(),
      );
    }
  }

  // -------------------------------
  // Config data (dropdowns)
  // -------------------------------
  static Future<List<String>> getContractorTypes({bool forceRefresh = false}) async {
    if (_contractorTypes != null && !forceRefresh) return _contractorTypes!;
    try {
      _logger.info('Fetching contractor types');
      final result = await ApiService.getContractorTypes();

      if (result is Map && result['success'] == true) {
        final payload = result['data'];
        if (payload is List) {
          _contractorTypes = payload.cast<String>();
          return _contractorTypes!;
        } else if (payload is Map && payload['data'] is List) {
          _contractorTypes = (payload['data'] as List).cast<String>();
          return _contractorTypes!;
        }
      }
      _logger.warning('Using fallback contractor types');
    } catch (e) {
      _logger.error('Failed to fetch contractor types: $e');
    }
    _contractorTypes = ContractorTypes.all;
    return _contractorTypes!;
  }

  static Future<List<String>> getEmiratesList({bool forceRefresh = false}) async {
    if (_emiratesList != null && !forceRefresh) return _emiratesList!;
    try {
      _logger.info('Fetching emirates list');
      final result = await ApiService.getEmiratesList();

      if (result is Map && result['success'] == true) {
        final payload = result['data'];
        if (payload is List) {
          _emiratesList = payload.cast<String>();
          return _emiratesList!;
        } else if (payload is Map && payload['data'] is List) {
          _emiratesList = (payload['data'] as List).cast<String>();
          return _emiratesList!;
        }
      }
      _logger.warning('Using fallback emirates list');
    } catch (e) {
      _logger.error('Failed to fetch emirates list: $e');
    }
    _emiratesList = EmiratesConstants.all;
    return _emiratesList!;
  }

  // -------------------------------
  // Validation
  // -------------------------------

  static bool isValidMobileNumber(String mobileNumber) {
    // UAE mobile: +971XXXXXXXXX or 05XXXXXXXX
    final regex = RegExp(r'^(\+971|971|0)?[5][0-9]{8}$');
    return regex.hasMatch(mobileNumber.replaceAll(' ', '').replaceAll('-', ''));
  }

  static bool isValidIban(String iban) {
    // UAE IBAN: AE + 21 digits
    final regex = RegExp(r'^AE\d{21}$');
    return regex.hasMatch(iban.replaceAll(' ', ''));
  }

  static bool isValidDate(String date) {
    if (date.isEmpty) return false;
    try {
      DateTime.parse(date);
      return true;
    } catch (_) {
      return false;
    }
  }

  static String? validateRequiredField(String? value, String fieldName) {
    if (value == null || value.trim().isEmpty) {
      return '$fieldName is required';
    }
    return null;
  }

  static String? validateMobileNumber(String? value) {
    if (value == null || value.trim().isEmpty) {
      return 'Mobile number is required';
    }
    if (!isValidMobileNumber(value)) {
      return 'Please enter a valid UAE mobile number';
    }
    return null;
  }

  static String? validateIban(String? value) {
    if (value != null && value.isNotEmpty && !isValidIban(value)) {
      return 'Please enter a valid UAE IBAN (AE followed by 21 digits)';
    }
    return null;
  }

  static String? validateEmail(String? value) {
    if (value != null && value.isNotEmpty) {
      final regex = RegExp(r'^[^@]+@[^@]+\.[^@]+$');
      if (!regex.hasMatch(value)) {
        return 'Please enter a valid email address';
      }
    }
    return null;
  }

  // -------------------------------
  // Formatting
  // -------------------------------

  /// Accepts nullable and returns nullable so your request model can stay nullable-friendly.
  static String? formatMobileNumber(String? mobile) {
    if (mobile == null || mobile.isEmpty) return null;
    String cleaned = mobile.replaceAll(RegExp(r'[^0-9+]'), '');
    if (cleaned.startsWith('05')) {
      cleaned = '+971${cleaned.substring(1)}';
    } else if (cleaned.startsWith('5')) {
      cleaned = '+971$cleaned';
    } else if (!cleaned.startsWith('+971')) {
      cleaned = '+971$cleaned';
    }
    return cleaned;
  }

  static String formatIban(String iban) {
    String cleaned = iban.replaceAll(' ', '').toUpperCase();
    final buffer = StringBuffer();
    for (int i = 0; i < cleaned.length; i += 4) {
      final end = (i + 4 <= cleaned.length) ? i + 4 : cleaned.length;
      buffer.write(cleaned.substring(i, end));
      if (end < cleaned.length) buffer.write(' ');
    }
    return buffer.toString();
  }

  // -------------------------------
  // Cache
  // -------------------------------
  static void clearCache() {
    _contractorTypes = null;
    _emiratesList = null;
  }
}











// lib/core/models/contractor_models.dart
class ContractorRegistrationRequest {
  // Personal
  final String? contractorType;
  final String? firstName;
  final String? middleName;
  final String? lastName;
  final String? mobileNumber;
  final String? address;
  final String? area;
  final String? emirates;
  final String? reference;
  final String? profilePhoto;

  // Bank
  final String? accountHolderName;
  final String? ibanNumber;
  final String? bankName;
  final String? branchName;
  final String? bankAddress;

  // VAT
  final String? vatCertificate;
  final String? firmName;
  final String? vatAddress;
  final String? taxRegistrationNumber;
  final String? vatEffectiveDate;

  // License
  final String? licenseDocument;
  final String? licenseNumber;
  final String? issuingAuthority;
  final String? licenseType;
  final String? establishmentDate;
  final String? licenseExpiryDate;
  final String? tradeName;
  final String? responsiblePerson;
  final String? licenseAddress;
  final String? effectiveDate;

  ContractorRegistrationRequest({
    this.contractorType,
    this.firstName,
    this.middleName,
    this.lastName,
    this.mobileNumber,
    this.address,
    this.area,
    this.emirates,
    this.reference,
    this.profilePhoto,
    this.accountHolderName,
    this.ibanNumber,
    this.bankName,
    this.branchName,
    this.bankAddress,
    this.vatCertificate,
    this.firmName,
    this.vatAddress,
    this.taxRegistrationNumber,
    this.vatEffectiveDate,
    this.licenseDocument,
    this.licenseNumber,
    this.issuingAuthority,
    this.licenseType,
    this.establishmentDate,
    this.licenseExpiryDate,
    this.tradeName,
    this.responsiblePerson,
    this.licenseAddress,
    this.effectiveDate,
  });

  Map<String, dynamic> toJson() => {
        "contractorType": contractorType,
        "firstName": firstName,
        "middleName": middleName,
        "lastName": lastName,
        "mobileNumber": mobileNumber,
        "address": address,
        "area": area,
        "emirates": emirates,
        "reference": reference,
        "profilePhoto": profilePhoto,
        "accountHolderName": accountHolderName,
        "ibanNumber": ibanNumber,
        "bankName": bankName,
        "branchName": branchName,
        "bankAddress": bankAddress,
        "vatCertificate": vatCertificate,
        "firmName": firmName,
        "vatAddress": vatAddress,
        "taxRegistrationNumber": taxRegistrationNumber,
        "vatEffectiveDate": vatEffectiveDate,
        "licenseDocument": licenseDocument,
        "licenseNumber": licenseNumber,
        "issuingAuthority": issuingAuthority,
        "licenseType": licenseType,
        "establishmentDate": establishmentDate,
        "licenseExpiryDate": licenseExpiryDate,
        "tradeName": tradeName,
        "responsiblePerson": responsiblePerson,
        "licenseAddress": licenseAddress,
        "effectiveDate": effectiveDate,
      };
}

class ContractorRegistrationResponse {
  final bool success;
  final String? message;
  final String? contractorId;
  final String? error;
  final DateTime? timestamp;

  ContractorRegistrationResponse({
    required this.success,
    this.message,
    this.contractorId,
    this.error,
    this.timestamp,
  });

  factory ContractorRegistrationResponse.fromApi(Map<String, dynamic> json) {
    return ContractorRegistrationResponse(
      success: json['success'] == true,
      message: json['message']?.toString(),
      contractorId: json['contractorId']?.toString(),
      error: json['error']?.toString(),
      timestamp: DateTime.tryParse(json['timestamp']?.toString() ?? ''),
    );
  }

  factory ContractorRegistrationResponse.fromJson(Map<String, dynamic> json) {
    if (json.containsKey('success') || json.containsKey('contractorId')) {
      return ContractorRegistrationResponse.fromApi(json);
    }
    final data = (json['data'] is Map<String, dynamic>)
        ? json['data'] as Map<String, dynamic>
        : <String, dynamic>{};
    return ContractorRegistrationResponse.fromApi(data);
  }
}

class ContractorTypes {
  static const List<String> all = <String>[
    'Maintenance Contractor',
    'Petty contractors',
  ];
}

class EmiratesConstants {
  static const List<String> all = <String>[
    'Dubai',
    'Abu Dhabi',
    'Sharjah',
    'Ajman',
    'Umm Al Quwain',
    'Ras Al Khaimah',
    'Fujairah',
  ];
}

