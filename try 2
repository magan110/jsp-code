import 'dart:async';
import 'dart:convert';
import 'dart:io' show File;
import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:universal_html/js.dart' as js;
import 'package:pdfx/pdfx.dart';

class BankDetailsData {
  final String? accountHolderName;
  final String? accountNumber;
  final String? ibanNumber;
  final String? bankName;
  final String? branchName;
  final String? bankAddress;
  final String? routingNumber;
  final String? swiftCode;
  final String? accountType;
  final String? currency;

  BankDetailsData({
    this.accountHolderName,
    this.accountNumber,
    this.ibanNumber,
    this.bankName,
    this.branchName,
    this.bankAddress,
    this.routingNumber,
    this.swiftCode,
    this.accountType,
    this.currency,
  });

  Map<String, dynamic> toJson() {
    return {
      'accountHolderName': accountHolderName,
      'accountNumber': accountNumber,
      'ibanNumber': ibanNumber,
      'bankName': bankName,
      'branchName': branchName,
      'bankAddress': bankAddress,
      'routingNumber': routingNumber,
      'swiftCode': swiftCode,
      'accountType': accountType,
      'currency': currency,
    };
  }

  factory BankDetailsData.fromJson(Map<String, dynamic> json) {
    return BankDetailsData(
      accountHolderName: json['accountHolderName'],
      accountNumber: json['accountNumber'],
      ibanNumber: json['ibanNumber'],
      bankName: json['bankName'],
      branchName: json['branchName'],
      bankAddress: json['bankAddress'],
      routingNumber: json['routingNumber'],
      swiftCode: json['swiftCode'],
      accountType: json['accountType'],
      currency: json['currency'],
    );
  }

  bool get isValid {
    return accountHolderName != null &&
        (accountNumber != null || ibanNumber != null) &&
        bankName != null;
  }
}

class BankDetailsOCRService {
  // Main OCR processing method for bank documents
  static Future<BankDetailsData> processBankDocument(String imagePath) async {
    if (kIsWeb) {
      print('=== WEB BANK DOCUMENT OCR START ===');
      return _processWebBankDocument(imagePath);
    }

    // Check if file is a PDF
    if (imagePath.toLowerCase().endsWith('.pdf') ||
        imagePath.startsWith('data:application/pdf')) {
      print('=== BANK PDF PROCESSING DETECTED ===');
      return _processBankPdfFile(imagePath);
    }

    try {
      print('=== STARTING BANK DOCUMENT TESSERACT OCR ===');
      return _processBankTesseractMobile(imagePath);
    } catch (e) {
      print('Bank document Tesseract error: $e');
      return BankDetailsData();
    }
  }

  // PDF processing method for bank documents
  static Future<BankDetailsData> _processBankPdfFile(String pdfPath) async {
    try {
      print('=== BANK PDF PROCESSING START ===');
      print('Processing bank PDF: $pdfPath');

      PdfDocument? document;

      // Handle different PDF path types
      if (pdfPath.startsWith('data:application/pdf')) {
        final parts = pdfPath.split(',');
        if (parts.length == 2) {
          final bytes = base64Decode(parts[1]);
          document = await PdfDocument.openData(bytes);
        }
      } else if (pdfPath.startsWith('http')) {
        document = await PdfDocument.openFile(pdfPath);
      } else if (!kIsWeb) {
        document = await PdfDocument.openFile(pdfPath);
      }

      if (document == null) {
        print('Failed to load bank PDF document');
        return BankDetailsData();
      }

      String combinedText = '';

      // Process each page of the PDF (bank statements usually have multiple pages)
      for (
        int pageNum = 1;
        pageNum <= document.pagesCount && pageNum <= 3;
        pageNum++
      ) {
        try {
          final page = await document.getPage(pageNum);

          // Render page as high-quality image for better OCR
          final pageImage = await page.render(
            width: (page.width * 3).toDouble(),
            height: (page.height * 3).toDouble(),
            format: PdfPageImageFormat.png,
            backgroundColor: '#FFFFFF',
          );

          if (pageImage != null) {
            final processedBytes = await _preprocessBankImageForOCR(
              pageImage.bytes,
            );
            final pageText = await _processBankTesseractFromBytes(
              processedBytes,
            );
            combinedText += '$pageText\n';

            print(
              'Bank PDF Page $pageNum text extracted (${pageText.length} chars)',
            );
          }

          await page.close();
        } catch (pageError) {
          print('Error processing bank PDF page $pageNum: $pageError');
          continue;
        }
      }

      await document.close();

      if (combinedText.isEmpty) {
        print('No text extracted from bank PDF');
        return BankDetailsData();
      }

      print('Combined bank PDF text length: ${combinedText.length}');
      final extractedData = _extractBankDataFromText(combinedText);

      print('=== BANK PDF EXTRACTION RESULTS ===');
      print('Account Holder: ${extractedData.accountHolderName}');
      print('Account Number: ${extractedData.accountNumber}');
      print('IBAN: ${extractedData.ibanNumber}');
      print('Bank Name: ${extractedData.bankName}');
      print('Branch: ${extractedData.branchName}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END BANK PDF EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('Bank PDF processing error: $e');
      return BankDetailsData();
    }
  }

  // Web-compatible bank document processing
  static Future<BankDetailsData> _processWebBankDocument(
    String imagePath,
  ) async {
    try {
      print('=== WEB BANK DOCUMENT OCR PROCESSING START ===');
      print('Processing bank document: $imagePath');

      // Check if it's a PDF in web environment
      if (imagePath.startsWith('data:application/pdf') ||
          imagePath.toLowerCase().endsWith('.pdf')) {
        return _processWebBankPdf(imagePath);
      }

      final extractedText = await _extractBankTextWithTesseract(imagePath);

      if (extractedText.isEmpty) {
        print('No text extracted from bank document');
        return BankDetailsData();
      }

      print('Extracted bank text length: ${extractedText.length}');
      final extractedData = _extractBankDataFromText(extractedText);

      print('=== BANK DOCUMENT EXTRACTION RESULTS ===');
      print('Account Holder: ${extractedData.accountHolderName}');
      print('Account Number: ${extractedData.accountNumber}');
      print('IBAN: ${extractedData.ibanNumber}');
      print('Bank Name: ${extractedData.bankName}');
      print('Branch: ${extractedData.branchName}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END BANK DOCUMENT EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('Web bank document OCR error: $e');
      return BankDetailsData();
    }
  }

  // Web PDF processing method for bank documents
  static Future<BankDetailsData> _processWebBankPdf(String pdfPath) async {
    try {
      print('=== WEB BANK PDF PROCESSING START ===');
      print('Processing bank PDF in web: $pdfPath');

      PdfDocument? document;

      if (pdfPath.startsWith('data:application/pdf')) {
        final parts = pdfPath.split(',');
        if (parts.length == 2) {
          final bytes = base64Decode(parts[1]);
          document = await PdfDocument.openData(bytes);
        }
      } else {
        document = await PdfDocument.openFile(pdfPath);
      }

      if (document == null) {
        print('Failed to load bank PDF document in web');
        return BankDetailsData();
      }

      String combinedText = '';

      // Process first 3 pages maximum for bank documents
      for (
        int pageNum = 1;
        pageNum <= document.pagesCount && pageNum <= 3;
        pageNum++
      ) {
        try {
          final page = await document.getPage(pageNum);

          final pageImage = await page.render(
            width: (page.width * 3).toDouble(),
            height: (page.height * 3).toDouble(),
            format: PdfPageImageFormat.png,
            backgroundColor: '#FFFFFF',
          );

          if (pageImage != null) {
            final processedBytes = await _preprocessBankImageForOCR(
              pageImage.bytes,
            );
            final base64Image =
                'data:image/png;base64,${base64Encode(processedBytes)}';

            final pageText = await _extractBankTextWithTesseract(base64Image);
            combinedText += '$pageText\n';

            print(
              'Web Bank PDF Page $pageNum text extracted (${pageText.length} chars)',
            );
          }

          await page.close();
        } catch (pageError) {
          print('Error processing web bank PDF page $pageNum: $pageError');
          continue;
        }
      }

      await document.close();

      if (combinedText.isEmpty) {
        print('No text extracted from web bank PDF');
        return BankDetailsData();
      }

      print('Combined web bank PDF text length: ${combinedText.length}');
      final extractedData = _extractBankDataFromText(combinedText);

      print('=== WEB BANK PDF EXTRACTION RESULTS ===');
      print('Account Holder: ${extractedData.accountHolderName}');
      print('Account Number: ${extractedData.accountNumber}');
      print('IBAN: ${extractedData.ibanNumber}');
      print('Bank Name: ${extractedData.bankName}');
      print('Branch: ${extractedData.branchName}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END WEB BANK PDF EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('Web bank PDF processing error: $e');
      return BankDetailsData();
    }
  }

  // Extract text using Tesseract for bank documents
  static Future<String> _extractBankTextWithTesseract(String imagePath) async {
    try {
      print('Calling Tesseract OCR for bank document...');
      print('Image path: $imagePath');

      final completer = Completer<String>();

      js.context['dartBankTesseractCallback'] = js.allowInterop((
        String result,
      ) {
        if (!completer.isCompleted) {
          print('Bank document Tesseract OCR result received');
          print('Bank OCR result length: ${result.length}');
          completer.complete(result);
        }
      });

      js.context['dartBankTesseractErrorCallback'] = js.allowInterop((
        dynamic error,
      ) {
        if (!completer.isCompleted) {
          print('Bank document Tesseract OCR error: $error');
          completer.complete('');
        }
      });

      // Call the specialized bank document OCR JavaScript function
      js.context.callMethod('eval', [
        '''
        processBankDocumentWithOCR("$imagePath")
          .then(function(result) {
            if (window.dartBankTesseractCallback) {
              window.dartBankTesseractCallback(result || '');
            }
          })
          .catch(function(error) {
            if (window.dartBankTesseractErrorCallback) {
              window.dartBankTesseractErrorCallback(error);
            }
          });
      ''',
      ]);

      final result = await completer.future;

      // Clean up callbacks
      js.context['dartBankTesseractCallback'] = null;
      js.context['dartBankTesseractErrorCallback'] = null;

      return result;
    } catch (e) {
      print('Bank document Tesseract OCR failed: $e');
      return '';
    }
  }

  // Mobile bank document processing
  static Future<BankDetailsData> _processBankTesseractMobile(
    String imagePath,
  ) async {
    try {
      print('=== MOBILE BANK DOCUMENT TESSERACT OCR START ===');
      print('Processing bank document: $imagePath');

      if (kIsWeb) {
        final extractedText = await _extractBankTextWithTesseract(imagePath);
        if (extractedText.isEmpty) {
          return BankDetailsData();
        }
        return _extractBankDataFromText(extractedText);
      } else {
        print('Native mobile bank document Tesseract not implemented');
        return BankDetailsData();
      }
    } catch (e) {
      print('Mobile bank document Tesseract error: $e');
      return BankDetailsData();
    }
  }

  // Process bank document from bytes using Tesseract
  static Future<String> _processBankTesseractFromBytes(
    Uint8List imageBytes,
  ) async {
    try {
      print('=== BANK DOCUMENT TESSERACT FROM BYTES ===');

      final base64Image = 'data:image/png;base64,${base64Encode(imageBytes)}';
      return await _extractBankTextWithTesseract(base64Image);
    } catch (e) {
      print('Bank document Tesseract from bytes error: $e');
      return '';
    }
  }

  // Process bank document from bytes (public method)
  static Future<BankDetailsData> processBankDetailsFromBytes(
    Uint8List imageBytes,
  ) async {
    try {
      final extractedText = await _processBankTesseractFromBytes(imageBytes);
      if (extractedText.isEmpty) {
        return BankDetailsData();
      }
      return _extractBankDataFromText(extractedText);
    } catch (e) {
      print('Process bank details from bytes failed: $e');
      return BankDetailsData();
    }
  }

  // Bank document image preprocessing for better OCR results
  static Future<Uint8List> _preprocessBankImageForOCR(
    Uint8List imageBytes,
  ) async {
    try {
      if (kIsWeb) {
        return await _preprocessBankImageWeb(imageBytes);
      } else {
        return imageBytes;
      }
    } catch (e) {
      print('Bank document image preprocessing failed: $e');
      return imageBytes;
    }
  }

  // Web-based bank document image preprocessing
  static Future<Uint8List> _preprocessBankImageWeb(Uint8List imageBytes) async {
    try {
      print('=== WEB BANK DOCUMENT IMAGE PREPROCESSING ===');

      final completer = Completer<Uint8List>();

      js.context['dartBankImageProcessCallback'] = js.allowInterop((
        List<int> result,
      ) {
        if (!completer.isCompleted) {
          print('Bank document image preprocessing completed');
          completer.complete(Uint8List.fromList(result.cast<int>()));
        }
      });

      js.context['dartBankImageProcessErrorCallback'] = js.allowInterop((
        dynamic error,
      ) {
        if (!completer.isCompleted) {
          print('Bank document image preprocessing error: $error');
          completer.complete(imageBytes);
        }
      });

      final base64Image = base64Encode(imageBytes);

      js.context.callMethod('eval', [
        '''
        preprocessBankImageForOCR("data:image/png;base64,$base64Image")
          .then(function(result) {
            if (window.dartBankImageProcessCallback) {
              window.dartBankImageProcessCallback(result || []);
            }
          })
          .catch(function(error) {
            if (window.dartBankImageProcessErrorCallback) {
              window.dartBankImageProcessErrorCallback(error);
            }
          });
      ''',
      ]);

      final result = await completer.future;

      js.context['dartBankImageProcessCallback'] = null;
      js.context['dartBankImageProcessErrorCallback'] = null;

      return result;
    } catch (e) {
      print('Web bank document image preprocessing failed: $e');
      return imageBytes;
    }
  }

  // Extract bank details from OCR text
  static BankDetailsData _extractBankDataFromText(String ocrText) {
    String? accountHolderName;
    String? accountNumber;
    String? ibanNumber;
    String? bankName;
    String? branchName;
    String? bankAddress;
    String? routingNumber;
    String? swiftCode;
    String? accountType;
    String? currency;

    final lines = ocrText.split('\n');
    print('=== RAW BANK DOCUMENT OCR TEXT ===');
    print(ocrText);
    print('=== END RAW BANK TEXT ===');
    print('Lines count: ${lines.length}');

    final fullText = ocrText.toLowerCase();

    // Extract account holder name patterns
    final accountHolderPatterns = [
      RegExp(r'account\s+holder[:\s]*([a-zA-Z\s]{3,50})', caseSensitive: false),
      RegExp(r'beneficiary[:\s]*([a-zA-Z\s]{3,50})', caseSensitive: false),
      RegExp(r'name[:\s]*([a-zA-Z\s]{3,50})', caseSensitive: false),
      RegExp(r'customer[:\s]*([a-zA-Z\s]{3,50})', caseSensitive: false),
    ];

    for (final pattern in accountHolderPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null &&
          match.group(1) != null &&
          accountHolderName == null) {
        var extractedName = match.group(1)!.trim();
        extractedName = extractedName
            .replaceAll(RegExp(r'[^a-zA-Z\s]'), '')
            .replaceAll(RegExp(r'\s+'), ' ')
            .trim();
        if (extractedName.length >= 3) {
          accountHolderName = _cleanAccountHolderName(extractedName);
          break;
        }
      }
    }

    // Extract IBAN number (UAE format: AE00 0000 0000 0000 0000 000)
    final ibanPatterns = [
      RegExp(
        r'AE\d{2}\s*\d{4}\s*\d{4}\s*\d{4}\s*\d{4}\s*\d{3}',
        caseSensitive: false,
      ),
      RegExp(
        r'IBAN[:\s]*AE\d{2}\s*\d{4}\s*\d{4}\s*\d{4}\s*\d{4}\s*\d{3}',
        caseSensitive: false,
      ),
      RegExp(r'AE\d{21}', caseSensitive: false),
    ];

    for (final pattern in ibanPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && ibanNumber == null) {
        ibanNumber = match
            .group(0)!
            .replaceAll(RegExp(r'\s+'), '')
            .toUpperCase();
        break;
      }
    }

    // Extract account number patterns
    final accountNumberPatterns = [
      RegExp(r'account\s+number[:\s]*(\d{8,20})', caseSensitive: false),
      RegExp(r'account[:\s]*(\d{8,20})', caseSensitive: false),
      RegExp(r'acc\.?\s*no\.?[:\s]*(\d{8,20})', caseSensitive: false),
      RegExp(r'(\d{10,20})'), // Generic long number pattern
    ];

    for (final pattern in accountNumberPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && accountNumber == null) {
        final extractedNumber = match.group(1)!;
        if (extractedNumber.length >= 8) {
          accountNumber = extractedNumber;
          break;
        }
      }
    }

    // Extract UAE bank names
    final uaeBanks = [
      'emirates nbd',
      'enbd',
      'emirates national bank',
      'adcb',
      'abu dhabi commercial bank',
      'fab',
      'first abu dhabi bank',
      'mashreq',
      'mashreq bank',
      'cbd',
      'commercial bank of dubai',
      'noor bank',
      'hsbc',
      'hsbc bank middle east',
      'standard chartered',
      'citibank',
      'rak bank',
      'ajman bank',
      'union national bank',
      'unb',
      'invest bank',
      'sharjah islamic bank',
      'dubai islamic bank',
      'dib',
      'abu dhabi islamic bank',
      'adib',
    ];

    for (final bank in uaeBanks) {
      if (fullText.contains(bank.toLowerCase()) && bankName == null) {
        bankName = _formatBankName(bank);
        break;
      }
    }

    // Extract branch information with enhanced patterns
    final branchPatterns = [
      // Standard branch patterns
      RegExp(r'branch[:\s]*([a-zA-Z\s\-&]{3,40})', caseSensitive: false),
      RegExp(r'branch\s+name[:\s]*([a-zA-Z\s\-&]{3,40})', caseSensitive: false),
      RegExp(r'location[:\s]*([a-zA-Z\s\-&]{3,40})', caseSensitive: false),
      // UAE specific patterns
      RegExp(
        r'dubai\s+branch[:\s]*([a-zA-Z\s\-&]{3,40})',
        caseSensitive: false,
      ),
      RegExp(
        r'abu\s+dhabi\s+branch[:\s]*([a-zA-Z\s\-&]{3,40})',
        caseSensitive: false,
      ),
      RegExp(
        r'sharjah\s+branch[:\s]*([a-zA-Z\s\-&]{3,40})',
        caseSensitive: false,
      ),
      // Common branch naming patterns
      RegExp(r'br\.[:\s]*([a-zA-Z\s\-&]{3,40})', caseSensitive: false),
      RegExp(
        r'branch\s*code[:\s]*\d+[,\s]*([a-zA-Z\s\-&]{3,40})',
        caseSensitive: false,
      ),
      // Geographic patterns
      RegExp(
        r'(?:at|in)\s+([a-zA-Z\s\-&]{3,40})\s+branch',
        caseSensitive: false,
      ),
    ];

    // Try each pattern to extract branch name
    for (final pattern in branchPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && branchName == null) {
        String? extractedBranch = match.group(1)!.trim();
        extractedBranch = _cleanBranchName(extractedBranch);
        if (extractedBranch != null && extractedBranch.length >= 3) {
          branchName = extractedBranch;
          break;
        }
      }
    }

    // If no branch found with patterns, try UAE location-based extraction
    if (branchName == null) {
      final uaeLocations = [
        'Dubai',
        'Abu Dhabi',
        'Sharjah',
        'Ajman',
        'Ras Al Khaimah',
        'RAK',
        'Fujairah',
        'Umm Al Quwain',
        'Al Ain',
        'ADCB',
        'ENBD',
        'FAB',
        'Downtown',
        'Marina',
        'JLT',
        'DIFC',
        'Business Bay',
        'Deira',
        'Bur Dubai',
        'Sheikh Zayed Road',
        'Mall of Emirates',
        'Dubai Mall',
        'Ibn Battuta',
        'Dragon Mart',
        'Karama',
        'Satwa',
        'Jumeirah',
        'Al Barsha',
        'Motor City',
        'International City',
        'Discovery Gardens',
        'Silicon Oasis',
        'Academic City',
        'Healthcare City',
        'Sports City',
        'Al Wasl',
        'Al Qusais',
        'Al Nahda',
        'Mirdif',
        'Festival City',
      ];

      for (final location in uaeLocations) {
        if (fullText.contains(location.toLowerCase()) && branchName == null) {
          // Extract surrounding context for better branch name
          final locationIndex = fullText.indexOf(location.toLowerCase());
          final contextStart = (locationIndex - 20).clamp(0, fullText.length);
          final contextEnd = (locationIndex + location.length + 20).clamp(
            0,
            fullText.length,
          );
          final context = ocrText.substring(contextStart, contextEnd);

          // Try to extract a more complete branch name from context
          final contextPattern = RegExp(
            r'([a-zA-Z\s\-&]*' + RegExp.escape(location) + r'[a-zA-Z\s\-&]*)',
            caseSensitive: false,
          );
          final contextMatch = contextPattern.firstMatch(context);
          if (contextMatch != null) {
            final candidateBranch = _cleanBranchName(contextMatch.group(1)!);
            if (candidateBranch != null && candidateBranch.length >= 3) {
              branchName = candidateBranch;
              break;
            }
          }

          // Fallback to just the location name
          if (branchName == null) {
            branchName = location;
          }
          break;
        }
      }
    }

    // Extract SWIFT code
    final swiftPattern = RegExp(
      r'swift[:\s]*([A-Z]{8}|[A-Z]{11})',
      caseSensitive: false,
    );
    final swiftMatch = swiftPattern.firstMatch(ocrText);
    if (swiftMatch != null && swiftMatch.group(1) != null) {
      swiftCode = swiftMatch.group(1)!.toUpperCase();
    }

    // Extract currency (UAE Dirham patterns)
    final currencyPatterns = [
      RegExp(r'\bAED\b', caseSensitive: false),
      RegExp(r'\bDHS?\b', caseSensitive: false),
      RegExp(r'dirham', caseSensitive: false),
    ];

    for (final pattern in currencyPatterns) {
      if (pattern.hasMatch(ocrText) && currency == null) {
        currency = 'AED';
        break;
      }
    }

    // Extract account type
    final accountTypePatterns = [
      RegExp(r'savings\s+account', caseSensitive: false),
      RegExp(r'current\s+account', caseSensitive: false),
      RegExp(r'checking\s+account', caseSensitive: false),
      RegExp(r'salary\s+account', caseSensitive: false),
    ];

    for (final pattern in accountTypePatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && accountType == null) {
        accountType = _cleanAccountType(match.group(0)!);
        break;
      }
    }

    // Line-by-line processing for additional patterns
    for (int i = 0; i < lines.length; i++) {
      final line = lines[i].trim();
      final lowerLine = line.toLowerCase();

      // Extract bank address
      if (lowerLine.contains('address') && bankAddress == null) {
        bankAddress = _extractValueAfterColon(line);
        if (bankAddress == null && i + 1 < lines.length) {
          bankAddress = lines[i + 1].trim();
        }
      }

      // Extract routing number
      if (lowerLine.contains('routing') && routingNumber == null) {
        final routingMatch = RegExp(
          r'routing[:\s]*(\d{9})',
          caseSensitive: false,
        ).firstMatch(line);
        if (routingMatch != null) {
          routingNumber = routingMatch.group(1);
        }
      }

      // Additional fallback patterns for branch name
      if (branchName == null) {
        // Look for lines that might contain branch information
        final fallbackBranchPatterns = [
          // Address-based patterns (branches often mentioned in addresses)
          RegExp(r'([A-Za-z\s\-&]{3,30})\s+branch', caseSensitive: false),
          RegExp(r'branch\s+([A-Za-z\s\-&]{3,30})', caseSensitive: false),
          // Phone/contact patterns (branch contact info)
          RegExp(
            r'phone[:\s]*\+971[^,]*,?\s*([A-Za-z\s\-&]{3,30})',
            caseSensitive: false,
          ),
          // PO Box patterns (branch postal info)
          RegExp(
            r'p\.?o\.?\s*box[:\s]*\d+[,\s]*([A-Za-z\s\-&]{3,30})',
            caseSensitive: false,
          ),
          // Service center patterns
          RegExp(
            r'service\s+center[:\s]*([A-Za-z\s\-&]{3,30})',
            caseSensitive: false,
          ),
          // Regional office patterns
          RegExp(
            r'regional\s+office[:\s]*([A-Za-z\s\-&]{3,30})',
            caseSensitive: false,
          ),
        ];

        for (final pattern in fallbackBranchPatterns) {
          final match = pattern.firstMatch(line);
          if (match != null && match.group(1) != null) {
            final candidateBranch = _cleanBranchName(match.group(1)!);
            if (candidateBranch != null && candidateBranch.length >= 3) {
              branchName = candidateBranch;
              break;
            }
          }
        }
      }
    }

    // Final fallback: Extract branch from address or context if still not found
    if (branchName == null && bankAddress != null) {
      // Try to extract location from bank address
      final addressWords = bankAddress!.split(' ');
      for (final word in addressWords) {
        if (word.length > 2) {
          final candidateBranch = _cleanBranchName(word);
          if (candidateBranch != null && candidateBranch.length >= 3) {
            // Validate it's not just a common address word
            final commonAddressWords = [
              'street',
              'road',
              'avenue',
              'building',
              'tower',
              'floor',
              'office',
              'suite',
              'unit',
            ];
            if (!commonAddressWords.contains(candidateBranch.toLowerCase())) {
              branchName = candidateBranch;
              break;
            }
          }
        }
      }
    }

    return BankDetailsData(
      accountHolderName: accountHolderName,
      accountNumber: accountNumber,
      ibanNumber: ibanNumber,
      bankName: bankName,
      branchName: branchName,
      bankAddress: bankAddress,
      routingNumber: routingNumber,
      swiftCode: swiftCode,
      accountType: accountType,
      currency: currency,
    );
  }

  // Helper methods for cleaning extracted bank data
  static String? _cleanAccountHolderName(String? name) {
    if (name == null || name.isEmpty) return null;

    name = name.replaceAll(RegExp(r'[^\w\s]'), ' ');
    name = name.replaceAll(RegExp(r'\s+'), ' ').trim();

    return name
        .split(' ')
        .where((word) => word.isNotEmpty)
        .map((word) => word[0].toUpperCase() + word.substring(1).toLowerCase())
        .join(' ');
  }

  static String? _cleanBranchName(String? branch) {
    if (branch == null || branch.isEmpty) return null;

    // Remove common OCR artifacts and unwanted characters
    branch = branch
        .replaceAll(
          RegExp(r'[^\w\s\-&]'),
          ' ',
        ) // Keep alphanumeric, spaces, hyphens, and ampersands
        .replaceAll(
          RegExp(r'\b(branch|br|location|loc)\b', caseSensitive: false),
          '',
        ) // Remove redundant words
        .replaceAll(RegExp(r'\s+'), ' ') // Normalize spaces
        .trim();

    if (branch.length < 2) return null;

    // Filter out common OCR noise words
    final noiseWords = [
      'the',
      'at',
      'in',
      'and',
      'or',
      'of',
      'to',
      'for',
      'with',
    ];
    final words = branch.split(' ');
    final cleanWords = words
        .where(
          (word) => word.length > 1 && !noiseWords.contains(word.toLowerCase()),
        )
        .toList();

    if (cleanWords.isEmpty) return null;

    final cleanedBranch = cleanWords.join(' ');
    if (cleanedBranch.length < 2) return null;

    // Validate that it looks like a real branch name (not just numbers or single letters)
    if (RegExp(r'^[\d\s]+$').hasMatch(cleanedBranch))
      return null; // Only digits
    if (RegExp(r'^[A-Za-z]{1,2}$').hasMatch(cleanedBranch))
      return null; // Single/double letter

    return _capitalizeWords(cleanedBranch);
  }

  static String? _cleanAccountType(String? type) {
    if (type == null || type.isEmpty) return null;

    return _capitalizeWords(type.trim());
  }

  static String _formatBankName(String bank) {
    return bank
        .split(' ')
        .map((word) => word[0].toUpperCase() + word.substring(1).toLowerCase())
        .join(' ');
  }

  static String? _extractValueAfterColon(String line) {
    final parts = line.split(':');
    if (parts.length > 1) {
      return parts[1].trim();
    }
    return null;
  }

  static String _capitalizeWords(String text) {
    return text
        .split(' ')
        .map(
          (word) => word.isNotEmpty
              ? word[0].toUpperCase() + word.substring(1).toLowerCase()
              : word,
        )
        .join(' ');
  }

  // Validation methods
  static bool validateIBANFormat(String iban) {
    final pattern = RegExp(r'^AE\d{21}$');
    return pattern.hasMatch(iban.replaceAll(' ', ''));
  }

  static bool validateAccountNumber(String accountNumber) {
    return accountNumber.length >= 8 && accountNumber.length <= 20;
  }

  // Auto-fill form fields mapping for bank details
  static Map<String, String> getBankFormFieldMapping(BankDetailsData data) {
    final mapping = <String, String>{};

    if (data.accountHolderName != null) {
      mapping['accountHolderName'] = data.accountHolderName!;
    }
    if (data.accountNumber != null) {
      mapping['accountNumber'] = data.accountNumber!;
    }
    if (data.ibanNumber != null) {
      mapping['ibanNumber'] = data.ibanNumber!;
    }
    if (data.bankName != null) {
      mapping['bankName'] = data.bankName!;
    }
    if (data.branchName != null) {
      mapping['branchName'] = data.branchName!;
    }
    if (data.bankAddress != null) {
      mapping['bankAddress'] = data.bankAddress!;
    }
    if (data.swiftCode != null) {
      mapping['swiftCode'] = data.swiftCode!;
    }
    if (data.routingNumber != null) {
      mapping['routingNumber'] = data.routingNumber!;
    }

    return mapping;
  }
}

// Extension methods for easy bank data validation
extension BankDetailsValidation on BankDetailsData {
  bool get hasValidIBAN =>
      ibanNumber != null &&
      BankDetailsOCRService.validateIBANFormat(ibanNumber!);

  bool get hasValidAccountNumber =>
      accountNumber != null &&
      BankDetailsOCRService.validateAccountNumber(accountNumber!);
}






































import 'dart:async';
import 'dart:convert';
import 'dart:io' show File;
import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:universal_html/js.dart' as js;
import 'package:pdfx/pdfx.dart';

class TradeLicenseData {
  final String? licenseNumber;
  final String? tradeName;
  final String? issuingAuthority;
  final String? establishmentDate;
  final String? expiryDate;
  final String? responsiblePerson;
  final String? registeredAddress;
  final String? licenseType;
  final String? emirate;
  final String? activitiesDescription;
  final String? legalForm;
  final String? capital;
  final String? effectiveRegistrationDate;

  TradeLicenseData({
    this.licenseNumber,
    this.tradeName,
    this.issuingAuthority,
    this.establishmentDate,
    this.expiryDate,
    this.responsiblePerson,
    this.registeredAddress,
    this.licenseType,
    this.emirate,
    this.activitiesDescription,
    this.legalForm,
    this.capital,
    this.effectiveRegistrationDate,
  });

  Map<String, dynamic> toJson() {
    return {
      'licenseNumber': licenseNumber,
      'tradeName': tradeName,
      'issuingAuthority': issuingAuthority,
      'establishmentDate': establishmentDate,
      'expiryDate': expiryDate,
      'responsiblePerson': responsiblePerson,
      'registeredAddress': registeredAddress,
      'licenseType': licenseType,
      'emirate': emirate,
      'activitiesDescription': activitiesDescription,
      'legalForm': legalForm,
      'capital': capital,
      'effectiveRegistrationDate': effectiveRegistrationDate,
    };
  }

  factory TradeLicenseData.fromJson(Map<String, dynamic> json) {
    return TradeLicenseData(
      licenseNumber: json['licenseNumber'],
      tradeName: json['tradeName'],
      issuingAuthority: json['issuingAuthority'],
      establishmentDate: json['establishmentDate'],
      expiryDate: json['expiryDate'],
      responsiblePerson: json['responsiblePerson'],
      registeredAddress: json['registeredAddress'],
      licenseType: json['licenseType'],
      emirate: json['emirate'],
      activitiesDescription: json['activitiesDescription'],
      legalForm: json['legalForm'],
      capital: json['capital'],
      effectiveRegistrationDate: json['effectiveRegistrationDate'],
    );
  }

  bool get isValid {
    return licenseNumber != null &&
        tradeName != null &&
        issuingAuthority != null;
  }
}

class TradeLicenseOCRService {
  // Main OCR processing method for trade license documents
  static Future<TradeLicenseData> processTradeLicense(String imagePath) async {
    if (kIsWeb) {
      print('=== WEB TRADE LICENSE OCR START ===');
      return _processWebTradeLicense(imagePath);
    }

    // Check if file is a PDF
    if (imagePath.toLowerCase().endsWith('.pdf') ||
        imagePath.startsWith('data:application/pdf')) {
      print('=== TRADE LICENSE PDF PROCESSING DETECTED ===');
      return _processTradeLicensePdfFile(imagePath);
    }

    try {
      print('=== STARTING TRADE LICENSE TESSERACT OCR ===');
      return _processTradeLicenseTesseractMobile(imagePath);
    } catch (e) {
      print('Trade license Tesseract error: $e');
      return TradeLicenseData();
    }
  }

  // PDF processing method for trade license documents
  static Future<TradeLicenseData> _processTradeLicensePdfFile(String pdfPath) async {
    try {
      print('=== TRADE LICENSE PDF PROCESSING START ===');
      print('Processing trade license PDF: $pdfPath');

      PdfDocument? document;

      // Handle different PDF path types
      if (pdfPath.startsWith('data:application/pdf')) {
        // Handle base64 PDF data
        final parts = pdfPath.split(',');
        if (parts.length == 2) {
          final bytes = base64Decode(parts[1]);
          document = await PdfDocument.openData(bytes);
        }
      } else if (pdfPath.startsWith('http')) {
        // Handle PDF URL
        document = await PdfDocument.openFile(pdfPath);
      } else if (!kIsWeb) {
        // Handle local file path
        document = await PdfDocument.openFile(pdfPath);
      }

      if (document == null) {
        print('Failed to load trade license PDF document');
        return TradeLicenseData();
      }

      String combinedText = '';

      // Process each page of the PDF (usually trade licenses are 1-2 pages)
      for (
        int pageNum = 1;
        pageNum <= document.pagesCount && pageNum <= 3;
        pageNum++
      ) {
        try {
          final page = await document.getPage(pageNum);

          // Render page as high-quality image for better OCR
          final pageImage = await page.render(
            width: (page.width * 3).toDouble(),
            height: (page.height * 3).toDouble(),
            format: PdfPageImageFormat.png,
            backgroundColor: '#FFFFFF',
          );

          if (pageImage != null) {
            final processedBytes = await _preprocessImageForOCR(pageImage.bytes);
            final pageText = await _processTesseractFromBytes(processedBytes);
            combinedText += '$pageText\n';

            print('Trade License Page $pageNum text extracted (${pageText.length} chars)');
          }

          await page.close();
        } catch (pageError) {
          print('Error processing trade license page $pageNum: $pageError');
          continue;
        }
      }

      await document.close();

      if (combinedText.isEmpty) {
        print('No text extracted from trade license PDF');
        return TradeLicenseData();
      }

      print('Combined trade license PDF text length: ${combinedText.length}');
      final extractedData = _extractTradeLicenseDataFromText(combinedText);

      print('=== TRADE LICENSE PDF EXTRACTION RESULTS ===');
      print('License Number: ${extractedData.licenseNumber}');
      print('Trade Name: ${extractedData.tradeName}');
      print('Issuing Authority: ${extractedData.issuingAuthority}');
      print('Establishment Date: ${extractedData.establishmentDate}');
      print('Expiry Date: ${extractedData.expiryDate}');
      print('Responsible Person: ${extractedData.responsiblePerson}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END TRADE LICENSE PDF EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('Trade license PDF processing error: $e');
      return TradeLicenseData();
    }
  }

  // Web-compatible Tesseract processing for trade license
  static Future<TradeLicenseData> _processWebTradeLicense(String imagePath) async {
    try {
      print('=== WEB TRADE LICENSE TESSERACT OCR PROCESSING START ===');
      print('Processing trade license image: $imagePath');

      // Check if it's a PDF in web environment
      if (imagePath.startsWith('data:application/pdf') ||
          imagePath.toLowerCase().endsWith('.pdf')) {
        return _processWebTradeLicensePdf(imagePath);
      }

      final extractedText = await _extractTextWithTesseract(imagePath);

      if (extractedText.isEmpty) {
        print('No text extracted from trade license Tesseract OCR');
        return TradeLicenseData();
      }

      print('Extracted trade license text length: ${extractedText.length}');
      final extractedData = _extractTradeLicenseDataFromText(extractedText);

      print('=== TRADE LICENSE TESSERACT EXTRACTION RESULTS ===');
      print('License Number: ${extractedData.licenseNumber}');
      print('Trade Name: ${extractedData.tradeName}');
      print('Issuing Authority: ${extractedData.issuingAuthority}');
      print('Establishment Date: ${extractedData.establishmentDate}');
      print('Expiry Date: ${extractedData.expiryDate}');
      print('Responsible Person: ${extractedData.responsiblePerson}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END TRADE LICENSE TESSERACT EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('Web trade license Tesseract OCR error: $e');
      return TradeLicenseData();
    }
  }

  // Web PDF processing method for trade license
  static Future<TradeLicenseData> _processWebTradeLicensePdf(String pdfPath) async {
    try {
      print('=== WEB TRADE LICENSE PDF PROCESSING START ===');
      print('Processing trade license PDF in web: $pdfPath');

      PdfDocument? document;

      if (pdfPath.startsWith('data:application/pdf')) {
        final parts = pdfPath.split(',');
        if (parts.length == 2) {
          final bytes = base64Decode(parts[1]);
          document = await PdfDocument.openData(bytes);
        }
      } else {
        document = await PdfDocument.openFile(pdfPath);
      }

      if (document == null) {
        print('Failed to load trade license PDF document in web');
        return TradeLicenseData();
      }

      String combinedText = '';

      // Process first 3 pages maximum for trade license
      for (
        int pageNum = 1;
        pageNum <= document.pagesCount && pageNum <= 3;
        pageNum++
      ) {
        try {
          final page = await document.getPage(pageNum);

          final pageImage = await page.render(
            width: (page.width * 3).toDouble(),
            height: (page.height * 3).toDouble(),
            format: PdfPageImageFormat.png,
            backgroundColor: '#FFFFFF',
          );

          if (pageImage != null) {
            final processedBytes = await _preprocessImageForOCR(pageImage.bytes);
            final base64Image = 'data:image/png;base64,${base64Encode(processedBytes)}';

            final pageText = await _extractTextWithTesseract(base64Image);
            combinedText += '$pageText\n';

            print('Web trade license PDF Page $pageNum text extracted (${pageText.length} chars)');
          }

          await page.close();
        } catch (pageError) {
          print('Error processing web trade license PDF page $pageNum: $pageError');
          continue;
        }
      }

      await document.close();

      if (combinedText.isEmpty) {
        print('No text extracted from web trade license PDF');
        return TradeLicenseData();
      }

      print('Combined web trade license PDF text length: ${combinedText.length}');
      final extractedData = _extractTradeLicenseDataFromText(combinedText);

      print('=== WEB TRADE LICENSE PDF EXTRACTION RESULTS ===');
      print('License Number: ${extractedData.licenseNumber}');
      print('Trade Name: ${extractedData.tradeName}');
      print('Issuing Authority: ${extractedData.issuingAuthority}');
      print('Establishment Date: ${extractedData.establishmentDate}');
      print('Expiry Date: ${extractedData.expiryDate}');
      print('Responsible Person: ${extractedData.responsiblePerson}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END WEB TRADE LICENSE PDF EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('Web trade license PDF processing error: $e');
      return TradeLicenseData();
    }
  }

  // Extract text using Tesseract
  static Future<String> _extractTextWithTesseract(String imagePath) async {
    try {
      print('Calling Tesseract OCR function for trade license...');
      print('Image path: $imagePath');

      final completer = Completer<String>();

      js.context['dartTradeLicenseTesseractCallback'] = js.allowInterop((String result) {
        if (!completer.isCompleted) {
          print('Trade license Tesseract OCR result received');
          print('OCR result length: ${result.length}');
          completer.complete(result);
        }
      });

      js.context['dartTradeLicenseTesseractErrorCallback'] = js.allowInterop((dynamic error) {
        if (!completer.isCompleted) {
          print('Trade license Tesseract OCR error: $error');
          completer.complete('');
        }
      });

      // Call the Tesseract JavaScript function
      js.context.callMethod('eval', [
        '''
        processImageWithTesseract("$imagePath")
          .then(function(result) {
            if (window.dartTradeLicenseTesseractCallback) {
              window.dartTradeLicenseTesseractCallback(result || '');
            }
          })
          .catch(function(error) {
            if (window.dartTradeLicenseTesseractErrorCallback) {
              window.dartTradeLicenseTesseractErrorCallback(error);
            }
          });
      ''',
      ]);

      final result = await completer.future;

      // Clean up callbacks
      js.context['dartTradeLicenseTesseractCallback'] = null;
      js.context['dartTradeLicenseTesseractErrorCallback'] = null;

      return result;
    } catch (e) {
      print('Trade license Tesseract OCR failed: $e');
      return '';
    }
  }

  // Mobile Tesseract processing for trade license
  static Future<TradeLicenseData> _processTradeLicenseTesseractMobile(String imagePath) async {
    try {
      print('=== MOBILE TRADE LICENSE TESSERACT OCR START ===');
      print('Processing trade license image: $imagePath');

      if (kIsWeb) {
        final extractedText = await _extractTextWithTesseract(imagePath);
        if (extractedText.isEmpty) {
          return TradeLicenseData();
        }
        return _extractTradeLicenseDataFromText(extractedText);
      } else {
        print('Native mobile trade license Tesseract not implemented');
        return TradeLicenseData();
      }
    } catch (e) {
      print('Mobile trade license Tesseract error: $e');
      return TradeLicenseData();
    }
  }

  // Process image from bytes using Tesseract
  static Future<String> _processTesseractFromBytes(Uint8List imageBytes) async {
    try {
      print('=== TRADE LICENSE TESSERACT FROM BYTES ===');

      final base64Image = 'data:image/png;base64,${base64Encode(imageBytes)}';
      return await _extractTextWithTesseract(base64Image);
    } catch (e) {
      print('Trade license Tesseract from bytes error: $e');
      return '';
    }
  }

  // Process image from bytes (public method)
  static Future<TradeLicenseData> processTradeLicenseFromBytes(Uint8List imageBytes) async {
    try {
      final extractedText = await _processTesseractFromBytes(imageBytes);
      if (extractedText.isEmpty) {
        return TradeLicenseData();
      }
      return _extractTradeLicenseDataFromText(extractedText);
    } catch (e) {
      print('Process trade license from bytes failed: $e');
      return TradeLicenseData();
    }
  }

  // Image preprocessing for better OCR results
  static Future<Uint8List> _preprocessImageForOCR(Uint8List imageBytes) async {
    try {
      if (kIsWeb) {
        return await _preprocessImageWeb(imageBytes);
      } else {
        return imageBytes;
      }
    } catch (e) {
      print('Trade license image preprocessing failed: $e');
      return imageBytes;
    }
  }

  // Web-based image preprocessing using Canvas
  static Future<Uint8List> _preprocessImageWeb(Uint8List imageBytes) async {
    try {
      print('=== WEB TRADE LICENSE IMAGE PREPROCESSING ===');

      final completer = Completer<Uint8List>();

      js.context['dartTradeLicenseImageProcessCallback'] = js.allowInterop((List<int> result) {
        if (!completer.isCompleted) {
          print('Trade license image preprocessing completed');
          completer.complete(Uint8List.fromList(result.cast<int>()));
        }
      });

      js.context['dartTradeLicenseImageProcessErrorCallback'] = js.allowInterop((dynamic error) {
        if (!completer.isCompleted) {
          print('Trade license image preprocessing error: $error');
          completer.complete(imageBytes);
        }
      });

      final base64Image = base64Encode(imageBytes);

      js.context.callMethod('eval', [
        '''
        preprocessImageForOCR("data:image/png;base64,$base64Image")
          .then(function(result) {
            if (window.dartTradeLicenseImageProcessCallback) {
              window.dartTradeLicenseImageProcessCallback(result || []);
            }
          })
          .catch(function(error) {
            if (window.dartTradeLicenseImageProcessErrorCallback) {
              window.dartTradeLicenseImageProcessErrorCallback(error);
            }
          });
      ''',
      ]);

      final result = await completer.future;

      js.context['dartTradeLicenseImageProcessCallback'] = null;
      js.context['dartTradeLicenseImageProcessErrorCallback'] = null;

      return result;
    } catch (e) {
      print('Web trade license image preprocessing failed: $e');
      return imageBytes;
    }
  }

  // Extract specific patterns from OCR text for trade license
  static TradeLicenseData _extractTradeLicenseDataFromText(String ocrText) {
    String? licenseNumber;
    String? tradeName;
    String? issuingAuthority;
    String? establishmentDate;
    String? expiryDate;
    String? responsiblePerson;
    String? registeredAddress;
    String? licenseType;
    String? emirate;
    String? activitiesDescription;
    String? legalForm;
    String? capital;
    String? effectiveRegistrationDate;

    final lines = ocrText.split('\n');
    print('=== RAW TRADE LICENSE OCR TEXT ===');
    print(ocrText);
    print('=== END RAW TEXT ===');
    print('Lines count: ${lines.length}');

    final fullText = ocrText.toLowerCase();

    // Extract License Number - multiple patterns for different emirates
    final licensePatterns = [
      RegExp(r'license\s*(?:no|number)[:\s]*([a-z0-9\-\/\s]{5,30})', caseSensitive: false),
      RegExp(r'licence\s*(?:no|number)[:\s]*([a-z0-9\-\/\s]{5,30})', caseSensitive: false),
      RegExp(r'\s*[:\s]*([a-z0-9\-\/\s]{5,30})', caseSensitive: false),
      RegExp(r'cn[:\s]*([a-z0-9\-\/\s]{5,30})', caseSensitive: false),
      RegExp(r'([a-z]{2,4}[\-\/]?\d{4,8}[\-\/]?\d{0,8})', caseSensitive: false),
      RegExp(r'(\d{6,12})', caseSensitive: false), // Numeric license numbers
    ];

    for (final pattern in licensePatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null) {
        var extracted = match.group(1)!.trim().replaceAll(RegExp(r'\s+'), ' ');
        if (extracted.length >= 5 && licenseNumber == null) {
          licenseNumber = _cleanLicenseNumber(extracted);
          break;
        }
      }
    }

    // Extract Trade Name - multiple patterns
    final tradeNamePatterns = [
      RegExp(r'trade\s*name[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
      RegExp(r'business\s*name[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
      RegExp(r'company\s*name[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
      RegExp(r'\s*[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
      RegExp(r'establishment[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
    ];

    for (final pattern in tradeNamePatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null) {
        var extracted = match.group(1)!.trim();
        if (extracted.length >= 3 && tradeName == null) {
          tradeName = _cleanTradeName(extracted);
          break;
        }
      }
    }

    // Extract Issuing Authority - specific to UAE emirates
    final authorityPatterns = [
      RegExp(r'issuing\s*authority[:\s]*([a-z\s&\-\.]{5,60})', caseSensitive: false),
      RegExp(r'issued\s*by[:\s]*([a-z\s&\-\.]{5,60})', caseSensitive: false),
      RegExp(r'\s*[:\s]*([a-z\s&\-\.]{5,60})', caseSensitive: false),
      RegExp(r'(dubai\s*economic\s*development|ddev|ded)', caseSensitive: false),
      RegExp(r'(abu\s*dhabi\s*chamber|adcci)', caseSensitive: false),
      RegExp(r'(sharjah\s*economic\s*development|sedd)', caseSensitive: false),
      RegExp(r'(ajman\s*economic\s*development)', caseSensitive: false),
      RegExp(r'(ras\s*al\s*khaimah\s*economic\s*zone)', caseSensitive: false),
      RegExp(r'(fujairah\s*economic\s*development)', caseSensitive: false),
      RegExp(r'(umm\s*al\s*quwain\s*economic\s*development)', caseSensitive: false),
    ];

    for (final pattern in authorityPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null) {
        var extracted = match.group(1)!.trim();
        if (extracted.length >= 5 && issuingAuthority == null) {
          issuingAuthority = _cleanIssuingAuthority(extracted);
          break;
        }
      }
    }

    // Extract dates with context awareness
    final datePattern = RegExp(r'(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{4})');
    final allDates = datePattern.allMatches(ocrText);
    final foundDates = <Map<String, dynamic>>[];

    for (final match in allDates) {
      final date = match.group(0)!;
      final year = int.parse(match.group(3)!);
      final month = int.parse(match.group(2)!);
      final day = int.parse(match.group(1)!);

      if (year >= 1990 && year <= 2040 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
        final startIndex = match.start;
        final contextStart = startIndex > 30 ? startIndex - 30 : 0;
        final contextEnd = startIndex + 30 < ocrText.length ? startIndex + 30 : ocrText.length;
        final context = ocrText.substring(contextStart, contextEnd).toLowerCase();

        foundDates.add({'date': date, 'year': year, 'context': context});
      }
    }

    // Categorize dates by context
    for (final dateObj in foundDates) {
      final date = dateObj['date'] as String;
      final year = dateObj['year'] as int;
      final context = dateObj['context'] as String;

      // Expiry date patterns (check first as it's more specific)
      if ((context.contains('expiry') ||
              context.contains('expires') ||
              context.contains('valid until') ||
              context.contains('valid till') ||
              context.contains('valid to') ||
              context.contains('') ||
              context.contains('expiration') ||
              (year >= DateTime.now().year + 1 && year <= 2040)) &&
          expiryDate == null) {
        expiryDate = date;
      }
      // Establishment date patterns
      else if ((context.contains('establishment') ||
              context.contains('incorporated') ||
              context.contains('founded') ||
              context.contains('') ||
              context.contains('established') ||
              context.contains('incorporation') ||
              (year >= 1990 && year <= DateTime.now().year)) &&
          establishmentDate == null) {
        establishmentDate = date;
      }
      // Effective registration date patterns
      else if ((context.contains('effective') ||
              context.contains('registration') ||
              context.contains('issue') ||
              context.contains('') ||
              (year >= 2000 && year <= DateTime.now().year + 1)) &&
          effectiveRegistrationDate == null) {
        effectiveRegistrationDate = date;
      }
    }

    // Extract Responsible Person
    final responsiblePersonPatterns = [
      RegExp(r'responsible\s*person[:\s]*([a-z\s]{3,50})', caseSensitive: false),
      RegExp(r'manager[:\s]*([a-z\s]{3,50})', caseSensitive: false),
      RegExp(r'authorized\s*person[:\s]*([a-z\s]{3,50})', caseSensitive: false),
      RegExp(r'\s*[:\s]*([a-z\s]{3,50})', caseSensitive: false),
      RegExp(r'owner[:\s]*([a-z\s]{3,50})', caseSensitive: false),
    ];

    for (final pattern in responsiblePersonPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null) {
        var extracted = match.group(1)!.trim();
        if (extracted.length >= 3 && responsiblePerson == null) {
          responsiblePerson = _cleanPersonName(extracted);
          break;
        }
      }
    }

    // Extract Registered Address
    final addressPatterns = [
      RegExp(r'address[:\s]*([a-z0-9\s,\-\.]{10,100})', caseSensitive: false),
      RegExp(r'location[:\s]*([a-z0-9\s,\-\.]{10,100})', caseSensitive: false),
      RegExp(r'[:\s]*([a-z0-9\s,\-\.]{10,100})', caseSensitive: false),
      RegExp(r'registered\s*address[:\s]*([a-z0-9\s,\-\.]{10,100})', caseSensitive: false),
    ];

    for (final pattern in addressPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null) {
        var extracted = match.group(1)!.trim();
        if (extracted.length >= 10 && registeredAddress == null) {
          registeredAddress = _cleanAddress(extracted);
          break;
        }
      }
    }

    // Extract Emirates
    final emiratePatterns = [
      RegExp(r'\b(dubai|abu\s*dhabi|sharjah|ajman|fujairah|ras\s*al\s*khaimah|umm\s*al\s*quwain)\b', caseSensitive: false),
    ];

    for (final pattern in emiratePatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && emirate == null) {
        emirate = _cleanEmirate(match.group(1)!);
        break;
      }
    }

    // Extract License Type
    final licenseTypePatterns = [
      RegExp(r'license\s*type[:\s]*([a-z\s]{5,40})', caseSensitive: false),
      RegExp(r'activity[:\s]*([a-z\s]{5,40})', caseSensitive: false),
      RegExp(r'(commercial|professional|industrial|tourism|agricultural)', caseSensitive: false),
    ];

    for (final pattern in licenseTypePatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && licenseType == null) {
        licenseType = _cleanLicenseType(match.group(1)!);
        break;
      }
    }

    // Extract Legal Form
    final legalFormPatterns = [
      RegExp(r'legal\s*form[:\s]*([a-z\s]{3,30})', caseSensitive: false),
      RegExp(r'(llc|fze|fzco|branch|establishment|sole\s*proprietorship)', caseSensitive: false),
    ];

    for (final pattern in legalFormPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && legalForm == null) {
        legalForm = _cleanLegalForm(match.group(1)!);
        break;
      }
    }

    // Extract Capital
    final capitalPatterns = [
      RegExp(r'capital[:\s]*([a-z0-9\s,\.]{3,20})', caseSensitive: false),
      RegExp(r'aed[:\s]*([0-9\s,\.]{3,20})', caseSensitive: false),
      RegExp(r'(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*aed', caseSensitive: false),
    ];

    for (final pattern in capitalPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && capital == null) {
        capital = _cleanCapital(match.group(1)!);
        break;
      }
    }

    return TradeLicenseData(
      licenseNumber: licenseNumber,
      tradeName: tradeName,
      issuingAuthority: issuingAuthority,
      establishmentDate: establishmentDate,
      expiryDate: expiryDate,
      responsiblePerson: responsiblePerson,
      registeredAddress: registeredAddress,
      licenseType: licenseType,
      emirate: emirate,
      activitiesDescription: activitiesDescription,
      legalForm: legalForm,
      capital: capital,
      effectiveRegistrationDate: effectiveRegistrationDate,
    );
  }

  // Helper methods for cleaning extracted data
  static String? _cleanLicenseNumber(String? licenseNumber) {
    if (licenseNumber == null || licenseNumber.isEmpty) return null;

    // Remove extra spaces and clean up
    licenseNumber = licenseNumber.replaceAll(RegExp(r'\s+'), '');
    licenseNumber = licenseNumber.replaceAll(RegExp(r'[^\w\-\/]'), '');

    return licenseNumber.length >= 5 ? licenseNumber.toUpperCase() : null;
  }

  static String? _cleanTradeName(String? tradeName) {
    if (tradeName == null || tradeName.isEmpty) return null;

    tradeName = tradeName.replaceAll(RegExp(r'[^\w\s&\-\.]'), ' ');
    tradeName = tradeName.replaceAll(RegExp(r'\s+'), ' ').trim();

    return tradeName.length >= 3 ? _capitalizeWords(tradeName) : null;
  }

  static String? _cleanIssuingAuthority(String? authority) {
    if (authority == null || authority.isEmpty) return null;

    authority = authority.replaceAll(RegExp(r'[^\w\s&\-\.]'), ' ');
    authority = authority.replaceAll(RegExp(r'\s+'), ' ').trim();

    return authority.length >= 5 ? _capitalizeWords(authority) : null;
  }

  static String? _cleanPersonName(String? name) {
    if (name == null || name.isEmpty) return null;

    name = name.replaceAll(RegExp(r'[^\w\s]'), ' ');
    name = name.replaceAll(RegExp(r'\s+'), ' ').trim();

    return name.length >= 3 ? _capitalizeWords(name) : null;
  }

  static String? _cleanAddress(String? address) {
    if (address == null || address.isEmpty) return null;

    address = address.replaceAll(RegExp(r'[^\w\s,\-\.]'), ' ');
    address = address.replaceAll(RegExp(r'\s+'), ' ').trim();

    return address.length >= 10 ? _capitalizeWords(address) : null;
  }

  static String? _cleanEmirate(String? emirate) {
    if (emirate == null || emirate.isEmpty) return null;

    emirate = emirate.toLowerCase().trim();

    // Standardize emirate names
    final emirateMap = {
      'dubai': 'Dubai',
      'abu dhabi': 'Abu Dhabi',
      'sharjah': 'Sharjah',
      'ajman': 'Ajman',
      'fujairah': 'Fujairah',
      'ras al khaimah': 'Ras Al Khaimah',
      'umm al quwain': 'Umm Al Quwain',
    };

    return emirateMap[emirate] ?? _capitalizeWords(emirate);
  }

  static String? _cleanLicenseType(String? type) {
    if (type == null || type.isEmpty) return null;

    type = type.replaceAll(RegExp(r'[^\w\s]'), ' ');
    type = type.replaceAll(RegExp(r'\s+'), ' ').trim();

    return type.length >= 3 ? _capitalizeWords(type) : null;
  }

  static String? _cleanLegalForm(String? form) {
    if (form == null || form.isEmpty) return null;

    form = form.toLowerCase().trim();

    // Standardize legal forms
    final formMap = {
      'llc': 'LLC',
      'fze': 'FZE',
      'fzco': 'FZCO',
      'branch': 'Branch',
      'establishment': 'Establishment',
      'sole proprietorship': 'Sole Proprietorship',
    };

    return formMap[form] ?? _capitalizeWords(form);
  }

  static String? _cleanCapital(String? capital) {
    if (capital == null || capital.isEmpty) return null;

    // Extract only numbers and decimal points
    capital = capital.replaceAll(RegExp(r'[^\d,\.]'), '');

    return capital.isNotEmpty ? capital : null;
  }

  static String _capitalizeWords(String text) {
    return text
        .split(' ')
        .map((word) => word.isNotEmpty
            ? word[0].toUpperCase() + word.substring(1).toLowerCase()
            : word)
        .join(' ');
  }

  // Get form field mapping for trade license data
  static Map<String, String> getFormFieldMapping(TradeLicenseData data) {
    final mapping = <String, String>{};

    if (data.licenseNumber != null) mapping['licenseNumber'] = data.licenseNumber!;
    if (data.tradeName != null) mapping['tradeName'] = data.tradeName!;
    if (data.issuingAuthority != null) mapping['issuingAuthority'] = data.issuingAuthority!;
    if (data.establishmentDate != null) mapping['establishmentDate'] = data.establishmentDate!;
    if (data.expiryDate != null) mapping['expiryDate'] = data.expiryDate!;
    if (data.responsiblePerson != null) mapping['responsiblePerson'] = data.responsiblePerson!;
    if (data.registeredAddress != null) mapping['registeredAddress'] = data.registeredAddress!;
    if (data.effectiveRegistrationDate != null) mapping['effectiveRegistrationDate'] = data.effectiveRegistrationDate!;

    return mapping;
  }
}

// Extension methods for easy validation
extension TradeLicenseValidation on TradeLicenseData {
  bool get hasValidLicenseNumber => licenseNumber != null && licenseNumber!.length >= 5;

  bool get hasValidTradeName => tradeName != null && tradeName!.length >= 3;

  bool get hasValidIssuingAuthority => issuingAuthority != null && issuingAuthority!.length >= 5;

  bool get isExpired {
    if (expiryDate == null) return false;
    try {
      final parts = expiryDate!.split(RegExp(r'[\-\/\.]'));
      if (parts.length == 3) {
        final day = int.parse(parts[0]);
        final month = int.parse(parts[1]);
        final year = int.parse(parts[2]);
        final expiry = DateTime(year, month, day);
        return DateTime.now().isAfter(expiry);
      }
    } catch (e) {
      // Invalid date format
    }
    return false;
  }
}





































import 'dart:async';
import 'dart:convert';
import 'dart:io' show File;
import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:universal_html/js.dart' as js;
import 'package:pdfx/pdfx.dart';

class VATRegistrationData {
  final String? vatNumber;
  final String? companyName;
  final String? registrationDate;
  final String? effectiveDate;
  final String? registrationStatus;
  final String? businessActivity;
  final String? registeredAddress;
  final String? issuingAuthority;
  final String? taxPeriod;
  final String? businessType;
  final String? phoneNumber;
  final String? emailAddress;

  VATRegistrationData({
    this.vatNumber,
    this.companyName,
    this.registrationDate,
    this.effectiveDate,
    this.registrationStatus,
    this.businessActivity,
    this.registeredAddress,
    this.issuingAuthority,
    this.taxPeriod,
    this.businessType,
    this.phoneNumber,
    this.emailAddress,
  });

  Map<String, dynamic> toJson() {
    return {
      'vatNumber': vatNumber,
      'companyName': companyName,
      'registrationDate': registrationDate,
      'effectiveDate': effectiveDate,
      'registrationStatus': registrationStatus,
      'businessActivity': businessActivity,
      'registeredAddress': registeredAddress,
      'issuingAuthority': issuingAuthority,
      'taxPeriod': taxPeriod,
      'businessType': businessType,
      'phoneNumber': phoneNumber,
      'emailAddress': emailAddress,
    };
  }

  factory VATRegistrationData.fromJson(Map<String, dynamic> json) {
    return VATRegistrationData(
      vatNumber: json['vatNumber'],
      companyName: json['companyName'],
      registrationDate: json['registrationDate'],
      effectiveDate: json['effectiveDate'],
      registrationStatus: json['registrationStatus'],
      businessActivity: json['businessActivity'],
      registeredAddress: json['registeredAddress'],
      issuingAuthority: json['issuingAuthority'],
      taxPeriod: json['taxPeriod'],
      businessType: json['businessType'],
      phoneNumber: json['phoneNumber'],
      emailAddress: json['emailAddress'],
    );
  }

  bool get isValid {
    return vatNumber != null ||
        companyName != null ||
        (registrationDate != null || effectiveDate != null);
  }
}

class VATRegistrationOCRService {
  // Main OCR processing method for VAT registration documents
  static Future<VATRegistrationData> processVATRegistration(String imagePath) async {
    if (kIsWeb) {
      print('=== WEB VAT REGISTRATION OCR START ===');
      return _processWebVATRegistration(imagePath);
    }

    // Check if file is a PDF
    if (imagePath.toLowerCase().endsWith('.pdf') ||
        imagePath.startsWith('data:application/pdf')) {
      print('=== VAT REGISTRATION PDF PROCESSING DETECTED ===');
      return _processVATRegistrationPdfFile(imagePath);
    }

    try {
      print('=== STARTING VAT REGISTRATION TESSERACT OCR ===');
      return _processVATRegistrationTesseractMobile(imagePath);
    } catch (e) {
      print('VAT registration Tesseract error: $e');
      return VATRegistrationData();
    }
  }

  // PDF processing method for VAT registration documents
  static Future<VATRegistrationData> _processVATRegistrationPdfFile(String pdfPath) async {
    try {
      print('=== VAT REGISTRATION PDF PROCESSING START ===');
      print('Processing VAT registration PDF: $pdfPath');

      PdfDocument? document;

      // Handle different PDF path types
      if (pdfPath.startsWith('data:application/pdf')) {
        // Handle base64 PDF data
        final parts = pdfPath.split(',');
        if (parts.length == 2) {
          final bytes = base64Decode(parts[1]);
          document = await PdfDocument.openData(bytes);
        }
      } else if (pdfPath.startsWith('http')) {
        // Handle PDF URL
        document = await PdfDocument.openFile(pdfPath);
      } else if (!kIsWeb) {
        // Handle local file path
        document = await PdfDocument.openFile(pdfPath);
      }

      if (document == null) {
        print('Failed to load VAT registration PDF document');
        return VATRegistrationData();
      }

      String combinedText = '';

      // Process each page of the PDF (usually VAT certificates are 1-2 pages)
      for (
        int pageNum = 1;
        pageNum <= document.pagesCount && pageNum <= 3;
        pageNum++
      ) {
        try {
          final page = await document.getPage(pageNum);

          // Render page as high-quality image for better OCR
          final pageImage = await page.render(
            width: (page.width * 3).toDouble(),
            height: (page.height * 3).toDouble(),
            format: PdfPageImageFormat.png,
            backgroundColor: '#FFFFFF',
          );

          if (pageImage != null) {
            final processedBytes = await _preprocessImageForOCR(pageImage.bytes);
            final pageText = await _processTesseractFromBytes(processedBytes);
            combinedText += '$pageText\n';

            print('VAT Registration Page $pageNum text extracted (${pageText.length} chars)');
          }

          await page.close();
        } catch (pageError) {
          print('Error processing VAT registration page $pageNum: $pageError');
          continue;
        }
      }

      await document.close();

      if (combinedText.isEmpty) {
        print('No text extracted from VAT registration PDF');
        return VATRegistrationData();
      }

      print('Combined VAT registration PDF text length: ${combinedText.length}');
      final extractedData = _extractVATRegistrationDataFromText(combinedText);

      print('=== VAT REGISTRATION PDF EXTRACTION RESULTS ===');
      print('VAT Number: ${extractedData.vatNumber}');
      print('Company Name: ${extractedData.companyName}');
      print('Registration Date: ${extractedData.registrationDate}');
      print('Effective Date: ${extractedData.effectiveDate}');
      print('Registration Status: ${extractedData.registrationStatus}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END VAT REGISTRATION PDF EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('VAT registration PDF processing error: $e');
      return VATRegistrationData();
    }
  }

  // Web-compatible Tesseract processing for VAT registration
  static Future<VATRegistrationData> _processWebVATRegistration(String imagePath) async {
    try {
      print('=== WEB VAT REGISTRATION TESSERACT OCR PROCESSING START ===');
      print('Processing VAT registration image: $imagePath');

      // Check if it's a PDF in web environment
      if (imagePath.startsWith('data:application/pdf') ||
          imagePath.toLowerCase().endsWith('.pdf')) {
        return _processWebVATRegistrationPdf(imagePath);
      }

      final extractedText = await _extractTextWithTesseract(imagePath);

      if (extractedText.isEmpty) {
        print('No text extracted from VAT registration Tesseract OCR');
        return VATRegistrationData();
      }

      print('Extracted VAT registration text length: ${extractedText.length}');
      final extractedData = _extractVATRegistrationDataFromText(extractedText);

      print('=== VAT REGISTRATION TESSERACT EXTRACTION RESULTS ===');
      print('VAT Number: ${extractedData.vatNumber}');
      print('Company Name: ${extractedData.companyName}');
      print('Registration Date: ${extractedData.registrationDate}');
      print('Effective Date: ${extractedData.effectiveDate}');
      print('Registration Status: ${extractedData.registrationStatus}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END VAT REGISTRATION TESSERACT EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('Web VAT registration Tesseract OCR error: $e');
      return VATRegistrationData();
    }
  }

  // Web PDF processing method for VAT registration
  static Future<VATRegistrationData> _processWebVATRegistrationPdf(String pdfPath) async {
    try {
      print('=== WEB VAT REGISTRATION PDF PROCESSING START ===');
      print('Processing VAT registration PDF in web: $pdfPath');

      PdfDocument? document;

      if (pdfPath.startsWith('data:application/pdf')) {
        final parts = pdfPath.split(',');
        if (parts.length == 2) {
          final bytes = base64Decode(parts[1]);
          document = await PdfDocument.openData(bytes);
        }
      } else {
        document = await PdfDocument.openFile(pdfPath);
      }

      if (document == null) {
        print('Failed to load VAT registration PDF document in web');
        return VATRegistrationData();
      }

      String combinedText = '';

      // Process first 3 pages maximum for VAT registration
      for (
        int pageNum = 1;
        pageNum <= document.pagesCount && pageNum <= 3;
        pageNum++
      ) {
        try {
          final page = await document.getPage(pageNum);

          final pageImage = await page.render(
            width: (page.width * 3).toDouble(),
            height: (page.height * 3).toDouble(),
            format: PdfPageImageFormat.png,
            backgroundColor: '#FFFFFF',
          );

          if (pageImage != null) {
            final processedBytes = await _preprocessImageForOCR(pageImage.bytes);
            final base64Image = 'data:image/png;base64,${base64Encode(processedBytes)}';

            final pageText = await _extractTextWithTesseract(base64Image);
            combinedText += '$pageText\n';

            print('Web VAT registration PDF Page $pageNum text extracted (${pageText.length} chars)');
          }

          await page.close();
        } catch (pageError) {
          print('Error processing web VAT registration PDF page $pageNum: $pageError');
          continue;
        }
      }

      await document.close();

      if (combinedText.isEmpty) {
        print('No text extracted from web VAT registration PDF');
        return VATRegistrationData();
      }

      print('Combined web VAT registration PDF text length: ${combinedText.length}');
      final extractedData = _extractVATRegistrationDataFromText(combinedText);

      print('=== WEB VAT REGISTRATION PDF EXTRACTION RESULTS ===');
      print('VAT Number: ${extractedData.vatNumber}');
      print('Company Name: ${extractedData.companyName}');
      print('Registration Date: ${extractedData.registrationDate}');
      print('Effective Date: ${extractedData.effectiveDate}');
      print('Registration Status: ${extractedData.registrationStatus}');
      print('Is Valid: ${extractedData.isValid}');
      print('=== END WEB VAT REGISTRATION PDF EXTRACTION RESULTS ===');

      return extractedData;
    } catch (e) {
      print('Web VAT registration PDF processing error: $e');
      return VATRegistrationData();
    }
  }

  // Extract text using Tesseract
  static Future<String> _extractTextWithTesseract(String imagePath) async {
    try {
      print('Calling Tesseract OCR function for VAT registration...');
      print('Image path: $imagePath');

      final completer = Completer<String>();

      js.context['dartVATRegistrationTesseractCallback'] = js.allowInterop((String result) {
        if (!completer.isCompleted) {
          print('VAT registration Tesseract OCR result received');
          print('OCR result length: ${result.length}');
          completer.complete(result);
        }
      });

      js.context['dartVATRegistrationTesseractErrorCallback'] = js.allowInterop((dynamic error) {
        if (!completer.isCompleted) {
          print('VAT registration Tesseract OCR error: $error');
          completer.complete('');
        }
      });

      // Call the Tesseract JavaScript function
      js.context.callMethod('eval', [
        '''
        processImageWithTesseract("$imagePath")
          .then(function(result) {
            if (window.dartVATRegistrationTesseractCallback) {
              window.dartVATRegistrationTesseractCallback(result || '');
            }
          })
          .catch(function(error) {
            if (window.dartVATRegistrationTesseractErrorCallback) {
              window.dartVATRegistrationTesseractErrorCallback(error);
            }
          });
      ''',
      ]);

      final result = await completer.future;

      // Clean up callbacks
      js.context['dartVATRegistrationTesseractCallback'] = null;
      js.context['dartVATRegistrationTesseractErrorCallback'] = null;

      return result;
    } catch (e) {
      print('VAT registration Tesseract OCR failed: $e');
      return '';
    }
  }

  // Mobile Tesseract processing for VAT registration
  static Future<VATRegistrationData> _processVATRegistrationTesseractMobile(String imagePath) async {
    try {
      print('=== MOBILE VAT REGISTRATION TESSERACT OCR START ===');
      print('Processing VAT registration image: $imagePath');

      if (kIsWeb) {
        final extractedText = await _extractTextWithTesseract(imagePath);
        if (extractedText.isEmpty) {
          return VATRegistrationData();
        }
        return _extractVATRegistrationDataFromText(extractedText);
      } else {
        print('Native mobile VAT registration Tesseract not implemented');
        return VATRegistrationData();
      }
    } catch (e) {
      print('Mobile VAT registration Tesseract error: $e');
      return VATRegistrationData();
    }
  }

  // Process image from bytes using Tesseract
  static Future<String> _processTesseractFromBytes(Uint8List imageBytes) async {
    try {
      print('=== VAT REGISTRATION TESSERACT FROM BYTES ===');

      final base64Image = 'data:image/png;base64,${base64Encode(imageBytes)}';
      return await _extractTextWithTesseract(base64Image);
    } catch (e) {
      print('VAT registration Tesseract from bytes error: $e');
      return '';
    }
  }

  // Process image from bytes (public method)
  static Future<VATRegistrationData> processVATRegistrationFromBytes(Uint8List imageBytes) async {
    try {
      final extractedText = await _processTesseractFromBytes(imageBytes);
      if (extractedText.isEmpty) {
        return VATRegistrationData();
      }
      return _extractVATRegistrationDataFromText(extractedText);
    } catch (e) {
      print('Process VAT registration from bytes failed: $e');
      return VATRegistrationData();
    }
  }

  // Image preprocessing for better OCR results
  static Future<Uint8List> _preprocessImageForOCR(Uint8List imageBytes) async {
    try {
      if (kIsWeb) {
        return await _preprocessImageWeb(imageBytes);
      } else {
        return imageBytes;
      }
    } catch (e) {
      print('VAT registration image preprocessing failed: $e');
      return imageBytes;
    }
  }

  // Web-based image preprocessing using Canvas
  static Future<Uint8List> _preprocessImageWeb(Uint8List imageBytes) async {
    try {
      print('=== WEB VAT REGISTRATION IMAGE PREPROCESSING ===');

      final completer = Completer<Uint8List>();

      js.context['dartVATRegistrationImageProcessCallback'] = js.allowInterop((List<int> result) {
        if (!completer.isCompleted) {
          print('VAT registration image preprocessing completed');
          completer.complete(Uint8List.fromList(result.cast<int>()));
        }
      });

      js.context['dartVATRegistrationImageProcessErrorCallback'] = js.allowInterop((dynamic error) {
        if (!completer.isCompleted) {
          print('VAT registration image preprocessing error: $error');
          completer.complete(imageBytes);
        }
      });

      final base64Image = base64Encode(imageBytes);

      js.context.callMethod('eval', [
        '''
        preprocessImageForOCR("data:image/png;base64,$base64Image")
          .then(function(result) {
            if (window.dartVATRegistrationImageProcessCallback) {
              window.dartVATRegistrationImageProcessCallback(result || []);
            }
          })
          .catch(function(error) {
            if (window.dartVATRegistrationImageProcessErrorCallback) {
              window.dartVATRegistrationImageProcessErrorCallback(error);
            }
          });
      ''',
      ]);

      final result = await completer.future;

      js.context['dartVATRegistrationImageProcessCallback'] = null;
      js.context['dartVATRegistrationImageProcessErrorCallback'] = null;

      return result;
    } catch (e) {
      print('Web VAT registration image preprocessing failed: $e');
      return imageBytes;
    }
  }

  // Extract specific patterns from OCR text for VAT registration
  static VATRegistrationData _extractVATRegistrationDataFromText(String ocrText) {
    String? vatNumber;
    String? companyName;
    String? registrationDate;
    String? effectiveDate;
    String? registrationStatus;
    String? businessActivity;
    String? registeredAddress;
    String? issuingAuthority;
    String? taxPeriod;
    String? businessType;
    String? phoneNumber;
    String? emailAddress;

    final lines = ocrText.split('\n');
    print('=== RAW VAT REGISTRATION OCR TEXT ===');
    print(ocrText);
    print('=== END RAW TEXT ===');
    print('Lines count: ${lines.length}');

    final fullText = ocrText.toLowerCase();

    // Extract VAT Number - UAE format: 100000000000003
    final vatNumberPatterns = [
      RegExp(r'vat\s*(?:no|number|registration)[:\s]*([0-9]{15})', caseSensitive: false),
      RegExp(r'tax\s*(?:no|number|registration)[:\s]*([0-9]{15})', caseSensitive: false),
      RegExp(r'trn[:\s]*([0-9]{15})', caseSensitive: false),
      RegExp(r'([0-9]{15})', caseSensitive: false), // 15-digit UAE VAT numbers
      RegExp(r'\s*[:\s]*([0-9]{15})', caseSensitive: false),
    ];

    for (final pattern in vatNumberPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null) {
        var extracted = match.group(1)!.trim();
        if (extracted.length == 15 && vatNumber == null) {
          vatNumber = extracted;
          break;
        }
      }
    }

    // Extract Company Name
    final companyNamePatterns = [
      RegExp(r'company\s*name[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
      RegExp(r'business\s*name[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
      RegExp(r'establishment[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
      RegExp(r'taxpayer[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
      RegExp(r'\s*[:\s]*([a-z0-9\s&\-\.]{3,80})', caseSensitive: false),
    ];

    for (final pattern in companyNamePatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null) {
        var extracted = match.group(1)!.trim();
        if (extracted.length >= 3 && companyName == null) {
          companyName = _cleanCompanyName(extracted);
          break;
        }
      }
    }

    // Extract dates with context awareness
    final datePattern = RegExp(r'(\d{1,2})[\-\/\.](\d{1,2})[\-\/\.](\d{4})');
    final allDates = datePattern.allMatches(ocrText);
    final foundDates = <Map<String, dynamic>>[];

    for (final match in allDates) {
      final date = match.group(0)!;
      final year = int.parse(match.group(3)!);
      final month = int.parse(match.group(2)!);
      final day = int.parse(match.group(1)!);

      if (year >= 2010 && year <= 2040 && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
        final startIndex = match.start;
        final contextStart = startIndex > 30 ? startIndex - 30 : 0;
        final contextEnd = startIndex + 30 < ocrText.length ? startIndex + 30 : ocrText.length;
        final context = ocrText.substring(contextStart, contextEnd).toLowerCase();

        foundDates.add({'date': date, 'year': year, 'context': context});
      }
    }

    // Categorize dates by context
    for (final dateObj in foundDates) {
      final date = dateObj['date'] as String;
      final year = dateObj['year'] as int;
      final context = dateObj['context'] as String;

      // Registration date patterns
      if ((context.contains('registration') ||
              context.contains('registered') ||
              context.contains('issue') ||
              context.contains('issued') ||
              context.contains('') ||
              (year >= 2017 && year <= DateTime.now().year)) &&
          registrationDate == null) {
        registrationDate = date;
      }
      // Effective date patterns
      else if ((context.contains('effective') ||
              context.contains('valid from') ||
              context.contains('start') ||
              context.contains('') ||
              (year >= 2017 && year <= DateTime.now().year + 1)) &&
          effectiveDate == null) {
        effectiveDate = date;
      }
    }

    // Extract Registration Status
    final statusPatterns = [
      RegExp(r'status[:\s]*([a-z\s]{4,20})', caseSensitive: false),
      RegExp(r'(active|inactive|suspended|cancelled)', caseSensitive: false),
      RegExp(r'[:\s]*([a-z\s]{4,20})', caseSensitive: false),
    ];

    for (final pattern in statusPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && registrationStatus == null) {
        registrationStatus = _cleanStatus(match.group(1)!);
        break;
      }
    }

    // Extract Business Activity
    final activityPatterns = [
      RegExp(r'activity[:\s]*([a-z0-9\s&\-\.]{5,100})', caseSensitive: false),
      RegExp(r'business\s*activity[:\s]*([a-z0-9\s&\-\.]{5,100})', caseSensitive: false),
      RegExp(r'economic\s*activity[:\s]*([a-z0-9\s&\-\.]{5,100})', caseSensitive: false),
      RegExp(r'[:\s]*([a-z0-9\s&\-\.]{5,100})', caseSensitive: false),
    ];

    for (final pattern in activityPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && businessActivity == null) {
        businessActivity = _cleanActivity(match.group(1)!);
        break;
      }
    }

    // Extract Registered Address
    final addressPatterns = [
      RegExp(r'address[:\s]*([a-z0-9\s,\-\.]{10,150})', caseSensitive: false),
      RegExp(r'location[:\s]*([a-z0-9\s,\-\.]{10,150})', caseSensitive: false),
      RegExp(r'[:\s]*([a-z0-9\s,\-\.]{10,150})', caseSensitive: false),
    ];

    for (final pattern in addressPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && registeredAddress == null) {
        registeredAddress = _cleanAddress(match.group(1)!);
        break;
      }
    }

    // Extract Issuing Authority - UAE Tax authorities
    final authorityPatterns = [
      RegExp(r'federal\s*tax\s*authority', caseSensitive: false),
      RegExp(r'fta', caseSensitive: false),
      RegExp(r'uae\s*tax\s*authority', caseSensitive: false),
      RegExp(r'\s*\s*', caseSensitive: false),
    ];

    for (final pattern in authorityPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && issuingAuthority == null) {
        issuingAuthority = 'Federal Tax Authority (FTA)';
        break;
      }
    }

    // Extract Tax Period
    final taxPeriodPatterns = [
      RegExp(r'tax\s*period[:\s]*([a-z0-9\s]{5,30})', caseSensitive: false),
      RegExp(r'(monthly|quarterly|annual)', caseSensitive: false),
    ];

    for (final pattern in taxPeriodPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && taxPeriod == null) {
        taxPeriod = _cleanTaxPeriod(match.group(1)!);
        break;
      }
    }

    // Extract Business Type
    final businessTypePatterns = [
      RegExp(r'business\s*type[:\s]*([a-z\s]{5,40})', caseSensitive: false),
      RegExp(r'(llc|fze|fzco|establishment|branch)', caseSensitive: false),
    ];

    for (final pattern in businessTypePatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && businessType == null) {
        businessType = _cleanBusinessType(match.group(1)!);
        break;
      }
    }

    // Extract Phone Number
    final phonePatterns = [
      RegExp(r'phone[:\s]*(\+?[0-9\s\-\(\)]{8,20})', caseSensitive: false),
      RegExp(r'tel[:\s]*(\+?[0-9\s\-\(\)]{8,20})', caseSensitive: false),
      RegExp(r'mobile[:\s]*(\+?[0-9\s\-\(\)]{8,20})', caseSensitive: false),
    ];

    for (final pattern in phonePatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && phoneNumber == null) {
        phoneNumber = _cleanPhone(match.group(1)!);
        break;
      }
    }

    // Extract Email Address
    final emailPatterns = [
      RegExp(r'email[:\s]*([a-z0-9\.\-_]+@[a-z0-9\.\-_]+\.[a-z]{2,})', caseSensitive: false),
      RegExp(r'([a-z0-9\.\-_]+@[a-z0-9\.\-_]+\.[a-z]{2,})', caseSensitive: false),
    ];

    for (final pattern in emailPatterns) {
      final match = pattern.firstMatch(ocrText);
      if (match != null && match.group(1) != null && emailAddress == null) {
        emailAddress = match.group(1)!.toLowerCase().trim();
        break;
      }
    }

    return VATRegistrationData(
      vatNumber: vatNumber,
      companyName: companyName,
      registrationDate: registrationDate,
      effectiveDate: effectiveDate,
      registrationStatus: registrationStatus,
      businessActivity: businessActivity,
      registeredAddress: registeredAddress,
      issuingAuthority: issuingAuthority,
      taxPeriod: taxPeriod,
      businessType: businessType,
      phoneNumber: phoneNumber,
      emailAddress: emailAddress,
    );
  }

  // Helper methods for cleaning extracted data
  static String? _cleanCompanyName(String? name) {
    if (name == null || name.isEmpty) return null;

    name = name.replaceAll(RegExp(r'[^\w\s&\-\.]'), ' ');
    name = name.replaceAll(RegExp(r'\s+'), ' ').trim();

    return name.length >= 3 ? _capitalizeWords(name) : null;
  }

  static String? _cleanStatus(String? status) {
    if (status == null || status.isEmpty) return null;

    status = status.toLowerCase().trim();

    // Standardize status values
    final statusMap = {
      'active': 'Active',
      'inactive': 'Inactive',
      'suspended': 'Suspended',
      'cancelled': 'Cancelled',
      'valid': 'Active',
      'invalid': 'Inactive',
    };

    return statusMap[status] ?? _capitalizeWords(status);
  }

  static String? _cleanActivity(String? activity) {
    if (activity == null || activity.isEmpty) return null;

    activity = activity.replaceAll(RegExp(r'[^\w\s&\-\.]'), ' ');
    activity = activity.replaceAll(RegExp(r'\s+'), ' ').trim();

    return activity.length >= 5 ? _capitalizeWords(activity) : null;
  }

  static String? _cleanAddress(String? address) {
    if (address == null || address.isEmpty) return null;

    address = address.replaceAll(RegExp(r'[^\w\s,\-\.]'), ' ');
    address = address.replaceAll(RegExp(r'\s+'), ' ').trim();

    return address.length >= 10 ? _capitalizeWords(address) : null;
  }

  static String? _cleanTaxPeriod(String? period) {
    if (period == null || period.isEmpty) return null;

    period = period.toLowerCase().trim();

    // Standardize tax periods
    final periodMap = {
      'monthly': 'Monthly',
      'quarterly': 'Quarterly',
      'annual': 'Annual',
      'yearly': 'Annual',
    };

    return periodMap[period] ?? _capitalizeWords(period);
  }

  static String? _cleanBusinessType(String? type) {
    if (type == null || type.isEmpty) return null;

    type = type.toLowerCase().trim();

    // Standardize business types
    final typeMap = {
      'llc': 'LLC',
      'fze': 'FZE',
      'fzco': 'FZCO',
      'establishment': 'Establishment',
      'branch': 'Branch',
    };

    return typeMap[type] ?? _capitalizeWords(type);
  }

  static String? _cleanPhone(String? phone) {
    if (phone == null || phone.isEmpty) return null;

    // Remove extra characters but keep numbers, +, -, (, )
    phone = phone.replaceAll(RegExp(r'[^\d\+\-\(\)\s]'), '');
    phone = phone.replaceAll(RegExp(r'\s+'), ' ').trim();

    return phone.length >= 8 ? phone : null;
  }

  static String _capitalizeWords(String text) {
    return text
        .split(' ')
        .map((word) => word.isNotEmpty
            ? word[0].toUpperCase() + word.substring(1).toLowerCase()
            : word)
        .join(' ');
  }

  // Get form field mapping for VAT registration data
  static Map<String, String> getFormFieldMapping(VATRegistrationData data) {
    final mapping = <String, String>{};

    if (data.vatNumber != null) mapping['vatNumber'] = data.vatNumber!;
    if (data.companyName != null) mapping['companyName'] = data.companyName!;
    if (data.registrationDate != null) mapping['registrationDate'] = data.registrationDate!;
    if (data.effectiveDate != null) mapping['effectiveDate'] = data.effectiveDate!;
    if (data.registrationStatus != null) mapping['registrationStatus'] = data.registrationStatus!;
    if (data.businessActivity != null) mapping['businessActivity'] = data.businessActivity!;
    if (data.registeredAddress != null) mapping['registeredAddress'] = data.registeredAddress!;

    return mapping;
  }
}

// Extension methods for easy validation
extension VATRegistrationValidation on VATRegistrationData {
  bool get hasValidVATNumber => vatNumber != null && vatNumber!.length == 15;

  bool get hasValidCompanyName => companyName != null && companyName!.length >= 3;

  bool get hasValidRegistrationDate => registrationDate != null && registrationDate!.isNotEmpty;

  bool get isActiveRegistration => registrationStatus?.toLowerCase() == 'active';
}






































import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'dart:async';
import 'package:go_router/go_router.dart';
import 'package:rak_web/core/services/trade_license_ocr_service.dart';
import '../../../core/services/vat_registration_ocr_service.dart';
import '../../../core/services/bank_details_ocr_service.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:web/web.dart' as web;
import 'dart:js_interop';
import '../../../core/models/retailer_onboarding_models.dart';
import '../../../core/services/retailer_onboarding_service.dart';
import '../../../core/widgets/custom_back_button.dart';
import '../../../core/widgets/file_upload_widget.dart';

@JS()
@staticInterop
class WindowWithGeoLocation {}

extension WindowGeoLocationExtension on WindowWithGeoLocation {
  external JSPromise<JSAny?> requestGeoPosition();
}

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(RetailerOnboardingApp());
}

class RetailerOnboardingApp extends StatelessWidget {
  const RetailerOnboardingApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Retailer Onboarding',
      theme: ThemeData(primarySwatch: Colors.blue, fontFamily: 'Roboto'),
      home: RetailerFormPage(),
    );
  }
}

class RetailerFormPage extends StatefulWidget {
  const RetailerFormPage({super.key});

  @override
  RetailerFormPageState createState() => RetailerFormPageState();
}

class RetailerFormPageState extends State<RetailerFormPage>
    with TickerProviderStateMixin {
  final _formKey = GlobalKey<FormState>();
  final bool _isVATRequired = true;
  bool _isSubmitting = false;
  bool _isGettingLocation = false;

  // File paths for uploads
  String? _licenseImage;
  String? _vatCertificateImage;
  String? _bankStatementImage;
  String? _shopImage;

  // OCR processing state
  bool _isProcessingOCR = false;
  String? _ocrError;
  double _ocrProgress = 0.0;
  String _ocrCurrentStep = '';
  int _estimatedTimeLeft = 0;
  DateTime? _ocrStartTime;
  Timer? _progressTimer;

  // VAT OCR processing state
  bool _isProcessingVATOCR = false;
  String? _vatOcrError;
  double _vatOcrProgress = 0.0;
  String _vatOcrCurrentStep = '';
  int _vatEstimatedTimeLeft = 0;
  DateTime? _vatOcrStartTime;
  Timer? _vatProgressTimer;

  // Bank OCR processing state
  bool _isProcessingBankOCR = false;
  String? _bankOcrError;
  double _bankOcrProgress = 0.0;
  String _bankOcrCurrentStep = '';
  int _bankEstimatedTimeLeft = 0;
  DateTime? _bankOcrStartTime;
  Timer? _bankProgressTimer;

  // Controllers
  final firmNameController = TextEditingController();
  final taxRegNumberController = TextEditingController();
  final registeredAddressController = TextEditingController();
  final effectiveDateController = TextEditingController();
  final licenseNumberController = TextEditingController();
  final issuingAuthorityController = TextEditingController();
  final establishmentDateController = TextEditingController();
  final expiryDateController = TextEditingController();
  final tradeNameController = TextEditingController();
  final responsiblePersonController = TextEditingController();
  final accountNameController = TextEditingController();
  final ibanController = TextEditingController();
  final bankNameController = TextEditingController();
  final branchNameController = TextEditingController();
  final branchAddressController = TextEditingController();
  final latitudeController = TextEditingController();
  final longitudeController = TextEditingController();

  // Animations
  AnimationController? _mainController;
  AnimationController? _fabController;
  Animation<double>? _fadeAnimation;
  Animation<Offset>? _slideAnimation;
  Animation<double>? _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _mainController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );
    _fabController = AnimationController(
      duration: const Duration(milliseconds: 400),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(
        parent: _mainController!,
        curve: const Interval(0.0, 0.5, curve: Curves.easeOut),
      ),
    );
    _slideAnimation =
        Tween<Offset>(begin: const Offset(0, 0.3), end: Offset.zero).animate(
          CurvedAnimation(
            parent: _mainController!,
            curve: const Interval(0.2, 0.7, curve: Curves.easeOutCubic),
          ),
        );
    _scaleAnimation = Tween<double>(begin: 0.95, end: 1.0).animate(
      CurvedAnimation(
        parent: _mainController!,
        curve: const Interval(0.3, 0.8, curve: Curves.easeOutCubic),
      ),
    );
    _mainController?.forward();
    _fabController?.forward();
    // Auto-fill on load
    _initLocation();
  }

  @override
  void dispose() {
    _mainController?.dispose();
    _fabController?.dispose();
    _progressTimer?.cancel();
    _vatProgressTimer?.cancel();
    _bankProgressTimer?.cancel();
    firmNameController.dispose();
    taxRegNumberController.dispose();
    registeredAddressController.dispose();
    effectiveDateController.dispose();
    licenseNumberController.dispose();
    issuingAuthorityController.dispose();
    establishmentDateController.dispose();
    expiryDateController.dispose();
    tradeNameController.dispose();
    responsiblePersonController.dispose();
    accountNameController.dispose();
    ibanController.dispose();
    bankNameController.dispose();
    branchNameController.dispose();
    branchAddressController.dispose();
    latitudeController.dispose();
    longitudeController.dispose();
    super.dispose();
  }

  // --- GEOLOCATION (using web JavaScript helper from index.html) ---
  Future<void> _initLocation() async {
    setState(() => _isGettingLocation = true);
    try {
      await _getWebLocation();
    } catch (e) {
      _toast('Could not fetch location: $e');
    } finally {
      if (mounted) setState(() => _isGettingLocation = false);
    }
  }

  Future<void> _getWebLocation() async {
    try {
      // First try to get from localStorage (cached values from index.html)
      final lastLat = web.window.localStorage.getItem('lastLat');
      final lastLng = web.window.localStorage.getItem('lastLng');
      if (lastLat != null && lastLng != null && mounted) {
        latitudeController.text = double.parse(lastLat).toStringAsFixed(6);
        longitudeController.text = double.parse(lastLng).toStringAsFixed(6);
      }
      // Use the JavaScript geolocation helper from index.html
      final jsWindow = web.window as WindowWithGeoLocation;
      final result = await jsWindow.requestGeoPosition().toDart;
      if (result != null) {
        // Convert JSAny to proper Dart object
        final resultDart = result.dartify();
        if (resultDart is Map<String, dynamic>) {
          if (resultDart['ok'] == true) {
            if (mounted) {
              final lat = resultDart['lat'] as num?;
              final lng = resultDart['lng'] as num?;
              if (lat != null && lng != null) {
                latitudeController.text = lat.toStringAsFixed(6);
                longitudeController.text = lng.toStringAsFixed(6);
              }
            }
          } else {
            final error = resultDart['error']?.toString() ?? 'Unknown error';
            _toast('Web geolocation failed: $error');
          }
        }
      }
    } catch (e) {
      _toast('Web geolocation error: $e');
    }
  }

  void _toast(String msg) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(msg), behavior: SnackBarBehavior.floating),
    );
  }

  Future<void> _saveData() async {
    setState(() => _isSubmitting = true);
    try {
      // Create request object from form data - ensure non-empty strings or null
      final request = RetailerOnboardingRequest(
        firmName: _cleanString(firmNameController.text),
        taxRegistrationNumber: _cleanString(taxRegNumberController.text),
        registeredAddress: _cleanString(registeredAddressController.text),
        effectiveRegistrationDate: _cleanString(effectiveDateController.text),
        licenseNumber: _cleanString(licenseNumberController.text),
        issuingAuthority: _cleanString(issuingAuthorityController.text),
        establishmentDate: _cleanString(establishmentDateController.text),
        expiryDate: _cleanString(expiryDateController.text),
        tradeName: _cleanString(tradeNameController.text),
        responsiblePerson: _cleanString(responsiblePersonController.text),
        accountHolderName: _cleanString(accountNameController.text),
        ibanNumber: _cleanString(ibanController.text),
        bankName: _cleanString(bankNameController.text),
        branchName: _cleanString(branchNameController.text),
        branchAddress: _cleanString(branchAddressController.text),
        latitude: _cleanString(latitudeController.text),
        longitude: _cleanString(longitudeController.text),
      );
      print('DEBUG: About to submit request with data: ${request.toJson()}');
      // Submit to API
      print('DEBUG: Calling RetailerOnboardingService.registerRetailer...');
      final response = await RetailerOnboardingService.registerRetailer(
        request,
      );
      print(
        'DEBUG: Got response: success=${response.success}, message=${response.message}',
      );
      if (response.success) {
        // Save to local storage as backup
        await _saveToLocalStorage();
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Row(
                children: [
                  const Icon(Icons.check_circle, color: Colors.white, size: 20),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Registration Successful!\nRetailer Code: ${response.retailerCode ?? 'N/A'}',
                    ),
                  ),
                ],
              ),
              backgroundColor: Colors.green,
              behavior: SnackBarBehavior.floating,
              duration: const Duration(seconds: 5),
            ),
          );
          // Navigate to success or show retailer code
          _showSuccessDialog(response.retailerCode);
        }
      } else {
        // Show error message
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Row(
                children: [
                  const Icon(Icons.error, color: Colors.white, size: 20),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Registration Failed: ${response.error ?? response.message}',
                    ),
                  ),
                ],
              ),
              backgroundColor: Colors.red,
              behavior: SnackBarBehavior.floating,
              duration: const Duration(seconds: 5),
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Row(
              children: [
                const Icon(Icons.error, color: Colors.white, size: 20),
                const SizedBox(width: 8),
                Expanded(child: Text('Network Error: $e')),
              ],
            ),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
            duration: const Duration(seconds: 5),
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  Future<void> _saveToLocalStorage() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('firmName', firmNameController.text);
    await prefs.setString('taxRegNumber', taxRegNumberController.text);
    await prefs.setString(
      'registeredAddress',
      registeredAddressController.text,
    );
    await prefs.setString('effectiveDate', effectiveDateController.text);
    await prefs.setString('licenseNumber', licenseNumberController.text);
    await prefs.setString('issuingAuthority', issuingAuthorityController.text);
    await prefs.setString(
      'establishmentDate',
      establishmentDateController.text,
    );
    await prefs.setString('expiryDate', expiryDateController.text);
    await prefs.setString('tradeName', tradeNameController.text);
    await prefs.setString(
      'responsiblePerson',
      responsiblePersonController.text,
    );
    await prefs.setString('accountName', accountNameController.text);
    await prefs.setString('iban', ibanController.text);
    await prefs.setString('bankName', bankNameController.text);
    await prefs.setString('branchName', branchNameController.text);
    await prefs.setString('branchAddress', branchAddressController.text);
    await prefs.setString('latitude', latitudeController.text);
    await prefs.setString('longitude', longitudeController.text);
  }

  void _showSuccessDialog(String? retailerCode) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.check_circle, size: 64, color: Colors.green),
              const SizedBox(height: 16),
              const Text(
                'Registration Successful!',
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              if (retailerCode != null) ...[
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.green.shade50,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.green.shade200),
                  ),
                  child: Column(
                    children: [
                      const Text(
                        'Your Retailer Code:',
                        style: TextStyle(fontWeight: FontWeight.w500),
                      ),
                      const SizedBox(height: 4),
                      SelectableText(
                        retailerCode,
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: Colors.green,
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
              ],
              const Text(
                'Your registration has been submitted successfully. Please save your retailer code for future reference.',
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    Navigator.pop(context);
                    // You can navigate to a different screen here if needed
                  },
                  child: const Text('Continue'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String? _validateTaxRegNumber(String? value) {
    return RetailerOnboardingService.validateTaxRegistrationNumber(value);
  }

  String? _validateLicense(String? value) {
    return RetailerOnboardingService.validateLicenseNumber(value);
  }

  String? _validateIBAN(String? value) {
    return RetailerOnboardingService.validateIban(value);
  }

  String? _validateFirmName(String? value) {
    return RetailerOnboardingService.validateFirmName(value);
  }

  String? _validateTradeName(String? value) {
    return RetailerOnboardingService.validateTradeName(value);
  }

  String? _validateResponsiblePerson(String? value) {
    return RetailerOnboardingService.validateResponsiblePerson(value);
  }

  String? _validateRegisteredAddress(String? value) {
    return RetailerOnboardingService.validateRegisteredAddress(value);
  }

  String? _validateIssuingAuthority(String? value) {
    return RetailerOnboardingService.validateIssuingAuthority(value);
  }

  String? _validateAccountHolderName(String? value) {
    return RetailerOnboardingService.validateAccountHolderName(value);
  }

  String? _validateBankName(String? value) {
    return RetailerOnboardingService.validateBankName(value);
  }

  String? _validateBranchName(String? value) {
    return RetailerOnboardingService.validateBranchName(value);
  }

  String? _validateBranchAddress(String? value) {
    return RetailerOnboardingService.validateBranchAddress(value);
  }

  String? _validateLatitude(String? value) {
    return RetailerOnboardingService.validateLatitude(value);
  }

  String? _validateLongitude(String? value) {
    return RetailerOnboardingService.validateLongitude(value);
  }

  String? _cleanString(String value) {
    final cleaned = value.trim();
    return cleaned.isEmpty ? null : cleaned;
  }

  // Process Trade License with OCR and auto-fill fields
  Future<void> _processTradeLicenseOCR(String filePath) async {
    try {
      print('Starting OCR processing for trade license: $filePath');

      // Initialize progress tracking
      _startProgressTracking();

      // Step 1: Document Scanning (0-40%)
      if (mounted) {
        setState(() {
          _ocrProgress = 0.1;
          _ocrCurrentStep = ' Analyzing document format...';
          _estimatedTimeLeft = 15;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _ocrProgress = 0.3;
          _ocrCurrentStep = ' Scanning document content...';
          _estimatedTimeLeft = 12;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      // Step 2: OCR Processing (40-70%)
      if (mounted) {
        setState(() {
          _ocrProgress = 0.5;
          _ocrCurrentStep = ' Running AI text recognition...';
          _estimatedTimeLeft = 8;
        });
      }

      // Process the trade license document with OCR
      final tradeLicenseData = await TradeLicenseOCRService.processTradeLicense(
        filePath,
      );

      // Step 3: Data Extraction (70-90%)
      if (mounted) {
        setState(() {
          _ocrProgress = 0.75;
          _ocrCurrentStep = ' Extracting license information...';
          _estimatedTimeLeft = 4;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      // Step 4: Field Population (90-100%)
      if (mounted) {
        setState(() {
          _ocrProgress = 0.9;
          _ocrCurrentStep = ' Auto-filling form fields...';
          _estimatedTimeLeft = 2;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _ocrProgress = 1.0;
          _ocrCurrentStep = ' Processing complete!';
          _estimatedTimeLeft = 0;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _isProcessingOCR = false;
          _progressTimer?.cancel();

          // Auto-fill form fields if OCR extracted data successfully
          if (tradeLicenseData.isValid) {
            print('OCR extracted valid data, auto-filling fields...');

            // Fill license details
            if (tradeLicenseData.licenseNumber != null) {
              licenseNumberController.text = tradeLicenseData.licenseNumber!;
            }

            if (tradeLicenseData.issuingAuthority != null) {
              issuingAuthorityController.text =
                  tradeLicenseData.issuingAuthority!;
            }

            if (tradeLicenseData.establishmentDate != null) {
              establishmentDateController.text =
                  tradeLicenseData.establishmentDate!;
            }

            if (tradeLicenseData.expiryDate != null) {
              expiryDateController.text = tradeLicenseData.expiryDate!;
            }

            if (tradeLicenseData.tradeName != null) {
              tradeNameController.text = tradeLicenseData.tradeName!;
            }

            if (tradeLicenseData.responsiblePerson != null) {
              responsiblePersonController.text =
                  tradeLicenseData.responsiblePerson!;
            }

            if (tradeLicenseData.registeredAddress != null) {
              registeredAddressController.text =
                  tradeLicenseData.registeredAddress!;
            }

            if (tradeLicenseData.effectiveRegistrationDate != null) {
              effectiveDateController.text =
                  tradeLicenseData.effectiveRegistrationDate!;
            }

            _ocrError = null;

            // Show success message
            _toast(
              ' Trade license processed successfully! All fields auto-filled in ${DateTime.now().difference(_ocrStartTime!).inSeconds}s.',
            );

            print('OCR auto-fill completed successfully');
          } else {
            print('OCR did not extract enough valid data');
            _ocrError =
                'Could not extract complete information from the document';
            _toast(
              ' Document processed but some fields could not be extracted. Please fill them manually.',
            );
          }
        });
      }
    } catch (e) {
      print('OCR processing error: $e');
      if (mounted) {
        setState(() {
          _isProcessingOCR = false;
          _progressTimer?.cancel();
          _ocrError = 'Failed to process document: $e';
        });
        _toast(' OCR processing failed. Please fill the fields manually.');
      }
    }
  }

  void _startProgressTracking() {
    _ocrStartTime = DateTime.now();
    _progressTimer = Timer.periodic(const Duration(milliseconds: 100), (timer) {
      if (!_isProcessingOCR) {
        timer.cancel();
        return;
      }

      if (mounted && _estimatedTimeLeft > 0) {
        setState(() {
          _estimatedTimeLeft = (_estimatedTimeLeft * 0.98).ceil();
        });
      }
    });
  }

  Widget _buildStepIndicator(int stepIndex, String label, bool isActive) {
    return Column(
      children: [
        Container(
          width: 32,
          height: 32,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: isActive ? Colors.blue.shade600 : Colors.grey.shade300,
            border: Border.all(
              color: isActive ? Colors.blue.shade600 : Colors.grey.shade400,
              width: 2,
            ),
          ),
          child: isActive
              ? const Icon(Icons.check, color: Colors.white, size: 16)
              : Text(
                  '${stepIndex + 1}',
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontWeight: FontWeight.bold,
                    fontSize: 12,
                  ),
                  textAlign: TextAlign.center,
                ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: TextStyle(
            fontSize: 10,
            fontWeight: FontWeight.w500,
            color: isActive ? Colors.blue.shade600 : Colors.grey.shade500,
          ),
        ),
      ],
    );
  }

  Widget _buildStepConnector(bool isActive) {
    return Container(
      width: 30,
      height: 2,
      margin: const EdgeInsets.only(bottom: 24),
      color: isActive ? Colors.blue.shade600 : Colors.grey.shade300,
    );
  }

  // Process VAT Registration with OCR and auto-fill fields
  Future<void> _processVATRegistrationOCR(String filePath) async {
    try {
      print('Starting VAT OCR processing for: $filePath');

      // Initialize progress tracking
      _startVATProgressTracking();

      // Step 1: Document Scanning (0-40%)
      if (mounted) {
        setState(() {
          _vatOcrProgress = 0.1;
          _vatOcrCurrentStep = ' Analyzing VAT certificate format...';
          _vatEstimatedTimeLeft = 12;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _vatOcrProgress = 0.3;
          _vatOcrCurrentStep = ' Scanning VAT document content...';
          _vatEstimatedTimeLeft = 10;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      // Step 2: OCR Processing (40-70%)
      if (mounted) {
        setState(() {
          _vatOcrProgress = 0.5;
          _vatOcrCurrentStep = ' Running AI VAT text recognition...';
          _vatEstimatedTimeLeft = 6;
        });
      }

      // Process the VAT registration document with OCR
      final vatRegistrationData = await VATRegistrationOCRService.processVATRegistration(filePath);

      // Debug: Print extracted VAT data
      print('=== VAT OCR EXTRACTED DATA ===');
      print('VAT Number: ${vatRegistrationData.vatNumber}');
      print('Company Name: ${vatRegistrationData.companyName}');
      print('Registration Date: ${vatRegistrationData.registrationDate}');
      print('Effective Date: ${vatRegistrationData.effectiveDate}');
      print('Registration Status: ${vatRegistrationData.registrationStatus}');
      print('Business Activity: ${vatRegistrationData.businessActivity}');
      print('Registered Address: ${vatRegistrationData.registeredAddress}');
      print('Is Valid: ${vatRegistrationData.isValid}');
      print('=== END VAT OCR DATA ===');

      // Step 3: Data Extraction (70-90%)
      if (mounted) {
        setState(() {
          _vatOcrProgress = 0.75;
          _vatOcrCurrentStep = ' Extracting VAT registration information...';
          _vatEstimatedTimeLeft = 3;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      // Step 4: Field Population (90-100%)
      if (mounted) {
        setState(() {
          _vatOcrProgress = 0.9;
          _vatOcrCurrentStep = ' Auto-filling VAT fields...';
          _vatEstimatedTimeLeft = 1;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _vatOcrProgress = 1.0;
          _vatOcrCurrentStep = ' VAT processing complete!';
          _vatEstimatedTimeLeft = 0;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _isProcessingVATOCR = false;
          _vatProgressTimer?.cancel();

          // Auto-fill form fields with any extracted data
          int fieldsFilledCount = 0;

          // Fill VAT details - only the 3 VAT-specific fields
          if (vatRegistrationData.vatNumber != null) {
            print('Setting Tax Registration Number: ${vatRegistrationData.vatNumber}');
            taxRegNumberController.text = vatRegistrationData.vatNumber!;
            print('Tax Registration Number Controller value: ${taxRegNumberController.text}');
            fieldsFilledCount++;
          } else {
            print('No VAT Number extracted');
          }

          if (vatRegistrationData.companyName != null) {
            print('Setting Firm Name: ${vatRegistrationData.companyName}');
            firmNameController.text = vatRegistrationData.companyName!;
            print('Firm Name Controller value: ${firmNameController.text}');
            fieldsFilledCount++;
          } else {
            print('No Company Name extracted');
          }

          if (vatRegistrationData.effectiveDate != null) {
            print('Setting Effective Date: ${vatRegistrationData.effectiveDate}');
            effectiveDateController.text = vatRegistrationData.effectiveDate!;
            print('Effective Date Controller value: ${effectiveDateController.text}');
            fieldsFilledCount++;
          } else if (vatRegistrationData.registrationDate != null) {
            print('Using Registration Date as Effective Date: ${vatRegistrationData.registrationDate}');
            effectiveDateController.text = vatRegistrationData.registrationDate!;
            print('Effective Date Controller value (from reg date): ${effectiveDateController.text}');
            fieldsFilledCount++;
          } else {
            print('No Effective Date or Registration Date extracted');
          }

          _vatOcrError = null;

          if (fieldsFilledCount > 0) {
            // Show success message with count of fields filled
            _toast(' VAT registration processed! $fieldsFilledCount fields auto-filled in ${DateTime.now().difference(_vatOcrStartTime!).inSeconds}s.');
            print('VAT OCR auto-fill completed successfully. Fields filled: $fieldsFilledCount');
          } else {
            print('VAT OCR did not extract any usable data');
            _vatOcrError = 'Could not extract VAT information from the document';
            _toast(' VAT document processed but no fields could be extracted. Please fill them manually.');
          }
        });
      }
    } catch (e) {
      print('VAT OCR processing error: $e');
      if (mounted) {
        setState(() {
          _isProcessingVATOCR = false;
          _vatProgressTimer?.cancel();
          _vatOcrError = 'Failed to process VAT document: $e';
        });
        _toast(' VAT OCR processing failed. Please fill the fields manually.');
      }
    }
  }

  void _startVATProgressTracking() {
    _vatOcrStartTime = DateTime.now();
    _vatProgressTimer = Timer.periodic(const Duration(milliseconds: 100), (timer) {
      if (!_isProcessingVATOCR) {
        timer.cancel();
        return;
      }

      if (mounted && _vatEstimatedTimeLeft > 0) {
        setState(() {
          _vatEstimatedTimeLeft = (_vatEstimatedTimeLeft * 0.98).ceil();
        });
      }
    });
  }

  Widget _buildVATStepIndicator(int stepIndex, String label, bool isActive) {
    return Column(
      children: [
        Container(
          width: 32,
          height: 32,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: isActive ? Colors.orange.shade600 : Colors.grey.shade300,
            border: Border.all(
              color: isActive ? Colors.orange.shade600 : Colors.grey.shade400,
              width: 2,
            ),
          ),
          child: isActive
              ? const Icon(Icons.check, color: Colors.white, size: 16)
              : Text(
                  '${stepIndex + 1}',
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontWeight: FontWeight.bold,
                    fontSize: 12,
                  ),
                  textAlign: TextAlign.center,
                ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: TextStyle(
            fontSize: 10,
            fontWeight: FontWeight.w500,
            color: isActive ? Colors.orange.shade600 : Colors.grey.shade500,
          ),
        ),
      ],
    );
  }

  Widget _buildVATStepConnector(bool isActive) {
    return Container(
      width: 30,
      height: 2,
      margin: const EdgeInsets.only(bottom: 24),
      color: isActive ? Colors.orange.shade600 : Colors.grey.shade300,
    );
  }

  // Process Bank Details with OCR and auto-fill fields
  Future<void> _processBankDetailsOCR(String filePath) async {
    try {
      print('Starting Bank OCR processing for: $filePath');

      // Initialize progress tracking
      _startBankProgressTracking();

      // Step 1: Document Scanning (0-40%)
      if (mounted) {
        setState(() {
          _bankOcrProgress = 0.1;
          _bankOcrCurrentStep = ' Analyzing bank document format...';
          _bankEstimatedTimeLeft = 10;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _bankOcrProgress = 0.3;
          _bankOcrCurrentStep = ' Scanning bank statement content...';
          _bankEstimatedTimeLeft = 8;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      // Step 2: OCR Processing (40-70%)
      if (mounted) {
        setState(() {
          _bankOcrProgress = 0.5;
          _bankOcrCurrentStep = ' Running AI bank text recognition...';
          _bankEstimatedTimeLeft = 5;
        });
      }

      // Process the bank document with OCR
      final bankDetailsData = await BankDetailsOCRService.processBankDocument(filePath);

      // Debug: Print extracted bank data
      print('=== BANK OCR EXTRACTED DATA ===');
      print('Account Holder Name: ${bankDetailsData.accountHolderName}');
      print('Account Number: ${bankDetailsData.accountNumber}');
      print('IBAN Number: ${bankDetailsData.ibanNumber}');
      print('Bank Name: ${bankDetailsData.bankName}');
      print('Branch Name: ${bankDetailsData.branchName}');
      print('Bank Address: ${bankDetailsData.bankAddress}');
      print('Is Valid: ${bankDetailsData.isValid}');
      print('=== END BANK OCR DATA ===');

      // Step 3: Data Extraction (70-90%)
      if (mounted) {
        setState(() {
          _bankOcrProgress = 0.75;
          _bankOcrCurrentStep = ' Extracting bank account information...';
          _bankEstimatedTimeLeft = 2;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      // Step 4: Field Population (90-100%)
      if (mounted) {
        setState(() {
          _bankOcrProgress = 0.9;
          _bankOcrCurrentStep = ' Auto-filling bank fields...';
          _bankEstimatedTimeLeft = 1;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _bankOcrProgress = 1.0;
          _bankOcrCurrentStep = ' Bank processing complete!';
          _bankEstimatedTimeLeft = 0;
        });
      }
      await Future.delayed(const Duration(milliseconds: 500));

      if (mounted) {
        setState(() {
          _isProcessingBankOCR = false;
          _bankProgressTimer?.cancel();

          // Auto-fill form fields with any extracted bank data
          int fieldsFilledCount = 0;

          // Fill bank details - the 4 main bank fields
          if (bankDetailsData.accountHolderName != null) {
            print('Setting Account Name: ${bankDetailsData.accountHolderName}');
            accountNameController.text = bankDetailsData.accountHolderName!;
            print('Account Name Controller value: ${accountNameController.text}');
            fieldsFilledCount++;
          } else {
            print('No Account Holder Name extracted');
          }

          if (bankDetailsData.ibanNumber != null) {
            print('Setting IBAN: ${bankDetailsData.ibanNumber}');
            ibanController.text = bankDetailsData.ibanNumber!;
            print('IBAN Controller value: ${ibanController.text}');
            fieldsFilledCount++;
          } else {
            print('No IBAN Number extracted');
          }

          if (bankDetailsData.bankName != null) {
            print('Setting Bank Name: ${bankDetailsData.bankName}');
            bankNameController.text = bankDetailsData.bankName!;
            print('Bank Name Controller value: ${bankNameController.text}');
            fieldsFilledCount++;
          } else {
            print('No Bank Name extracted');
          }

          if (bankDetailsData.branchName != null) {
            print('Setting Branch Name: ${bankDetailsData.branchName}');
            branchNameController.text = bankDetailsData.branchName!;
            print('Branch Name Controller value: ${branchNameController.text}');
            fieldsFilledCount++;
          } else if (bankDetailsData.bankAddress != null) {
            print('Using Bank Address as Branch Name: ${bankDetailsData.bankAddress}');
            branchNameController.text = bankDetailsData.bankAddress!;
            print('Branch Name Controller value (from address): ${branchNameController.text}');
            fieldsFilledCount++;
          } else {
            print('No Branch Name or Bank Address extracted');
          }

          // Also try to set branch address if available
          if (bankDetailsData.bankAddress != null) {
            print('Setting Branch Address: ${bankDetailsData.bankAddress}');
            branchAddressController.text = bankDetailsData.bankAddress!;
            print('Branch Address Controller value: ${branchAddressController.text}');
            fieldsFilledCount++;
          }

          _bankOcrError = null;

          if (fieldsFilledCount > 0) {
            // Show success message with count of fields filled
            _toast(' Bank document processed! $fieldsFilledCount fields auto-filled in ${DateTime.now().difference(_bankOcrStartTime!).inSeconds}s.');
            print('Bank OCR auto-fill completed successfully. Fields filled: $fieldsFilledCount');
          } else {
            print('Bank OCR did not extract any usable data');
            _bankOcrError = 'Could not extract bank information from the document';
            _toast(' Bank document processed but no fields could be extracted. Please fill them manually.');
          }
        });
      }
    } catch (e) {
      print('Bank OCR processing error: $e');
      if (mounted) {
        setState(() {
          _isProcessingBankOCR = false;
          _bankProgressTimer?.cancel();
          _bankOcrError = 'Failed to process bank document: $e';
        });
        _toast(' Bank OCR processing failed. Please fill the fields manually.');
      }
    }
  }

  void _startBankProgressTracking() {
    _bankOcrStartTime = DateTime.now();
    _bankProgressTimer = Timer.periodic(const Duration(milliseconds: 100), (timer) {
      if (!_isProcessingBankOCR) {
        timer.cancel();
        return;
      }

      if (mounted && _bankEstimatedTimeLeft > 0) {
        setState(() {
          _bankEstimatedTimeLeft = (_bankEstimatedTimeLeft * 0.98).ceil();
        });
      }
    });
  }

  Widget _buildBankStepIndicator(int stepIndex, String label, bool isActive) {
    return Column(
      children: [
        Container(
          width: 32,
          height: 32,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: isActive ? Colors.green.shade600 : Colors.grey.shade300,
            border: Border.all(
              color: isActive ? Colors.green.shade600 : Colors.grey.shade400,
              width: 2,
            ),
          ),
          child: isActive
              ? const Icon(Icons.check, color: Colors.white, size: 16)
              : Text(
                  '${stepIndex + 1}',
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontWeight: FontWeight.bold,
                    fontSize: 12,
                  ),
                  textAlign: TextAlign.center,
                ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: TextStyle(
            fontSize: 10,
            fontWeight: FontWeight.w500,
            color: isActive ? Colors.green.shade600 : Colors.grey.shade500,
          ),
        ),
      ],
    );
  }

  Widget _buildBankStepConnector(bool isActive) {
    return Container(
      width: 30,
      height: 2,
      margin: const EdgeInsets.only(bottom: 24),
      color: isActive ? Colors.green.shade600 : Colors.grey.shade300,
    );
  }

  PreferredSizeWidget _buildModernAppBar() {
    return AppBar(
      elevation: 0,
      backgroundColor: Colors.transparent,
      foregroundColor: Colors.blue.shade800,
      systemOverlayStyle: const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.dark,
      ),
      leading: CustomBackButton(
        onPressed: () {
          context.pop();
        },
      ),
      title: const Text(
        'Retailer Onboarding',
        style: TextStyle(fontWeight: FontWeight.w600, fontSize: 20),
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.help_outline_rounded),
          onPressed: _showHelpDialog,
        ),
      ],
    );
  }

  Widget _buildAnimatedHeader() {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(30),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [Colors.blue.shade700, Colors.blue.shade500],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(20),
        boxShadow: [
          BoxShadow(
            color: Colors.blue.withValues(alpha: 0.2),
            blurRadius: 20,
            offset: const Offset(0, 10),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: const [
          _FadeSlide(text: 'Welcome!', big: true),
          SizedBox(height: 8),
          _FadeSlide(text: 'Complete your retailer registration'),
        ],
      ),
    );
  }

  Widget _buildModernSection({
    required String title,
    required IconData icon,
    required List<Widget> children,
    bool isOptional = false,
  }) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withValues(alpha: 0.1),
            blurRadius: 10,
            offset: const Offset(0, 5),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Container(
            padding: const EdgeInsets.all(20),
            decoration: BoxDecoration(
              color: Colors.blue.shade50,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            child: Row(
              children: [
                Container(
                  width: 48,
                  height: 48,
                  decoration: const BoxDecoration(
                    color: Colors.blue,
                    shape: BoxShape.circle,
                  ),
                  child: Icon(icon, color: Colors.white, size: 24),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                          color: Colors.blue.shade800,
                        ),
                      ),
                      if (isOptional)
                        Text(
                          'Optional',
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey.shade500,
                          ),
                        ),
                    ],
                  ),
                ),
                if (title == 'Location Details')
                  AnimatedOpacity(
                    duration: const Duration(milliseconds: 250),
                    opacity: _isGettingLocation ? 1 : 0,
                    child: const Padding(
                      padding: EdgeInsets.only(right: 6),
                      child: SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      ),
                    ),
                  ),
              ],
            ),
          ),
          // Content
          Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: children,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildModernTextField({
    required TextEditingController controller,
    required String label,
    required IconData icon,
    bool isRequired = true,
    String? Function(String?)? validator,
    Widget? suffix,
  }) {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(milliseconds: 500),
      curve: Curves.easeOut,
      builder: (context, value, child) => Transform.translate(
        offset: Offset(0, 20 * (1 - value)),
        child: Opacity(opacity: value, child: child),
      ),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(
          labelText: isRequired ? '$label *' : label,
          prefixIcon: Icon(icon, color: Colors.grey.shade600),
          suffixIcon: suffix,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(color: Colors.grey.shade300),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(color: Colors.grey.shade300),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Colors.blue, width: 2),
          ),
          filled: true,
          fillColor: Colors.grey.shade50,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 16,
          ),
        ),
        validator: validator,
      ),
    );
  }

  Widget _buildModernDateField({
    required TextEditingController controller,
    required String label,
    required IconData icon,
    required BuildContext context,
    bool isRequired = true,
  }) {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(milliseconds: 500),
      curve: Curves.easeOut,
      builder: (context, value, child) => Transform.translate(
        offset: Offset(0, 20 * (1 - value)),
        child: Opacity(opacity: value, child: child),
      ),
      child: TextFormField(
        controller: controller,
        readOnly: true,
        decoration: InputDecoration(
          labelText: isRequired ? '$label *' : label,
          prefixIcon: Icon(icon, color: Colors.grey.shade600),
          suffixIcon: const Icon(
            Icons.calendar_today_rounded,
            color: Colors.grey,
          ),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(color: Colors.grey.shade300),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide(color: Colors.grey.shade300),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: const BorderSide(color: Colors.blue, width: 2),
          ),
          filled: true,
          fillColor: Colors.grey.shade50,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 16,
          ),
        ),
        onTap: () async {
          final date = await showDatePicker(
            context: context,
            initialDate: DateTime.now(),
            firstDate: DateTime(1900),
            lastDate: DateTime(2100),
            builder: (context, child) => Theme(
              data: Theme.of(context).copyWith(
                colorScheme: const ColorScheme.light(primary: Colors.blue),
              ),
              child: child!,
            ),
          );
          if (date != null && mounted) {
            controller.text = date.toString().split(' ').first;
          }
        },
        validator: isRequired
            ? (v) => v?.isEmpty == true ? 'Please enter $label' : null
            : null,
      ),
    );
  }

  Widget _buildAnimatedSubmitButton() {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(milliseconds: 600),
      curve: Curves.easeOutCubic,
      builder: (context, value, child) =>
          Transform.scale(scale: 0.8 + (0.2 * value), child: child),
      child: SizedBox(
        width: double.infinity,
        height: 56,
        child: ElevatedButton(
          onPressed: _isSubmitting ? null : _submitForm,
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.blue.shade700,
            foregroundColor: Colors.white,
            elevation: 8,
            shadowColor: Colors.blue.withValues(alpha: 0.3),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(16),
            ),
          ),
          child: _isSubmitting
              ? const Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.white,
                      ),
                    ),
                    SizedBox(width: 16),
                    Text('Submitting...', style: TextStyle(fontSize: 16)),
                  ],
                )
              : const Text(
                  'Submit Registration',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
        ),
      ),
    );
  }

  void _showHelpDialog() {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: Container(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(
                Icons.help_outline_rounded,
                size: 48,
                color: Colors.blue,
              ),
              const SizedBox(height: 16),
              const Text(
                'Registration Help',
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              const Text(
                'Fill in all required fields marked with *.\nVAT Registration is required only if your firm\'s Annual Turnover exceeds AED 375,000.',
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('Got it'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  void _submitForm() async {
    if (_formKey.currentState!.validate()) {
      await _saveData();
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final isDesktop = constraints.maxWidth > 1200;
        final isTablet =
            constraints.maxWidth > 800 && constraints.maxWidth <= 1200;
        final isMobile = constraints.maxWidth <= 800;

        return Scaffold(
          backgroundColor: Colors.grey.shade50,
          appBar: _buildModernAppBar(),
          body: FadeTransition(
            opacity: _fadeAnimation ?? const AlwaysStoppedAnimation(1.0),
            child: SlideTransition(
              position:
                  _slideAnimation ?? const AlwaysStoppedAnimation(Offset.zero),
              child: Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      Colors.blue.shade50,
                      Colors.white,
                      Colors.grey.shade50,
                    ],
                  ),
                ),
                child: SingleChildScrollView(
                  padding: EdgeInsets.symmetric(
                    horizontal: isDesktop ? 48 : (isTablet ? 32 : 24),
                    vertical: 24,
                  ),
                  child: Center(
                    child: ConstrainedBox(
                      constraints: BoxConstraints(
                        maxWidth: isDesktop ? 1400 : double.infinity,
                      ),
                      child: ScaleTransition(
                        scale:
                            _scaleAnimation ??
                            const AlwaysStoppedAnimation(1.0),
                        child: Form(
                          key: _formKey,
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              _buildAnimatedHeader(),
                              const SizedBox(height: 32),
                              // Main Content - Two columns on desktop
                              if (isDesktop)
                                _buildDesktopLayout()
                              else
                                _buildMobileLayout(),
                              const SizedBox(height: 48),
                              _buildAnimatedSubmitButton(),
                              const SizedBox(height: 48),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildDesktopLayout() {
    return Column(
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Left Column
            Expanded(
              child: Column(
                children: [
                  // Trade License
                  _buildModernSection(
                    title: 'Trade License Details',
                    icon: Icons.assignment_rounded,
                    children: [
                      _buildModernTextField(
                        controller: licenseNumberController,
                        label: 'License Number',
                        icon: Icons.confirmation_number,
                        validator: _validateLicense,
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: issuingAuthorityController,
                        label: 'Issuing Authority',
                        icon: Icons.account_balance,
                      ),
                      const SizedBox(height: 16),
                      _buildModernDateField(
                        controller: establishmentDateController,
                        label: 'Establishment Date',
                        icon: Icons.event,
                        context: context,
                      ),
                      const SizedBox(height: 16),
                      _buildModernDateField(
                        controller: expiryDateController,
                        label: 'Expiry Date',
                        icon: Icons.event_busy,
                        context: context,
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: tradeNameController,
                        label: 'Trade Name',
                        icon: Icons.store,
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: responsiblePersonController,
                        label: 'Responsible Person',
                        icon: Icons.person,
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: registeredAddressController,
                        label: 'Registered Address',
                        icon: Icons.location_on,
                      ),
                      const SizedBox(height: 16),
                      _buildModernDateField(
                        controller: effectiveDateController,
                        label: 'Effective Registration Date',
                        icon: Icons.calendar_today,
                        context: context,
                      ),
                      const SizedBox(height: 16),
                      Stack(
                        children: [
                          FileUploadWidget(
                            label: 'Trade License Document',
                            icon: Icons.assignment,
                            allowedExtensions: ['pdf', 'jpg', 'jpeg', 'png'],
                            maxSizeInMB: 10.0,
                            currentFilePath: _licenseImage,
                            onFileSelected: (filePath) async {
                              setState(() {
                                _licenseImage = filePath;
                                _isProcessingOCR = true;
                                _ocrError = null;
                              });

                              if (filePath != null) {
                                await _processTradeLicenseOCR(filePath);
                              }
                            },
                          ),
                          if (_isProcessingOCR)
                            Positioned.fill(
                              child: Container(
                                decoration: BoxDecoration(
                                  color: Colors.black.withOpacity(0.8),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: Center(
                                  child: Container(
                                    padding: const EdgeInsets.all(24),
                                    decoration: BoxDecoration(
                                      color: Colors.white,
                                      borderRadius: BorderRadius.circular(16),
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.black.withOpacity(0.2),
                                          blurRadius: 20,
                                          offset: const Offset(0, 10),
                                        ),
                                      ],
                                    ),
                                    child: Column(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        // AI Processing Icon
                                        Container(
                                          width: 60,
                                          height: 60,
                                          decoration: BoxDecoration(
                                            gradient: LinearGradient(
                                              colors: [
                                                Colors.blue.shade400,
                                                Colors.purple.shade400,
                                              ],
                                              begin: Alignment.topLeft,
                                              end: Alignment.bottomRight,
                                            ),
                                            shape: BoxShape.circle,
                                          ),
                                          child: const Icon(
                                            Icons.auto_awesome,
                                            color: Colors.white,
                                            size: 30,
                                          ),
                                        ),
                                        const SizedBox(height: 16),

                                        // Title
                                        const Text(
                                          'AI Reading Document',
                                          style: TextStyle(
                                            fontSize: 18,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.black87,
                                          ),
                                        ),
                                        const SizedBox(height: 8),

                                        // Current Step
                                        Text(
                                          _ocrCurrentStep,
                                          style: TextStyle(
                                            fontSize: 14,
                                            color: Colors.grey.shade600,
                                          ),
                                          textAlign: TextAlign.center,
                                        ),
                                        const SizedBox(height: 20),

                                        // Progress Bar
                                        Container(
                                          width: 200,
                                          height: 8,
                                          decoration: BoxDecoration(
                                            color: Colors.grey.shade200,
                                            borderRadius: BorderRadius.circular(
                                              4,
                                            ),
                                          ),
                                          child: Stack(
                                            children: [
                                              AnimatedContainer(
                                                duration: const Duration(
                                                  milliseconds: 300,
                                                ),
                                                width: 200 * _ocrProgress,
                                                height: 8,
                                                decoration: BoxDecoration(
                                                  gradient: LinearGradient(
                                                    colors: [
                                                      Colors.blue.shade400,
                                                      Colors.purple.shade400,
                                                    ],
                                                  ),
                                                  borderRadius:
                                                      BorderRadius.circular(4),
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                        const SizedBox(height: 12),

                                        // Progress Percentage and Time
                                        Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.spaceBetween,
                                          children: [
                                            Text(
                                              '${(_ocrProgress * 100).toInt()}%',
                                              style: TextStyle(
                                                fontSize: 14,
                                                fontWeight: FontWeight.w600,
                                                color: Colors.blue.shade700,
                                              ),
                                            ),
                                            Text(
                                              _estimatedTimeLeft > 0
                                                  ? '${_estimatedTimeLeft}s remaining'
                                                  : 'Almost done...',
                                              style: TextStyle(
                                                fontSize: 12,
                                                color: Colors.grey.shade600,
                                              ),
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 16),

                                        // Processing Steps Indicator
                                        Row(
                                          mainAxisAlignment:
                                              MainAxisAlignment.center,
                                          children: [
                                            _buildStepIndicator(
                                              0,
                                              'Scan',
                                              _ocrProgress >= 0.2,
                                            ),
                                            _buildStepConnector(
                                              _ocrProgress >= 0.4,
                                            ),
                                            _buildStepIndicator(
                                              1,
                                              'Extract',
                                              _ocrProgress >= 0.4,
                                            ),
                                            _buildStepConnector(
                                              _ocrProgress >= 0.7,
                                            ),
                                            _buildStepIndicator(
                                              2,
                                              'Fill',
                                              _ocrProgress >= 0.7,
                                            ),
                                          ],
                                        ),
                                      ],
                                    ),
                                  ),
                                ),
                              ),
                            ),
                        ],
                      ),
                      if (_ocrError != null) ...[
                        const SizedBox(height: 12),
                        Container(
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: Colors.orange.shade50,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(color: Colors.orange.shade200),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.warning,
                                color: Colors.orange.shade700,
                              ),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  'OCR Processing: $_ocrError. Please verify and correct the fields manually if needed.',
                                  style: TextStyle(
                                    fontSize: 12,
                                    color: Colors.orange.shade700,
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                      const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.green.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.green.shade200),
                        ),
                        child: Row(
                          children: [
                            Icon(
                              Icons.auto_fix_high,
                              color: Colors.green.shade700,
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                'Upload your trade license document and fields will be automatically filled using OCR technology.',
                                style: TextStyle(
                                  fontSize: 12,
                                  color: Colors.green.shade700,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  // Bank Details
                  _buildModernSection(
                    title: 'Bank Details',
                    icon: Icons.account_balance_outlined,
                    isOptional: true,
                    children: [
                      _buildModernTextField(
                        controller: accountNameController,
                        label: 'Account Holder Name',
                        icon: Icons.person_outline_rounded,
                        isRequired: false,
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: ibanController,
                        label: 'IBAN Number',
                        icon: Icons.account_balance_wallet_outlined,
                        isRequired: false,
                        validator: _validateIBAN,
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: bankNameController,
                        label: 'Bank Name',
                        icon: Icons.business_outlined,
                        isRequired: false,
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: branchNameController,
                        label: 'Branch Name',
                        icon: Icons.location_on_outlined,
                        isRequired: false,
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: branchAddressController,
                        label: 'Branch Address',
                        icon: Icons.location_city_outlined,
                        isRequired: false,
                      ),
                      const SizedBox(height: 16),
                      Stack(
                        children: [
                          FileUploadWidget(
                            label: 'Bank Statement or Certificate',
                            icon: Icons.account_balance,
                            allowedExtensions: ['pdf', 'jpg', 'jpeg', 'png'],
                            maxSizeInMB: 10.0,
                            currentFilePath: _bankStatementImage,
                            isRequired: false,
                            onFileSelected: (filePath) async {
                              setState(() {
                                _bankStatementImage = filePath;
                                _isProcessingBankOCR = true;
                                _bankOcrError = null;
                              });

                              if (filePath != null) {
                                await _processBankDetailsOCR(filePath);
                              }
                            },
                          ),
                          if (_isProcessingBankOCR)
                            Positioned.fill(
                              child: Container(
                                decoration: BoxDecoration(
                                  color: Colors.black.withOpacity(0.8),
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: Center(
                                  child: Container(
                                    padding: const EdgeInsets.all(24),
                                    decoration: BoxDecoration(
                                      color: Colors.white,
                                      borderRadius: BorderRadius.circular(16),
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.black.withOpacity(0.2),
                                          blurRadius: 20,
                                          offset: const Offset(0, 10),
                                        ),
                                      ],
                                    ),
                                    child: Column(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        // Bank AI Processing Icon
                                        Container(
                                          width: 60,
                                          height: 60,
                                          decoration: BoxDecoration(
                                            gradient: LinearGradient(
                                              colors: [Colors.green.shade400, Colors.teal.shade400],
                                              begin: Alignment.topLeft,
                                              end: Alignment.bottomRight,
                                            ),
                                            shape: BoxShape.circle,
                                          ),
                                          child: const Icon(
                                            Icons.account_balance,
                                            color: Colors.white,
                                            size: 30,
                                          ),
                                        ),
                                        const SizedBox(height: 16),

                                        // Title
                                        const Text(
                                          'AI Reading Bank Document',
                                          style: TextStyle(
                                            fontSize: 18,
                                            fontWeight: FontWeight.bold,
                                            color: Colors.black87,
                                          ),
                                        ),
                                        const SizedBox(height: 8),

                                        // Current Step
                                        Text(
                                          _bankOcrCurrentStep,
                                          style: TextStyle(
                                            fontSize: 14,
                                            color: Colors.grey.shade600,
                                          ),
                                          textAlign: TextAlign.center,
                                        ),
                                        const SizedBox(height: 20),

                                        // Progress Bar
                                        Container(
                                          width: 200,
                                          height: 8,
                                          decoration: BoxDecoration(
                                            color: Colors.grey.shade200,
                                            borderRadius: BorderRadius.circular(4),
                                          ),
                                          child: Stack(
                                            children: [
                                              AnimatedContainer(
                                                duration: const Duration(milliseconds: 300),
                                                width: 200 * _bankOcrProgress,
                                                height: 8,
                                                decoration: BoxDecoration(
                                                  gradient: LinearGradient(
                                                    colors: [Colors.green.shade400, Colors.teal.shade400],
                                                  ),
                                                  borderRadius: BorderRadius.circular(4),
                                                ),
                                              ),
                                            ],
                                          ),
                                        ),
                                        const SizedBox(height: 12),

                                        // Progress Percentage and Time
                                        Row(
                                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                          children: [
                                            Text(
                                              '${(_bankOcrProgress * 100).toInt()}%',
                                              style: TextStyle(
                                                fontSize: 14,
                                                fontWeight: FontWeight.w600,
                                                color: Colors.green.shade700,
                                              ),
                                            ),
                                            Text(
                                              _bankEstimatedTimeLeft > 0
                                                  ? '${_bankEstimatedTimeLeft}s remaining'
                                                  : 'Almost done...',
                                              style: TextStyle(
                                                fontSize: 12,
                                                color: Colors.grey.shade600,
                                              ),
                                            ),
                                          ],
                                        ),
                                        const SizedBox(height: 16),

                                        // Processing Steps Indicator
                                        Row(
                                          mainAxisAlignment: MainAxisAlignment.center,
                                          children: [
                                            _buildBankStepIndicator(0, 'Scan', _bankOcrProgress >= 0.2),
                                            _buildBankStepConnector(_bankOcrProgress >= 0.4),
                                            _buildBankStepIndicator(1, 'Extract', _bankOcrProgress >= 0.4),
                                            _buildBankStepConnector(_bankOcrProgress >= 0.7),
                                            _buildBankStepIndicator(2, 'Fill', _bankOcrProgress >= 0.7),
                                          ],
                                        ),
                                      ],
                                    ),
                                  ),
                                ),
                              ),
                            ),
                        ],
                      ),
                      // Bank OCR Error Display
                      if (_bankOcrError != null) ...[
                        const SizedBox(height: 16),
                        Container(
                          width: double.infinity,
                          padding: const EdgeInsets.all(16),
                          decoration: BoxDecoration(
                            color: Colors.red.shade50,
                            border: Border.all(color: Colors.red.shade200),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.error_outline,
                                color: Colors.red.shade600,
                                size: 24,
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      'Bank Document Processing Error',
                                      style: TextStyle(
                                        fontWeight: FontWeight.w600,
                                        color: Colors.red.shade800,
                                        fontSize: 14,
                                      ),
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      _bankOcrError!,
                                      style: TextStyle(
                                        color: Colors.red.shade700,
                                        fontSize: 13,
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                              IconButton(
                                onPressed: () {
                                  setState(() {
                                    _bankOcrError = null;
                                  });
                                },
                                icon: Icon(
                                  Icons.close,
                                  color: Colors.red.shade600,
                                  size: 20,
                                ),
                                tooltip: 'Dismiss error',
                              ),
                            ],
                          ),
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
            const SizedBox(width: 24),
            // Right Column
            Expanded(
              child: Column(
                children: [
                  // VAT Registration (conditionally shown)
                  if (_isVATRequired)
                    _buildModernSection(
                      title: 'VAT Registration Details',
                      icon: Icons.receipt_long,
                      isOptional: true,
                      children: [
                        _buildModernTextField(
                          controller: taxRegNumberController,
                          label: 'Tax Registration Number',
                          icon: Icons.numbers,
                          validator: _validateTaxRegNumber,
                        ),
                        const SizedBox(height: 16),
                        _buildModernTextField(
                          controller: firmNameController,
                          label: 'Firm Name',
                          icon: Icons.business,
                          validator: _validateFirmName,
                        ),
                        const SizedBox(height: 16),
                        _buildModernDateField(
                          controller: effectiveDateController,
                          label: 'Effective Registration Date',
                          icon: Icons.calendar_today,
                          context: context,
                        ),
                        const SizedBox(height: 16),
                        Stack(
                          children: [
                            FileUploadWidget(
                              label: 'VAT Registration Certificate',
                              icon: Icons.receipt_long,
                              allowedExtensions: ['pdf', 'jpg', 'jpeg', 'png'],
                              maxSizeInMB: 10.0,
                              currentFilePath: _vatCertificateImage,
                              isRequired: false,
                              onFileSelected: (filePath) async {
                                setState(() {
                                  _vatCertificateImage = filePath;
                                  _isProcessingVATOCR = true;
                                  _vatOcrError = null;
                                });

                                if (filePath != null) {
                                  await _processVATRegistrationOCR(filePath);
                                }
                              },
                            ),
                            if (_isProcessingVATOCR)
                              Positioned.fill(
                                child: Container(
                                  decoration: BoxDecoration(
                                    color: Colors.black.withOpacity(0.8),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: Center(
                                    child: Container(
                                      padding: const EdgeInsets.all(24),
                                      decoration: BoxDecoration(
                                        color: Colors.white,
                                        borderRadius: BorderRadius.circular(16),
                                        boxShadow: [
                                          BoxShadow(
                                            color: Colors.black.withOpacity(0.2),
                                            blurRadius: 20,
                                            offset: const Offset(0, 10),
                                          ),
                                        ],
                                      ),
                                      child: Column(
                                        mainAxisSize: MainAxisSize.min,
                                        children: [
                                          // VAT AI Processing Icon
                                          Container(
                                            width: 60,
                                            height: 60,
                                            decoration: BoxDecoration(
                                              gradient: LinearGradient(
                                                colors: [Colors.orange.shade400, Colors.red.shade400],
                                                begin: Alignment.topLeft,
                                                end: Alignment.bottomRight,
                                              ),
                                              shape: BoxShape.circle,
                                            ),
                                            child: const Icon(
                                              Icons.receipt_long,
                                              color: Colors.white,
                                              size: 30,
                                            ),
                                          ),
                                          const SizedBox(height: 16),

                                          // Title
                                          const Text(
                                            'AI Reading VAT Certificate',
                                            style: TextStyle(
                                              fontSize: 18,
                                              fontWeight: FontWeight.bold,
                                              color: Colors.black87,
                                            ),
                                          ),
                                          const SizedBox(height: 8),

                                          // Current Step
                                          Text(
                                            _vatOcrCurrentStep,
                                            style: TextStyle(
                                              fontSize: 14,
                                              color: Colors.grey.shade600,
                                            ),
                                            textAlign: TextAlign.center,
                                          ),
                                          const SizedBox(height: 20),

                                          // Progress Bar
                                          Container(
                                            width: 200,
                                            height: 8,
                                            decoration: BoxDecoration(
                                              color: Colors.grey.shade200,
                                              borderRadius: BorderRadius.circular(4),
                                            ),
                                            child: Stack(
                                              children: [
                                                AnimatedContainer(
                                                  duration: const Duration(milliseconds: 300),
                                                  width: 200 * _vatOcrProgress,
                                                  height: 8,
                                                  decoration: BoxDecoration(
                                                    gradient: LinearGradient(
                                                      colors: [Colors.orange.shade400, Colors.red.shade400],
                                                    ),
                                                    borderRadius: BorderRadius.circular(4),
                                                  ),
                                                ),
                                              ],
                                            ),
                                          ),
                                          const SizedBox(height: 12),

                                          // Progress Percentage and Time
                                          Row(
                                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                            children: [
                                              Text(
                                                '${(_vatOcrProgress * 100).toInt()}%',
                                                style: TextStyle(
                                                  fontSize: 14,
                                                  fontWeight: FontWeight.w600,
                                                  color: Colors.orange.shade700,
                                                ),
                                              ),
                                              Text(
                                                _vatEstimatedTimeLeft > 0
                                                    ? '${_vatEstimatedTimeLeft}s remaining'
                                                    : 'Almost done...',
                                                style: TextStyle(
                                                  fontSize: 12,
                                                  color: Colors.grey.shade600,
                                                ),
                                              ),
                                            ],
                                          ),
                                          const SizedBox(height: 16),

                                          // Processing Steps Indicator
                                          Row(
                                            mainAxisAlignment: MainAxisAlignment.center,
                                            children: [
                                              _buildVATStepIndicator(0, 'Scan', _vatOcrProgress >= 0.2),
                                              _buildVATStepConnector(_vatOcrProgress >= 0.4),
                                              _buildVATStepIndicator(1, 'Extract', _vatOcrProgress >= 0.4),
                                              _buildVATStepConnector(_vatOcrProgress >= 0.7),
                                              _buildVATStepIndicator(2, 'Fill', _vatOcrProgress >= 0.7),
                                            ],
                                          ),
                                        ],
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                          ],
                        ),
                        if (_vatOcrError != null) ...[
                          const SizedBox(height: 12),
                          Container(
                            padding: const EdgeInsets.all(12),
                            decoration: BoxDecoration(
                              color: Colors.red.shade50,
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(color: Colors.red.shade200),
                            ),
                            child: Row(
                              children: [
                                Icon(
                                  Icons.warning,
                                  color: Colors.red.shade700,
                                ),
                                const SizedBox(width: 8),
                                Expanded(
                                  child: Text(
                                    'VAT OCR Processing: $_vatOcrError. Please verify and correct the fields manually if needed.',
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: Colors.red.shade700,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                        const SizedBox(height: 16),
                        Container(
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: Colors.orange.shade50,
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(color: Colors.orange.shade200),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.info_outline,
                                color: Colors.orange.shade700,
                              ),
                              const SizedBox(width: 8),
                              const Expanded(
                                child: Text(
                                  'Required only if the firm\'s Annual Turnover exceeds AED 375,000.',
                                  style: TextStyle(fontSize: 12),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  if (_isVATRequired) const SizedBox(height: 24),
                  // Location Details
                  _buildModernSection(
                    title: 'Location Details',
                    icon: Icons.location_on_outlined,
                    isOptional: true,
                    children: [
                      _buildModernTextField(
                        controller: latitudeController,
                        label: 'Latitude',
                        icon: Icons.my_location,
                        isRequired: false,
                        validator: _validateLatitude,
                        suffix: IconButton(
                          tooltip: 'Refresh location',
                          icon: const Icon(Icons.gps_fixed),
                          onPressed: _isGettingLocation
                              ? null
                              : () async {
                                  HapticFeedback.selectionClick();
                                  await _initLocation();
                                },
                        ),
                      ),
                      const SizedBox(height: 16),
                      _buildModernTextField(
                        controller: longitudeController,
                        label: 'Longitude',
                        icon: Icons.my_location,
                        isRequired: false,
                        validator: _validateLongitude,
                        suffix: IconButton(
                          tooltip: 'Refresh location',
                          icon: const Icon(Icons.gps_fixed),
                          onPressed: _isGettingLocation
                              ? null
                              : () async {
                                  HapticFeedback.selectionClick();
                                  await _initLocation();
                                },
                        ),
                      ),
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          const Icon(
                            Icons.info_outline,
                            size: 16,
                            color: Colors.grey,
                          ),
                          const SizedBox(width: 6),
                          Expanded(
                            child: Text(
                              _isGettingLocation
                                  ? 'Fetching GPS'
                                  : (latitudeController.text.isEmpty ||
                                        longitudeController.text.isEmpty)
                                  ? 'Tap the GPS icon if fields are empty.'
                                  : 'Coordinates captured from your device GPS.',
                              style: TextStyle(
                                fontSize: 12,
                                color: Colors.grey.shade700,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),
                  // Shop Image Section
                  _buildModernSection(
                    title: 'Shop Image',
                    icon: Icons.storefront,
                    isOptional: true,
                    children: [
                      FileUploadWidget(
                        label: 'Shop Front Image',
                        icon: Icons.camera_alt,
                        allowedExtensions: ['jpg', 'jpeg', 'png'],
                        maxSizeInMB: 15.0,
                        currentFilePath: _shopImage,
                        isRequired: false,
                        onFileSelected: (filePath) {
                          setState(() {
                            _shopImage = filePath;
                          });
                        },
                      ),
                      const SizedBox(height: 16),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.green.shade50,
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(color: Colors.green.shade200),
                        ),
                        child: Row(
                          children: [
                            Icon(
                              Icons.info_outline,
                              color: Colors.green.shade700,
                            ),
                            const SizedBox(width: 8),
                            const Expanded(
                              child: Text(
                                'Upload a clear image of your shop front for verification purposes.',
                                style: TextStyle(fontSize: 12),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildMobileLayout() {
    return Column(
      children: [
        // Trade License
        _buildModernSection(
          title: 'Trade License Details',
          icon: Icons.assignment_rounded,
          children: [
            _buildModernTextField(
              controller: licenseNumberController,
              label: 'License Number',
              icon: Icons.confirmation_number,
              validator: _validateLicense,
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: issuingAuthorityController,
              label: 'Issuing Authority',
              icon: Icons.account_balance,
            ),
            const SizedBox(height: 16),
            _buildModernDateField(
              controller: establishmentDateController,
              label: 'Establishment Date',
              icon: Icons.event,
              context: context,
            ),
            const SizedBox(height: 16),
            _buildModernDateField(
              controller: expiryDateController,
              label: 'Expiry Date',
              icon: Icons.event_busy,
              context: context,
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: tradeNameController,
              label: 'Trade Name',
              icon: Icons.store,
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: responsiblePersonController,
              label: 'Responsible Person',
              icon: Icons.person,
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: registeredAddressController,
              label: 'Registered Address',
              icon: Icons.location_on,
            ),
            const SizedBox(height: 16),
            _buildModernDateField(
              controller: effectiveDateController,
              label: 'Effective Registration Date',
              icon: Icons.calendar_today,
              context: context,
            ),
            const SizedBox(height: 16),
            Stack(
              children: [
                FileUploadWidget(
                  label: 'Trade License Document',
                  icon: Icons.assignment,
                  allowedExtensions: ['pdf', 'jpg', 'jpeg', 'png'],
                  maxSizeInMB: 10.0,
                  currentFilePath: _licenseImage,
                  onFileSelected: (filePath) async {
                    setState(() {
                      _licenseImage = filePath;
                      _isProcessingOCR = true;
                      _ocrError = null;
                    });

                    if (filePath != null) {
                      await _processTradeLicenseOCR(filePath);
                    }
                  },
                ),
                if (_isProcessingOCR)
                  Positioned.fill(
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.8),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Center(
                        child: Container(
                          padding: const EdgeInsets.all(24),
                          decoration: BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.circular(16),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.2),
                                blurRadius: 20,
                                offset: const Offset(0, 10),
                              ),
                            ],
                          ),
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              // AI Processing Icon
                              Container(
                                width: 60,
                                height: 60,
                                decoration: BoxDecoration(
                                  gradient: LinearGradient(
                                    colors: [
                                      Colors.blue.shade400,
                                      Colors.purple.shade400,
                                    ],
                                    begin: Alignment.topLeft,
                                    end: Alignment.bottomRight,
                                  ),
                                  shape: BoxShape.circle,
                                ),
                                child: const Icon(
                                  Icons.auto_awesome,
                                  color: Colors.white,
                                  size: 30,
                                ),
                              ),
                              const SizedBox(height: 16),

                              // Title
                              const Text(
                                'AI Reading Document',
                                style: TextStyle(
                                  fontSize: 18,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.black87,
                                ),
                              ),
                              const SizedBox(height: 8),

                              // Current Step
                              Text(
                                _ocrCurrentStep,
                                style: TextStyle(
                                  fontSize: 14,
                                  color: Colors.grey.shade600,
                                ),
                                textAlign: TextAlign.center,
                              ),
                              const SizedBox(height: 20),

                              // Progress Bar
                              Container(
                                width: 200,
                                height: 8,
                                decoration: BoxDecoration(
                                  color: Colors.grey.shade200,
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Stack(
                                  children: [
                                    AnimatedContainer(
                                      duration: const Duration(
                                        milliseconds: 300,
                                      ),
                                      width: 200 * _ocrProgress,
                                      height: 8,
                                      decoration: BoxDecoration(
                                        gradient: LinearGradient(
                                          colors: [
                                            Colors.blue.shade400,
                                            Colors.purple.shade400,
                                          ],
                                        ),
                                        borderRadius: BorderRadius.circular(4),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                              const SizedBox(height: 12),

                              // Progress Percentage and Time
                              Row(
                                mainAxisAlignment:
                                    MainAxisAlignment.spaceBetween,
                                children: [
                                  Text(
                                    '${(_ocrProgress * 100).toInt()}%',
                                    style: TextStyle(
                                      fontSize: 14,
                                      fontWeight: FontWeight.w600,
                                      color: Colors.blue.shade700,
                                    ),
                                  ),
                                  Text(
                                    _estimatedTimeLeft > 0
                                        ? '${_estimatedTimeLeft}s remaining'
                                        : 'Almost done...',
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: Colors.grey.shade600,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 16),

                              // Processing Steps Indicator
                              Row(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  _buildStepIndicator(
                                    0,
                                    'Scan',
                                    _ocrProgress >= 0.2,
                                  ),
                                  _buildStepConnector(_ocrProgress >= 0.4),
                                  _buildStepIndicator(
                                    1,
                                    'Extract',
                                    _ocrProgress >= 0.4,
                                  ),
                                  _buildStepConnector(_ocrProgress >= 0.7),
                                  _buildStepIndicator(
                                    2,
                                    'Fill',
                                    _ocrProgress >= 0.7,
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
            if (_ocrError != null) ...[
              const SizedBox(height: 12),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.orange.shade50,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.orange.shade200),
                ),
                child: Row(
                  children: [
                    Icon(Icons.warning, color: Colors.orange.shade700),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        'OCR Processing: $_ocrError. Please verify and correct the fields manually if needed.',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.orange.shade700,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            const SizedBox(height: 16),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.green.shade50,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.green.shade200),
              ),
              child: Row(
                children: [
                  Icon(Icons.auto_fix_high, color: Colors.green.shade700),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Upload your trade license document and fields will be automatically filled using OCR technology.',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.green.shade700,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        const SizedBox(height: 24),
        // VAT Registration (conditionally shown)
        if (_isVATRequired)
          _buildModernSection(
            title: 'VAT Registration Details',
            icon: Icons.receipt_long,
            isOptional: true,
            children: [
              _buildModernTextField(
                controller: taxRegNumberController,
                label: 'Tax Registration Number',
                icon: Icons.numbers,
                validator: _validateTaxRegNumber,
              ),
              const SizedBox(height: 16),
              _buildModernTextField(
                controller: firmNameController,
                label: 'Firm Name',
                icon: Icons.business,
              ),
              const SizedBox(height: 16),
              _buildModernDateField(
                controller: effectiveDateController,
                label: 'Effective Registration Date',
                icon: Icons.calendar_today,
                context: context,
              ),
              const SizedBox(height: 16),
              Stack(
                children: [
                  FileUploadWidget(
                    label: 'VAT Registration Certificate',
                    icon: Icons.receipt_long,
                    allowedExtensions: ['pdf', 'jpg', 'jpeg', 'png'],
                    maxSizeInMB: 10.0,
                    currentFilePath: _vatCertificateImage,
                    isRequired: false,
                    onFileSelected: (filePath) async {
                      setState(() {
                        _vatCertificateImage = filePath;
                        _isProcessingVATOCR = true;
                        _vatOcrError = null;
                      });

                      if (filePath != null) {
                        await _processVATRegistrationOCR(filePath);
                      }
                    },
                  ),
                  if (_isProcessingVATOCR)
                    Positioned.fill(
                      child: Container(
                        decoration: BoxDecoration(
                          color: Colors.black.withOpacity(0.8),
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Center(
                          child: Container(
                            padding: const EdgeInsets.all(24),
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(16),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.2),
                                  blurRadius: 20,
                                  offset: const Offset(0, 10),
                                ),
                              ],
                            ),
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                // VAT AI Processing Icon
                                Container(
                                  width: 60,
                                  height: 60,
                                  decoration: BoxDecoration(
                                    gradient: LinearGradient(
                                      colors: [Colors.orange.shade400, Colors.red.shade400],
                                      begin: Alignment.topLeft,
                                      end: Alignment.bottomRight,
                                    ),
                                    shape: BoxShape.circle,
                                  ),
                                  child: const Icon(
                                    Icons.receipt_long,
                                    color: Colors.white,
                                    size: 30,
                                  ),
                                ),
                                const SizedBox(height: 16),

                                // Title
                                const Text(
                                  'AI Reading VAT Certificate',
                                  style: TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.bold,
                                    color: Colors.black87,
                                  ),
                                ),
                                const SizedBox(height: 8),

                                // Current Step
                                Text(
                                  _vatOcrCurrentStep,
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Colors.grey.shade600,
                                  ),
                                  textAlign: TextAlign.center,
                                ),
                                const SizedBox(height: 20),

                                // Progress Bar
                                Container(
                                  width: 200,
                                  height: 8,
                                  decoration: BoxDecoration(
                                    color: Colors.grey.shade200,
                                    borderRadius: BorderRadius.circular(4),
                                  ),
                                  child: Stack(
                                    children: [
                                      AnimatedContainer(
                                        duration: const Duration(milliseconds: 300),
                                        width: 200 * _vatOcrProgress,
                                        height: 8,
                                        decoration: BoxDecoration(
                                          gradient: LinearGradient(
                                            colors: [Colors.orange.shade400, Colors.red.shade400],
                                          ),
                                          borderRadius: BorderRadius.circular(4),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                                const SizedBox(height: 12),

                                // Progress Percentage and Time
                                Row(
                                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                  children: [
                                    Text(
                                      '${(_vatOcrProgress * 100).toInt()}%',
                                      style: TextStyle(
                                        fontSize: 14,
                                        fontWeight: FontWeight.w600,
                                        color: Colors.orange.shade700,
                                      ),
                                    ),
                                    Text(
                                      _vatEstimatedTimeLeft > 0
                                          ? '${_vatEstimatedTimeLeft}s remaining'
                                          : 'Almost done...',
                                      style: TextStyle(
                                        fontSize: 12,
                                        color: Colors.grey.shade600,
                                      ),
                                    ),
                                  ],
                                ),
                                const SizedBox(height: 16),

                                // Processing Steps Indicator
                                Row(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    _buildVATStepIndicator(0, 'Scan', _vatOcrProgress >= 0.2),
                                    _buildVATStepConnector(_vatOcrProgress >= 0.4),
                                    _buildVATStepIndicator(1, 'Extract', _vatOcrProgress >= 0.4),
                                    _buildVATStepConnector(_vatOcrProgress >= 0.7),
                                    _buildVATStepIndicator(2, 'Fill', _vatOcrProgress >= 0.7),
                                  ],
                                ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    ),
                ],
              ),
              if (_vatOcrError != null) ...[
                const SizedBox(height: 12),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.red.shade50,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.red.shade200),
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.warning,
                        color: Colors.red.shade700,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          'VAT OCR Processing: $_vatOcrError. Please verify and correct the fields manually if needed.',
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.red.shade700,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.orange.shade50,
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.orange.shade200),
                ),
                child: Row(
                  children: [
                    Icon(Icons.info_outline, color: Colors.orange.shade700),
                    const SizedBox(width: 8),
                    const Expanded(
                      child: Text(
                        'Required only if the firm\'s Annual Turnover exceeds AED 375,000.',
                        style: TextStyle(fontSize: 12),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        const SizedBox(height: 24),
        // Bank Details
        _buildModernSection(
          title: 'Bank Details',
          icon: Icons.account_balance_outlined,
          isOptional: true,
          children: [
            _buildModernTextField(
              controller: accountNameController,
              label: 'Account Holder Name',
              icon: Icons.person_outline_rounded,
              isRequired: false,
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: ibanController,
              label: 'IBAN Number',
              icon: Icons.account_balance_wallet_outlined,
              isRequired: false,
              validator: _validateIBAN,
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: bankNameController,
              label: 'Bank Name',
              icon: Icons.business_outlined,
              isRequired: false,
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: branchNameController,
              label: 'Branch Name',
              icon: Icons.location_on_outlined,
              isRequired: false,
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: branchAddressController,
              label: 'Branch Address',
              icon: Icons.location_city_outlined,
              isRequired: false,
            ),
            const SizedBox(height: 16),
            Stack(
              children: [
                FileUploadWidget(
                  label: 'Bank Statement or Certificate',
                  icon: Icons.account_balance,
                  allowedExtensions: ['pdf', 'jpg', 'jpeg', 'png'],
                  maxSizeInMB: 10.0,
                  currentFilePath: _bankStatementImage,
                  isRequired: false,
                  onFileSelected: (filePath) async {
                    setState(() {
                      _bankStatementImage = filePath;
                      _isProcessingBankOCR = true;
                      _bankOcrError = null;
                    });

                    if (filePath != null) {
                      await _processBankDetailsOCR(filePath);
                    }
                  },
                ),
                if (_isProcessingBankOCR)
                  Positioned.fill(
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.8),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Center(
                        child: Container(
                          padding: const EdgeInsets.all(24),
                          decoration: BoxDecoration(
                            color: Colors.white,
                            borderRadius: BorderRadius.circular(16),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.2),
                                blurRadius: 20,
                                offset: const Offset(0, 10),
                              ),
                            ],
                          ),
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              // Bank AI Processing Icon
                              Container(
                                width: 60,
                                height: 60,
                                decoration: BoxDecoration(
                                  gradient: LinearGradient(
                                    colors: [Colors.green.shade400, Colors.teal.shade400],
                                    begin: Alignment.topLeft,
                                    end: Alignment.bottomRight,
                                  ),
                                  shape: BoxShape.circle,
                                ),
                                child: const Icon(
                                  Icons.account_balance,
                                  color: Colors.white,
                                  size: 30,
                                ),
                              ),
                              const SizedBox(height: 16),

                              // Title
                              const Text(
                                'AI Reading Bank Document',
                                style: TextStyle(
                                  fontSize: 18,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.black87,
                                ),
                              ),
                              const SizedBox(height: 8),

                              // Current Step
                              Text(
                                _bankOcrCurrentStep,
                                style: TextStyle(
                                  fontSize: 14,
                                  color: Colors.grey.shade600,
                                ),
                                textAlign: TextAlign.center,
                              ),
                              const SizedBox(height: 20),

                              // Progress Bar
                              Container(
                                width: 200,
                                height: 8,
                                decoration: BoxDecoration(
                                  color: Colors.grey.shade200,
                                  borderRadius: BorderRadius.circular(4),
                                ),
                                child: Stack(
                                  children: [
                                    AnimatedContainer(
                                      duration: const Duration(milliseconds: 300),
                                      width: 200 * _bankOcrProgress,
                                      height: 8,
                                      decoration: BoxDecoration(
                                        gradient: LinearGradient(
                                          colors: [Colors.green.shade400, Colors.teal.shade400],
                                        ),
                                        borderRadius: BorderRadius.circular(4),
                                      ),
                                    ),
                                  ],
                                ),
                              ),
                              const SizedBox(height: 12),

                              // Progress Percentage and Time
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  Text(
                                    '${(_bankOcrProgress * 100).toInt()}%',
                                    style: TextStyle(
                                      fontSize: 14,
                                      fontWeight: FontWeight.w600,
                                      color: Colors.green.shade700,
                                    ),
                                  ),
                                  Text(
                                    _bankEstimatedTimeLeft > 0
                                        ? '${_bankEstimatedTimeLeft}s remaining'
                                        : 'Almost done...',
                                    style: TextStyle(
                                      fontSize: 12,
                                      color: Colors.grey.shade600,
                                    ),
                                  ),
                                ],
                              ),
                              const SizedBox(height: 16),

                              // Processing Steps Indicator
                              Row(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  _buildBankStepIndicator(0, 'Scan', _bankOcrProgress >= 0.2),
                                  _buildBankStepConnector(_bankOcrProgress >= 0.4),
                                  _buildBankStepIndicator(1, 'Extract', _bankOcrProgress >= 0.4),
                                  _buildBankStepConnector(_bankOcrProgress >= 0.7),
                                  _buildBankStepIndicator(2, 'Fill', _bankOcrProgress >= 0.7),
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
            // Bank OCR Error Display
            if (_bankOcrError != null) ...[
              const SizedBox(height: 16),
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.red.shade50,
                  border: Border.all(color: Colors.red.shade200),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.error_outline,
                      color: Colors.red.shade600,
                      size: 24,
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Bank Document Processing Error',
                            style: TextStyle(
                              fontWeight: FontWeight.w600,
                              color: Colors.red.shade800,
                              fontSize: 14,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            _bankOcrError!,
                            style: TextStyle(
                              color: Colors.red.shade700,
                              fontSize: 13,
                            ),
                          ),
                        ],
                      ),
                    ),
                    IconButton(
                      onPressed: () {
                        setState(() {
                          _bankOcrError = null;
                        });
                      },
                      icon: Icon(
                        Icons.close,
                        color: Colors.red.shade600,
                        size: 20,
                      ),
                      tooltip: 'Dismiss error',
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
        const SizedBox(height: 24),
        // Location Details
        _buildModernSection(
          title: 'Location Details',
          icon: Icons.location_on_outlined,
          isOptional: true,
          children: [
            _buildModernTextField(
              controller: latitudeController,
              label: 'Latitude',
              icon: Icons.my_location,
              isRequired: false,
              suffix: IconButton(
                tooltip: 'Refresh location',
                icon: const Icon(Icons.gps_fixed),
                onPressed: _isGettingLocation
                    ? null
                    : () async {
                        HapticFeedback.selectionClick();
                        await _initLocation();
                      },
              ),
            ),
            const SizedBox(height: 16),
            _buildModernTextField(
              controller: longitudeController,
              label: 'Longitude',
              icon: Icons.my_location,
              isRequired: false,
              suffix: IconButton(
                tooltip: 'Refresh location',
                icon: const Icon(Icons.gps_fixed),
                onPressed: _isGettingLocation
                    ? null
                    : () async {
                        HapticFeedback.selectionClick();
                        await _initLocation();
                      },
              ),
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                const Icon(Icons.info_outline, size: 16, color: Colors.grey),
                const SizedBox(width: 6),
                Expanded(
                  child: Text(
                    _isGettingLocation
                        ? 'Fetching GPS'
                        : (latitudeController.text.isEmpty ||
                              longitudeController.text.isEmpty)
                        ? 'Tap the GPS icon if fields are empty.'
                        : 'Coordinates captured from your device GPS.',
                    style: TextStyle(fontSize: 12, color: Colors.grey.shade700),
                  ),
                ),
              ],
            ),
          ],
        ),
        const SizedBox(height: 24),
        // Shop Image Section
        _buildModernSection(
          title: 'Shop Image',
          icon: Icons.storefront,
          isOptional: true,
          children: [
            FileUploadWidget(
              label: 'Shop Front Image',
              icon: Icons.camera_alt,
              allowedExtensions: ['jpg', 'jpeg', 'png'],
              maxSizeInMB: 15.0,
              currentFilePath: _shopImage,
              isRequired: false,
              onFileSelected: (filePath) {
                setState(() {
                  _shopImage = filePath;
                });
              },
            ),
            const SizedBox(height: 16),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.green.shade50,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.green.shade200),
              ),
              child: Row(
                children: [
                  Icon(Icons.info_outline, color: Colors.green.shade700),
                  const SizedBox(width: 8),
                  const Expanded(
                    child: Text(
                      'Upload a clear image of your shop front for verification purposes.',
                      style: TextStyle(fontSize: 12),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }
}

class _FadeSlide extends StatelessWidget {
  final String text;
  final bool big;
  const _FadeSlide({required this.text, this.big = false});

  @override
  Widget build(BuildContext context) {
    return TweenAnimationBuilder<double>(
      tween: Tween<double>(begin: 0, end: 1),
      duration: const Duration(milliseconds: 800),
      curve: Curves.easeOut,
      builder: (context, value, child) => Transform.translate(
        offset: Offset(0, 30 * (1 - value)),
        child: Opacity(opacity: value, child: child),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: big ? 32 : 16,
          fontWeight: big ? FontWeight.bold : FontWeight.normal,
          color: big ? Colors.white : Colors.white70,
        ),
      ),
    );
  }
}


