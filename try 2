import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter/foundation.dart';
import 'dart:async';
import 'dart:js' as js;
import '../core/services/auth_service.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with TickerProviderStateMixin {
  late AnimationController _fadeController;
  late AnimationController _scaleController;
  late AnimationController _slideController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;
  late Animation<Offset> _slideAnimation;
  late AnimationController _particleController;
  late Animation<double> _particleAnimation;

  @override
  void initState() {
    super.initState();

    // Initialize animation controllers
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );

    _slideController = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );

    _particleController = AnimationController(
      duration: const Duration(milliseconds: 3000),
      vsync: this,
    );

    // Define animations
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut),
    );

    _scaleAnimation = Tween<double>(begin: 0.5, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut),
    );

    _slideAnimation =
        Tween<Offset>(begin: const Offset(0, 0.5), end: Offset.zero).animate(
          CurvedAnimation(parent: _slideController, curve: Curves.easeOutCubic),
        );

    _particleAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _particleController, curve: Curves.easeInOut),
    );

    // Start animations
    _fadeController.forward();
    _scaleController.forward();
    _slideController.forward();
    _particleController.repeat();

    // Initialize Firebase Auth state listener for routing
    _initializeFirebaseAuthRouting();
  }

  void _initializeFirebaseAuthRouting() {
    if (kIsWeb) {
      // First, try to restore user session from localStorage
      Timer(const Duration(milliseconds: 1000), () async {
        if (!mounted) return;

        try {
          print('üîÑ Attempting to restore user session...');
          final sessionRestored = await AuthManager.restoreUserSession();
          if (sessionRestored) {
            print('‚úÖ Session restored from localStorage');

            // Session restored successfully, check if we should navigate to home immediately
            await Future.delayed(const Duration(milliseconds: 500));
            if (mounted && AuthManager.isLoggedIn) {
              print('‚úÖ Session restored and user logged in, navigating to home');
              _navigateToHome();
              return;
            }
          } else {
            print('‚ùå No session to restore');
          }

          // Then check Firebase state
          _checkFirebaseAuthState();
        } catch (e) {
          print('‚ùå Session restoration failed: $e');
          _checkFirebaseAuthState();
        }
      });
    } else {
      // Non-web platforms - check Flutter auth state
      Timer(const Duration(milliseconds: 1500), () {
        if (mounted) {
          if (AuthManager.isLoggedIn) {
            _navigateToHome();
          } else {
            _navigateToLogin();
          }
        }
      });
    }
  }

  void _checkFirebaseAuthState() {
    // Check both Firebase and Flutter auth state
    Timer.periodic(const Duration(milliseconds: 500), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }

      try {
        // Check if Firebase is initialized
        final firebaseReady = js.context['FirebaseAuthManager'] != null;

        if (firebaseReady) {
          timer.cancel();

          // Check Firebase auth state
          final currentUser = js.context.callMethod('eval', ['''
            window.FirebaseAuthManager.getCurrentUser()
          ''']);

          // If Firebase has a user, check Flutter auth state
          if (currentUser != null) {
            print('üî• Firebase user found, checking Flutter auth state');
            print('üì± Flutter isLoggedIn: ${AuthManager.isLoggedIn}');

            // Check if Flutter also has user data
            if (AuthManager.isLoggedIn) {
              print('‚úÖ Both Firebase and Flutter have user, navigating to home');
              _navigateToHome();
            } else {
              print('‚ùå Firebase user but no Flutter user data, navigating to login');
              _navigateToLogin();
            }
          } else {
            print('‚ùå No Firebase user, checking Flutter auth state');
            print('üì± Flutter isLoggedIn: ${AuthManager.isLoggedIn}');

            // No Firebase user, but check if Flutter has cached user data
            if (AuthManager.isLoggedIn) {
              print('üì± Flutter has cached user data, navigating to home');
              _navigateToHome();
            } else {
              print('‚ùå No user data, navigating to login');
              _navigateToLogin();
            }
          }
        } else if (timer.tick > 8) { // 4 seconds timeout
          timer.cancel();
          print('Firebase timeout, checking Flutter auth state');

          // Fallback to Flutter auth state
          if (AuthManager.isLoggedIn) {
            _navigateToHome();
          } else {
            _navigateToLogin();
          }
        }
      } catch (e) {
        timer.cancel();
        print('Firebase Auth routing error: \$e');

        // Fallback to Flutter auth state
        if (AuthManager.isLoggedIn) {
          _navigateToHome();
        } else {
          _navigateToLogin();
        }
      }
    });
  }

  void _navigateToLogin() {
    if (mounted) {
      context.go('/login-password');
    }
  }

  void _navigateToHome() {
    if (mounted) {
      context.go('/home');
    }
  }

  @override
  void dispose() {
    _fadeController.dispose();
    _scaleController.dispose();
    _slideController.dispose();
    _particleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: Stack(
        children: [
          // Background gradient
          Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [
                  const Color(0xFFFFFFFF),
                  const Color(0xFFF5F7FA),
                  const Color(0xFFE9ECEF),
                ],
              ),
            ),
          ),

          // Animated particles background
          AnimatedBuilder(
            animation: _particleAnimation,
            builder: (context, child) {
              return CustomPaint(
                painter: ParticlePainter(_particleAnimation.value),
                size: Size.infinite,
              );
            },
          ),

          // Main content
          Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Logo/Icon container
                // Logo/Icon container
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: ScaleTransition(
                    scale: _scaleAnimation,
                    child: Container(
                      width: 140,
                      height: 140,
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                          colors: [
                            const Color(0xFF2C5282),
                            const Color(0xFF2B6CB0),
                            const Color(0xFF3182CE),
                          ],
                        ),
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.3),
                            blurRadius: 20,
                            offset: const Offset(0, 10),
                          ),
                          BoxShadow(
                            color: const Color(0xFF3182CE).withOpacity(0.4),
                            blurRadius: 25,
                            offset: const Offset(0, 5),
                          ),
                        ],
                      ),
                      padding: const EdgeInsets.all(8),
                      child: Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.1),
                              blurRadius: 8,
                              offset: const Offset(0, 3),
                            ),
                          ],
                        ),
                        child: ClipOval(
                          child: Image.asset(
                            "assets/images/rak_logo.jpg",
                            fit: BoxFit.cover,
                            errorBuilder: (context, error, stackTrace) {
                              return const Icon(
                                Icons.business,
                                color: Color(0xFF2C5282),
                                size: 60,
                              );
                            },
                          ),
                        ),
                      ),
                    ),
                  ),
                ),

                const SizedBox(height: 40),

                // Company name
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: SlideTransition(
                    position: _slideAnimation,
                    child: Column(
                      children: [
                        Text(
                          'RAK',
                          style: TextStyle(
                            fontSize: 48,
                            fontWeight: FontWeight.bold,
                            color: const Color(0xFF2C5282),
                            letterSpacing: 3,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'WHITE CEMENT',
                          style: TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.w600,
                            color: const Color(0xFF4A5568),
                            letterSpacing: 2,
                          ),
                        ),
                        const SizedBox(height: 16),
                        Container(
                          width: 60,
                          height: 3,
                          decoration: BoxDecoration(
                            gradient: LinearGradient(
                              colors: [
                                const Color(0xFF3182CE),
                                const Color(0xFF2B6CB0),
                              ],
                            ),
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Construction Materials',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w400,
                            color: const Color(0xFF718096),
                            letterSpacing: 1,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 60),

                // Loading indicator
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: Column(
                    children: [
                      SizedBox(
                        width: 40,
                        height: 40,
                        child: CircularProgressIndicator(
                          strokeWidth: 3,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            const Color(0xFF3182CE),
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'Loading...',
                        style: TextStyle(
                          fontSize: 14,
                          color: const Color(0xFF718096),
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),

          // Bottom footer
          Positioned(
            bottom: 30,
            left: 0,
            right: 0,
            child: FadeTransition(
              opacity: _fadeAnimation,
              child: Column(
                children: [
                  Text(
                    'Est. 1980',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Ras Al Khaimah, United Arab Emirates',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w400,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ParticlePainter extends CustomPainter {
  final double animationValue;

  ParticlePainter(this.animationValue);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = Colors.blue.withOpacity(0.1);

    // Create floating particles
    for (int i = 0; i < 20; i++) {
      final x = (size.width / 20) * i + (animationValue * 50) % size.width;
      final y =
          size.height * 0.5 +
          (animationValue * 100 + i * 30) % size.height -
          size.height * 0.25;

      canvas.drawCircle(Offset(x, y), 2 + (animationValue * 2) % 3, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}





































import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'dart:js' as js;
import '../models/auth_models.dart';
import '../utils/app_logger.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client.send(request).timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      // Extract cookies from response headers for future requests
      final cookieHeader = response.headers['set-cookie'];
      if (cookieHeader != null) {
        _logger.debug('Received cookies: $cookieHeader');
      }

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    try {
      // First authenticate with backend to get user data
      final result = await authenticateUser(userID: userId, password: password);
      if (result['success'] == true) {
        final loginResponse = result['data'] as LoginResponse;

        // Create user data
        final userDataWithId = UserData(
          emplName: loginResponse.data.emplName,
          areaCode: loginResponse.data.areaCode,
          roles: loginResponse.data.roles,
          pages: loginResponse.data.pages,
          userID: userId,
        );

        // Set user in AuthManager first
        AuthManager.setUser(userDataWithId);

        // Then sign in to Firebase for web session management
        if (kIsWeb) {
          final firebaseResult = await _firebaseSignIn(userId, password);
          if (firebaseResult['success'] != true) {
            _logger.warning('Firebase authentication failed but backend succeeded');
            // Continue anyway - Firebase is for session management only
          }
        }

        return true;
      }
      return false;
    } catch (e) {
      _logger.error('Login error', e);
      return false;
    }
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    // Firebase sign out first
    if (kIsWeb) {
      await _firebaseSignOut();
    }

    // Try to logout from server
    final serverLogout = await logoutFromServer();
    if (!serverLogout['success']) {
      _logger.warning('Server logout failed, clearing local session anyway');
    }

    AuthManager.clearUser();
    await Future.delayed(const Duration(milliseconds: 500));
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }

  // Session validation endpoint
  static Future<Map<String, dynamic>> validateSession() async {
    try {
      _logger.info('Validating user session');

      final uri = Uri.parse('$baseUrl/auth/me');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .get(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Session validation response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Session validation failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Session validation error', e);
      return {
        'success': false,
        'error': 'Network error during session validation',
        'statusCode': 0,
      };
    }
  }

  // Token refresh endpoint
  static Future<Map<String, dynamic>> refreshToken() async {
    try {
      _logger.info('Refreshing access token');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  // Enhanced logout with server-side session clearing
  static Future<Map<String, dynamic>> logoutFromServer() async {
    try {
      _logger.info('Logging out from server');

      final uri = Uri.parse('$baseUrl/auth/logout');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Server logout response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Server logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout',
        'statusCode': 0,
      };
    }
  }

  // Firebase Authentication Helper Methods
  static Future<Map<String, dynamic>> _firebaseSignIn(String email, String password) async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Attempting Firebase sign in for: $email');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            return await window.FirebaseAuthManager.signInWithEmailAndPassword('$email', '$password');
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase sign in successful');
        return {'success': true, 'user': result['user']};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase sign in failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase sign in error', e);
      return {'success': false, 'error': 'Firebase authentication failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> _firebaseSignOut() async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Signing out from Firebase');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            return await window.FirebaseAuthManager.signOut();
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase sign out successful');
        return {'success': true};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase sign out failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase sign out error', e);
      return {'success': false, 'error': 'Firebase sign out failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> firebaseSignInWithPhone(String phoneNumber) async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Attempting Firebase phone sign in for: $phoneNumber');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            // Note: Phone auth requires reCAPTCHA setup in production
            // For now, this is a placeholder for future implementation
            return { success: false, error: 'Phone authentication not configured' };
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase phone sign in successful');
        return {'success': true, 'confirmationResult': result['confirmationResult']};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase phone sign in failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase phone sign in error', e);
      return {'success': false, 'error': 'Firebase phone authentication failed: $e'};
    }
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);
  static bool _firebaseInitialized = false;

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  // Initialize Firebase auth state sync
  static Future<void> initializeFirebaseSync() async {
    if (!kIsWeb || _firebaseInitialized) return;

    try {
      // Set up Firebase auth state listener
      js.context.callMethod('eval', ['''
        if (window.FirebaseAuthManager) {
          window.FirebaseAuthManager.onAuthStateChanged((user) => {
            console.log('Firebase auth state changed:', user ? 'signed in' : 'signed out');

            // Communicate with Flutter
            if (window.flutter_inappwebview && window.flutter_inappwebview.callHandler) {
              window.flutter_inappwebview.callHandler('firebase_auth_changed', {
                isSignedIn: !!user,
                uid: user ? user.uid : null,
                email: user ? user.email : null
              });
            } else {
              // For regular browser, use custom event
              window.dispatchEvent(new CustomEvent('firebaseAuthChanged', {
                detail: {
                  isSignedIn: !!user,
                  uid: user ? user.uid : null,
                  email: user ? user.email : null
                }
              }));
            }
          });
        }
      ''']);

      _firebaseInitialized = true;
    } catch (e) {
      print('Failed to initialize Firebase sync: $e');
    }
  }

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;

    // Save user session to localStorage for persistence across tabs
    if (kIsWeb) {
      _saveUserSession(userData);
    }

    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;

    // Clear user session from localStorage
    if (kIsWeb) {
      _clearUserSession();
    }

    _notifyAuthChanged();
  }

  // Try to restore user session on app startup
  static Future<bool> restoreUserSession() async {
    if (!kIsWeb) {
      print('üì± Not web platform, skipping session restoration');
      return false;
    }

    try {
      print('üîÑ Calling SessionManager.restoreUserSession()...');

      // Check if SessionManager exists first
      final sessionManagerExists = js.context.callMethod('eval', ['''
        typeof window.SessionManager !== 'undefined'
      ''']);

      if (!sessionManagerExists) {
        print('‚ùå SessionManager not available');
        return false;
      }

      final sessionData = js.context.callMethod('eval', ['''
        window.SessionManager.restoreUserSession()
      ''']);

      print('üìä Session data received: $sessionData');
      print('üìä Session data type: ${sessionData.runtimeType}');

      if (sessionData != null) {
        // Convert JavaScript object to Dart Map
        final Map<String, dynamic> dataMap = {};

        try {
          dataMap['emplName'] = js.context.callMethod('eval', ['''
            window.SessionManager.restoreUserSession()?.emplName || ''
          ''']);
          dataMap['areaCode'] = js.context.callMethod('eval', ['''
            window.SessionManager.restoreUserSession()?.areaCode || ''
          ''']);
          dataMap['userID'] = js.context.callMethod('eval', ['''
            window.SessionManager.restoreUserSession()?.userID || ''
          ''']);

          final rolesData = js.context.callMethod('eval', ['''
            JSON.stringify(window.SessionManager.restoreUserSession()?.roles || [])
          ''']);
          final pagesData = js.context.callMethod('eval', ['''
            JSON.stringify(window.SessionManager.restoreUserSession()?.pages || [])
          ''']);

          dataMap['roles'] = jsonDecode(rolesData.toString());
          dataMap['pages'] = jsonDecode(pagesData.toString());

          print('üìä Parsed data: $dataMap');

          if (dataMap['userID']?.isNotEmpty == true) {
            final userData = UserData(
              emplName: dataMap['emplName'] ?? '',
              areaCode: dataMap['areaCode'] ?? '',
              roles: List<String>.from(dataMap['roles'] ?? []),
              pages: List<String>.from(dataMap['pages'] ?? []),
              userID: dataMap['userID'] ?? '',
            );

            _currentUser = userData;
            _notifyAuthChanged();

            print('‚úÖ User session restored successfully: ${userData.userID}');
            return true;
          } else {
            print('‚ùå Invalid session data - missing userID');
          }
        } catch (parseError) {
          print('‚ùå Failed to parse session data: $parseError');
        }
      } else {
        print('‚ùå No session data found');
      }
    } catch (e) {
      print('‚ùå Failed to restore user session: $e');
    }

    return false;
  }

  static void _saveUserSession(UserData userData) {
    try {
      print('üíæ Saving user session for: ${userData.userID}');
      js.context.callMethod('eval', ['''
        if (window.SessionManager) {
          window.SessionManager.saveUserSession({
            emplName: "${userData.emplName}",
            areaCode: "${userData.areaCode}",
            roles: ${jsonEncode(userData.roles)},
            pages: ${jsonEncode(userData.pages)},
            userID: "${userData.userID}"
          });
        } else {
          console.error('‚ùå SessionManager not available');
        }
      ''']);
    } catch (e) {
      print('‚ùå Failed to save user session: $e');
    }
  }

  static void _clearUserSession() {
    try {
      js.context.callMethod('eval', ['''
        if (window.SessionManager) {
          window.SessionManager.clearUserSession();
        }
      ''']);
    } catch (e) {
      print('Failed to clear user session: $e');
    }
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}





































<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Flutter will replace this with the value from --base-href -->
  <base href="$FLUTTER_BASE_HREF" />

  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
  <meta name="description" content="RAK Web App" />

  <!-- PWA / theme -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="rak_web" />
  <meta name="theme-color" content="#ffffff" />
  <link rel="apple-touch-icon" href="icons/Icon-192.png" />
  <link rel="icon" href="icons/Icon-192.png" />

  <!-- Viewport -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover" />

  <!-- Meta CSP (header CSP in IIS/web.config will override this if set) -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self' https:;
    script-src 'self' https: 'unsafe-inline' 'unsafe-eval';
    img-src 'self' blob: data: https:;
    style-src 'self' 'unsafe-inline' https:;
    connect-src 'self' https: http: wss: ws: blob: https://qa.birlawhite.com:55232 https://rak.birlawhite.com;
    font-src 'self' https: data:;
    media-src 'self' blob: data: https:;
    worker-src 'self' blob: https:;
    child-src 'self' blob:;
    frame-src 'self';
  " />

  <title>rak_web</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="assets/css/roboto.css" />

  <style>
    html, body { margin: 0; height: 100%; overscroll-behavior: none; background: #fff; }
  </style>
</head>
<body>
  <!-- PDF.js - Local -->
  <script src="assets/js/pdf.min.js"></script>
  <script>
    // Enhanced PDF.js worker configuration with better fallbacks
    if (typeof pdfjsLib !== 'undefined') {
      console.log('PDF.js version:', pdfjsLib.version || 'unknown');

      // Create a robust worker configuration
      const configurePDFWorker = () => {
        try {
          // Dynamic version detection or fallback to known version
          const pdfVersion = pdfjsLib.version || '3.11.174';
          const cdnWorkerUrl = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfVersion}/pdf.worker.min.js`;

          pdfjsLib.GlobalWorkerOptions.workerSrc = cdnWorkerUrl;

          console.log('PDF.js worker configured successfully with URL:', cdnWorkerUrl);

          // Test worker loading
          const testWorker = () => {
            try {
              if (pdfjsLib.getDocument) {
                console.log('PDF.js worker test successful');
              }
            } catch (error) {
              console.error('PDF.js worker test failed:', error);
            }
          };

          setTimeout(testWorker, 100);

        } catch (error) {
          console.error('Failed to configure PDF.js worker:', error);
        }
      };

      // Configure immediately
      configurePDFWorker();

      // Also configure on document ready as fallback
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', configurePDFWorker);
      }
    } else {
      console.warn('PDF.js library not found');
    }
  </script>

  <!-- Firebase Web SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

  <!-- Third-party libs - Local -->
  <script defer src="assets/js/tesseract.min.js"></script>
  <script defer src="assets/js/jsQR.js"></script>

  <!-- Firebase Configuration -->
  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyA7DZnKbvRlBvq23Zakcu-_nYJqeSaOKa8",
      authDomain: "rak-circle.firebaseapp.com",
      projectId: "rak-circle",
      storageBucket: "rak-circle.firebasestorage.app",
      messagingSenderId: "346258797033",
      appId: "1:346258797033:web:e48a94e9560234e0c2db78",
      measurementId: "G-707FN3TQPD"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);

    // Set auth persistence to LOCAL (stores in IndexedDB/localStorage)
    firebase.auth().setPersistence(firebase.auth.Auth.Persistence.LOCAL)
      .then(() => {
        console.log('Firebase auth persistence set to LOCAL');
      })
      .catch((error) => {
        console.error('Failed to set Firebase auth persistence:', error);
      });

    // Global Firebase Auth instance
    window.firebaseAuth = firebase.auth();

    // Firebase Auth State Management
    window.FirebaseAuthManager = {
      currentUser: null,
      authStateListeners: [],
      isInitialized: false,

      // Initialize auth state listener
      init() {
        if (this.isInitialized) return;

        console.log('üî• Initializing Firebase Auth state listener');

        firebase.auth().onAuthStateChanged((user) => {
          console.log('üîÑ Firebase auth state changed:', user ? 'SIGNED IN' : 'SIGNED OUT');
          if (user) {
            console.log('üë§ User details:', {
              uid: user.uid,
              email: user.email,
              emailVerified: user.emailVerified
            });
          }
          this.currentUser = user;

          // Notify all listeners
          this.authStateListeners.forEach(callback => {
            try {
              callback(user);
            } catch (error) {
              console.error('‚ùå Auth state listener error:', error);
            }
          });
        });

        this.isInitialized = true;
        console.log('‚úÖ Firebase Auth Manager initialized');
      },

      // Add auth state change listener
      onAuthStateChanged(callback) {
        this.authStateListeners.push(callback);

        // If already initialized, call immediately with current state
        if (this.isInitialized && this.currentUser !== null) {
          callback(this.currentUser);
        }
      },

      // Get current Firebase user
      getCurrentUser() {
        return firebase.auth().currentUser;
      },

      // Get Firebase ID token
      async getIdToken() {
        const user = this.getCurrentUser();
        if (!user) {
          console.log('üé´ No Firebase user for token');
          return null;
        }

        try {
          const token = await user.getIdToken();
          console.log('üé´ Firebase ID token obtained:', token ? 'SUCCESS' : 'NULL');
          return token;
        } catch (error) {
          console.error('‚ùå Failed to get Firebase ID token:', error);
          return null;
        }
      },

      // Sign in with email and password
      async signInWithEmailAndPassword(email, password) {
        try {
          console.log('üîê Attempting Firebase sign in for:', email);
          const userCredential = await firebase.auth().signInWithEmailAndPassword(email, password);
          console.log('‚úÖ Firebase sign in successful for:', email);
          return { success: true, user: userCredential.user };
        } catch (error) {
          console.error('‚ùå Firebase sign in error:', error);
          return { success: false, error: error.message };
        }
      },

      // Sign in with phone number
      async signInWithPhoneNumber(phoneNumber, recaptchaVerifier) {
        try {
          const confirmationResult = await firebase.auth().signInWithPhoneNumber(phoneNumber, recaptchaVerifier);
          return { success: true, confirmationResult };
        } catch (error) {
          console.error('Firebase phone sign in error:', error);
          return { success: false, error: error.message };
        }
      },

      // Create user with email and password
      async createUserWithEmailAndPassword(email, password) {
        try {
          const userCredential = await firebase.auth().createUserWithEmailAndPassword(email, password);
          return { success: true, user: userCredential.user };
        } catch (error) {
          console.error('Firebase create user error:', error);
          return { success: false, error: error.message };
        }
      },

      // Sign out
      async signOut() {
        try {
          await firebase.auth().signOut();
          return { success: true };
        } catch (error) {
          console.error('Firebase sign out error:', error);
          return { success: false, error: error.message };
        }
      },

      // Send password reset email
      async sendPasswordResetEmail(email) {
        try {
          await firebase.auth().sendPasswordResetEmail(email);
          return { success: true };
        } catch (error) {
          console.error('Firebase password reset error:', error);
          return { success: false, error: error.message };
        }
      }
    };

    // Session Restoration Helper
    window.SessionManager = {
      // Save user data to localStorage
      saveUserSession(userData) {
        try {
          localStorage.setItem('flutter_user_session', JSON.stringify(userData));
          console.log('üíæ User session saved to localStorage:', userData);
        } catch (error) {
          console.error('‚ùå Failed to save user session:', error);
        }
      },

      // Restore user data from localStorage
      restoreUserSession() {
        try {
          const sessionData = localStorage.getItem('flutter_user_session');
          if (sessionData) {
            const userData = JSON.parse(sessionData);
            console.log('üì± User session restored from localStorage:', userData);
            return userData;
          } else {
            console.log('üì± No user session found in localStorage');
          }
        } catch (error) {
          console.error('‚ùå Failed to restore user session:', error);
        }
        return null;
      },

      // Clear user session
      clearUserSession() {
        try {
          localStorage.removeItem('flutter_user_session');
          console.log('üóëÔ∏è User session cleared from localStorage');
        } catch (error) {
          console.error('‚ùå Failed to clear user session:', error);
        }
      }
    };

    // Debug helper - call from console: window.debugAuth()
    window.debugAuth = function() {
      console.log('üîç AUTH DEBUG INFO:');
      console.log('Firebase ready:', !!window.FirebaseAuthManager);
      console.log('SessionManager ready:', !!window.SessionManager);

      if (window.FirebaseAuthManager) {
        const user = window.FirebaseAuthManager.getCurrentUser();
        console.log('Firebase user:', user ? {
          uid: user.uid,
          email: user.email,
          emailVerified: user.emailVerified
        } : 'NO USER');
      }

      if (window.SessionManager) {
        const session = window.SessionManager.restoreUserSession();
        console.log('Stored session:', session);
      }

      // Check localStorage directly
      const rawSession = localStorage.getItem('flutter_user_session');
      console.log('Raw localStorage:', rawSession);
    };

    // Initialize Firebase Auth Manager when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        window.FirebaseAuthManager.init();
      });
    } else {
      window.FirebaseAuthManager.init();
    }
  </script>

  <!-- Your local scripts -->
  <script defer src="mlkit-ocr.js"></script>
  <script defer src="ocr.js"></script>

  <!-- QR Code + Geolocation helpers -->
  <script>
    window.detectQRCode = function(imageData, width, height) {
      try {
        if (typeof jsQR !== 'undefined') {
          const code = jsQR(imageData, width, height);
          return code ? code.data : null;
        }
      } catch (e) { console.error('QR detection error:', e); }
      return null;
    };

    window.requestGeoPosition = async function () {
      if (!('geolocation' in navigator)) return { ok: false, error: 'Geolocation not supported' };
      return new Promise((resolve) => {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const lat = +pos.coords.latitude.toFixed(6);
            const lng = +pos.coords.longitude.toFixed(6);
            try { localStorage.setItem('lastLat', String(lat)); localStorage.setItem('lastLng', String(lng)); } catch {}
            resolve({ ok: true, lat, lng });
          },
          (err) => resolve({ ok: false, error: err.message }),
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
        );
      });
    };
  </script>

  <!-- Native Permissions Bridge -->
  <script>
    (function () {
      const w = window;
      const hasBridge = !!(w.flutter_inappwebview && typeof w.flutter_inappwebview.callHandler === 'function');

      async function callHandler(name, payload) {
        if (!hasBridge) return { ok: false, status: 'no-bridge', error: 'InAppWebView bridge not available' };
        try {
          const res = await w.flutter_inappwebview.callHandler(name, payload);
          return (res && typeof res === 'object') ? res : { ok: false, status: 'invalid', error: 'Bad response' };
        } catch (e) {
          return { ok: false, status: 'error', error: String(e) };
        }
      }

      async function warmUpBrowser(type) {
        try {
          if (type === 'camera') {
            if (!navigator.mediaDevices?.getUserMedia) return { ok: false, error: 'getUserMedia not supported' };
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            stream.getTracks().forEach(t => t.stop());
            return { ok: true };
          }
          if (type === 'microphone') {
            if (!navigator.mediaDevices?.getUserMedia) return { ok: false, error: 'getUserMedia not supported' };
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream.getTracks().forEach(t => t.stop());
            return { ok: true };
          }
          if (type === 'geolocation') return await w.requestGeoPosition();
          if (type === 'notifications') {
            if (!('Notification' in w)) return { ok: false, error: 'Notifications not supported' };
            const perm = await Notification.requestPermission();
            return { ok: perm === 'granted', status: perm };
          }
          if (type === 'bluetooth') {
            if (!navigator.bluetooth) return { ok: false, error: 'Web Bluetooth not supported' };
            return { ok: true, status: 'user-gesture-required' };
          }
          if (type === 'storage' && navigator.storage?.persist) {
            const persisted = await navigator.storage.persist();
            return { ok: persisted, status: persisted ? 'persisted' : 'not-persisted' };
          }
          return { ok: true };
        } catch (e) { return { ok: false, error: String(e) }; }
      }

      async function browserPermissionStatus(type) {
        try {
          if (!navigator.permissions?.query) return null;
          const nameMap = { camera: 'camera', microphone: 'microphone', geolocation: 'geolocation', notifications: 'notifications' };
          const name = nameMap[type]; if (!name) return null;
          const status = await navigator.permissions.query({ name });
          return status.state;
        } catch { return null; }
      }

      w.NativePerms = {
        request: async function (type, rationale) {
          const native = await callHandler('perm_request', { type, rationale });
          if (!native.ok) return native;
          const web = await warmUpBrowser(type);
          if (!web.ok) return { ok: true, status: native.status || 'granted', webError: web.error || web.status };
          return { ok: true, status: native.status || 'granted' };
        },
        status: async function (type) {
          const native = await callHandler('perm_status', { type });
          const browser = await browserPermissionStatus(type);
          if (browser) native.browser = browser;
          return native;
        },
        openSettings: function () { return callHandler('open_settings', {}); }
      };
    })();
  </script>

  <!-- Camera Uploader -->
  <script>
    (function () {
      const w = window;
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'image/*'; input.capture = 'environment';
      input.style.position = 'fixed'; input.style.left = '-9999px';
      document.body.appendChild(input);

      function pickViaInput() {
        return new Promise((res, rej) => {
          input.value = '';
          const onChange = () => {
            input.removeEventListener('change', onChange);
            const f = input.files?.[0]; if (!f) return rej(new Error('no-file-selected')); res(f);
          };
          input.addEventListener('change', onChange, { once: true });
          input.click();
        });
      }

      function overlay() {
        const wrap = document.createElement('div');
        wrap.style.cssText = `position:fixed; inset:0; background:rgba(0,0,0,.85); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:2147483647; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;`;
        const v = document.createElement('video'); v.autoplay = true; v.playsInline = true; v.muted = true;
        v.style.cssText = 'max-width:90vw; max-height:60vh; background:#000; border-radius:12px;';
        const row = document.createElement('div'); row.style.cssText = 'display:flex; gap:12px; margin-top:16px;';
        const shot = document.createElement('button'); const cancel = document.createElement('button');
        [shot, cancel].forEach(b=>b.style.cssText='padding:12px 18px; border-radius:10px; border:none; font-weight:600; cursor:pointer;');
        shot.textContent = 'Take Photo'; shot.style.background = '#21a0ff';
        cancel.textContent = 'Cancel'; cancel.style.background = '#666';
        row.append(shot, cancel);
        const msg = document.createElement('div'); msg.style.cssText = 'margin-top:10px; font-size:12px; opacity:.8;';
        msg.textContent = 'If video is black, camera permission was denied or not available.';
        wrap.append(v, row, msg); document.body.appendChild(wrap);
        return { wrap, v, shot, cancel };
      }

      async function pickViaGUM() {
        if (!navigator.mediaDevices?.getUserMedia) throw new Error('gum-not-supported');
        const { wrap, v, shot, cancel } = overlay();
        let stream;
        try {
          stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } } });
        } catch (e) { wrap.remove(); throw new Error('gum-permission-failed: ' + (e?.message || e)); }
        v.srcObject = stream;
        const file = await new Promise((resolve, reject) => {
          cancel.onclick = () => { try { stream.getTracks().forEach(t=>t.stop()); } catch{} wrap.remove(); reject(new Error('user-cancelled')); };
          shot.onclick = async () => {
            try {
              const c = document.createElement('canvas'); const vw = v.videoWidth || 1920, vh = v.videoHeight || 1080;
              c.width = vw; c.height = vh; c.getContext('2d', { alpha:false }).drawImage(v, 0, 0, vw, vh);
              const blob = await new Promise(r=>c.toBlob(r, 'image/jpeg', 0.9));
              resolve(new File([blob], 'camera.jpg', { type: 'image/jpeg' }));
            } catch (e) { reject(e); }
            finally { try { stream.getTracks().forEach(t=>t.stop()); } catch{} wrap.remove(); }
          };
        });
        return file;
      }

      async function downscale(f, maxW=1600, q=0.85) {
        try {
          const img = new Image(); const url = URL.createObjectURL(f);
          await new Promise((ok,bad)=>{ img.onload=ok; img.onerror=bad; img.src=url; });
          const scale = Math.min(1, maxW / img.width); URL.revokeObjectURL(url);
          if (scale >= 1) return f;
          const c = document.createElement('canvas'); c.width = Math.round(img.width*scale); c.height = Math.round(img.height*scale);
          c.getContext('2d', { alpha:false }).drawImage(img,0,0,c.width,c.height);
          const blob = await new Promise(r=>c.toBlob(r,'image/jpeg',q));
          return new File([blob], f.name.replace(/\.\w+$/, '-scaled.jpg'), { type:'image/jpeg' });
        } catch { return f; }
      }

      async function toB64(f){ return await new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(String(r.result)); r.onerror=rej; r.readAsDataURL(f); }); }

      w.CameraUploader = {
        async pick({ prefer='input', downscaleImage=true } = {}) {
          try {
            if (w.NativePerms) await w.NativePerms.request('camera');
            let f;
            if (prefer==='gum') { try { f = await pickViaGUM(); } catch { f = await pickViaInput(); } }
            else { try { f = await pickViaInput(); } catch { f = await pickViaGUM(); } }
            if (downscaleImage) f = await downscale(f);
            const base64 = await toB64(f);
            return { ok:true, fileName:f.name, mime:f.type, size:f.size, base64 };
          } catch (e) { return { ok:false, error:String(e) }; }
        },
        async upload({ endpoint, fieldName='photo', extra={}, headers={}, method='POST', prefer='input', downscaleImage=true } = {}) {
          if (!endpoint) return { ok:false, error:'Missing endpoint' };
          try {
            const picked = await this.pick({ prefer, downscaleImage });
            if (!picked.ok) return picked;
            const resp = await fetch(picked.base64); const blob = await resp.blob();
            const file = new File([blob], picked.fileName || 'photo.jpg', { type:picked.mime || 'image/jpeg' });
            const fd = new FormData(); fd.append(fieldName, file, file.name);
            Object.entries(extra).forEach(([k,v])=>fd.append(k, String(v)));
            const rsp = await fetch(endpoint, { method, body: fd, headers });
            const ct = rsp.headers.get('content-type') || '';
            const payload = ct.includes('application/json') ? await rsp.json().catch(()=>({})) : await rsp.text();
            return { ok:rsp.ok, status:rsp.status, data:payload };
          } catch (e) { return { ok:false, error:String(e) }; }
        }
      };
    })();
  </script>

  <!-- Flutter bootstrap -->
  <script defer src="flutter_bootstrap.js"></script>
</body>
</html>
