<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Flutter will replace this with the value from --base-href -->
  <base href="$FLUTTER_BASE_HREF" />

  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
  <meta name="description" content="RAK Web App" />

  <!-- PWA / theme -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="rak_web" />
  <meta name="theme-color" content="#ffffff" />
  <link rel="apple-touch-icon" href="icons/Icon-192.png" />
  <link rel="icon" href="icons/Icon-192.png" />

  <!-- Viewport -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover" />

  <!-- Meta CSP (header CSP in IIS/web.config will override this if set) -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self' https:;
    script-src 'self' https: 'unsafe-inline' 'unsafe-eval';
    img-src 'self' blob: data: https:;
    style-src 'self' 'unsafe-inline' https:;
    connect-src 'self' https: http: wss: ws: blob: https://qa.birlawhite.com:55232 https://rak.birlawhite.com;
    font-src 'self' https: data:;
    media-src 'self' blob: data: https:;
    worker-src 'self' blob: https:;
    child-src 'self' blob:;
    frame-src 'self';
  " />

  <title>rak_web</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="assets/css/roboto.css" />

  <style>
    html, body { margin: 0; height: 100%; overscroll-behavior: none; background: #fff; }
  </style>
</head>
<body>
  <!-- PDF.js - Local -->
  <script src="assets/js/pdf.min.js"></script>
  <script>
    // Enhanced PDF.js worker configuration with better fallbacks
    if (typeof pdfjsLib !== 'undefined') {
      console.log('PDF.js version:', pdfjsLib.version || 'unknown');

      // Create a robust worker configuration
      const configurePDFWorker = () => {
        try {
          // Dynamic version detection or fallback to known version
          const pdfVersion = pdfjsLib.version || '3.11.174';
          const cdnWorkerUrl = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfVersion}/pdf.worker.min.js`;

          pdfjsLib.GlobalWorkerOptions.workerSrc = cdnWorkerUrl;

          console.log('PDF.js worker configured successfully with URL:', cdnWorkerUrl);

          // Test worker loading
          const testWorker = () => {
            try {
              if (pdfjsLib.getDocument) {
                console.log('PDF.js worker test successful');
              }
            } catch (error) {
              console.error('PDF.js worker test failed:', error);
            }
          };

          setTimeout(testWorker, 100);

        } catch (error) {
          console.error('Failed to configure PDF.js worker:', error);
        }
      };

      // Configure immediately
      configurePDFWorker();

      // Also configure on document ready as fallback
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', configurePDFWorker);
      }
    } else {
      console.warn('PDF.js library not found');
    }
  </script>

  <!-- Third-party libs - Local -->
  <script defer src="assets/js/tesseract.min.js"></script>
  <script defer src="assets/js/jsQR.js"></script>

  <!-- Your local scripts -->
  <script defer src="mlkit-ocr.js"></script>
  <script defer src="ocr.js"></script>

  <!-- QR Code + Geolocation helpers -->
  <script>
    window.detectQRCode = function(imageData, width, height) {
      try {
        if (typeof jsQR !== 'undefined') {
          const code = jsQR(imageData, width, height);
          return code ? code.data : null;
        }
      } catch (e) { console.error('QR detection error:', e); }
      return null;
    };

    window.requestGeoPosition = async function () {
      if (!('geolocation' in navigator)) return { ok: false, error: 'Geolocation not supported' };
      return new Promise((resolve) => {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const lat = +pos.coords.latitude.toFixed(6);
            const lng = +pos.coords.longitude.toFixed(6);
            try { localStorage.setItem('lastLat', String(lat)); localStorage.setItem('lastLng', String(lng)); } catch {}
            resolve({ ok: true, lat, lng });
          },
          (err) => resolve({ ok: false, error: err.message }),
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
        );
      });
    };
  </script>

  <!-- Native Permissions Bridge -->
  <script>
    (function () {
      const w = window;
      const hasBridge = !!(w.flutter_inappwebview && typeof w.flutter_inappwebview.callHandler === 'function');

      async function callHandler(name, payload) {
        if (!hasBridge) return { ok: false, status: 'no-bridge', error: 'InAppWebView bridge not available' };
        try {
          const res = await w.flutter_inappwebview.callHandler(name, payload);
          return (res && typeof res === 'object') ? res : { ok: false, status: 'invalid', error: 'Bad response' };
        } catch (e) {
          return { ok: false, status: 'error', error: String(e) };
        }
      }

      async function warmUpBrowser(type) {
        try {
          if (type === 'camera') {
            if (!navigator.mediaDevices?.getUserMedia) return { ok: false, error: 'getUserMedia not supported' };
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            stream.getTracks().forEach(t => t.stop());
            return { ok: true };
          }
          if (type === 'microphone') {
            if (!navigator.mediaDevices?.getUserMedia) return { ok: false, error: 'getUserMedia not supported' };
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream.getTracks().forEach(t => t.stop());
            return { ok: true };
          }
          if (type === 'geolocation') return await w.requestGeoPosition();
          if (type === 'notifications') {
            if (!('Notification' in w)) return { ok: false, error: 'Notifications not supported' };
            const perm = await Notification.requestPermission();
            return { ok: perm === 'granted', status: perm };
          }
          if (type === 'bluetooth') {
            if (!navigator.bluetooth) return { ok: false, error: 'Web Bluetooth not supported' };
            return { ok: true, status: 'user-gesture-required' };
          }
          if (type === 'storage' && navigator.storage?.persist) {
            const persisted = await navigator.storage.persist();
            return { ok: persisted, status: persisted ? 'persisted' : 'not-persisted' };
          }
          return { ok: true };
        } catch (e) { return { ok: false, error: String(e) }; }
      }

      async function browserPermissionStatus(type) {
        try {
          if (!navigator.permissions?.query) return null;
          const nameMap = { camera: 'camera', microphone: 'microphone', geolocation: 'geolocation', notifications: 'notifications' };
          const name = nameMap[type]; if (!name) return null;
          const status = await navigator.permissions.query({ name });
          return status.state;
        } catch { return null; }
      }

      w.NativePerms = {
        request: async function (type, rationale) {
          const native = await callHandler('perm_request', { type, rationale });
          if (!native.ok) return native;
          const web = await warmUpBrowser(type);
          if (!web.ok) return { ok: true, status: native.status || 'granted', webError: web.error || web.status };
          return { ok: true, status: native.status || 'granted' };
        },
        status: async function (type) {
          const native = await callHandler('perm_status', { type });
          const browser = await browserPermissionStatus(type);
          if (browser) native.browser = browser;
          return native;
        },
        openSettings: function () { return callHandler('open_settings', {}); }
      };
    })();
  </script>

  <!-- Camera Uploader -->
  <script>
    (function () {
      const w = window;
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'image/*'; input.capture = 'environment';
      input.style.position = 'fixed'; input.style.left = '-9999px';
      document.body.appendChild(input);

      function pickViaInput() {
        return new Promise((res, rej) => {
          input.value = '';
          const onChange = () => {
            input.removeEventListener('change', onChange);
            const f = input.files?.[0]; if (!f) return rej(new Error('no-file-selected')); res(f);
          };
          input.addEventListener('change', onChange, { once: true });
          input.click();
        });
      }

      function overlay() {
        const wrap = document.createElement('div');
        wrap.style.cssText = `position:fixed; inset:0; background:rgba(0,0,0,.85); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:2147483647; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;`;
        const v = document.createElement('video'); v.autoplay = true; v.playsInline = true; v.muted = true;
        v.style.cssText = 'max-width:90vw; max-height:60vh; background:#000; border-radius:12px;';
        const row = document.createElement('div'); row.style.cssText = 'display:flex; gap:12px; margin-top:16px;';
        const shot = document.createElement('button'); const cancel = document.createElement('button');
        [shot, cancel].forEach(b=>b.style.cssText='padding:12px 18px; border-radius:10px; border:none; font-weight:600; cursor:pointer;');
        shot.textContent = 'Take Photo'; shot.style.background = '#21a0ff';
        cancel.textContent = 'Cancel'; cancel.style.background = '#666';
        row.append(shot, cancel);
        const msg = document.createElement('div'); msg.style.cssText = 'margin-top:10px; font-size:12px; opacity:.8;';
        msg.textContent = 'If video is black, camera permission was denied or not available.';
        wrap.append(v, row, msg); document.body.appendChild(wrap);
        return { wrap, v, shot, cancel };
      }

      async function pickViaGUM() {
        if (!navigator.mediaDevices?.getUserMedia) throw new Error('gum-not-supported');
        const { wrap, v, shot, cancel } = overlay();
        let stream;
        try {
          stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } } });
        } catch (e) { wrap.remove(); throw new Error('gum-permission-failed: ' + (e?.message || e)); }
        v.srcObject = stream;
        const file = await new Promise((resolve, reject) => {
          cancel.onclick = () => { try { stream.getTracks().forEach(t=>t.stop()); } catch{} wrap.remove(); reject(new Error('user-cancelled')); };
          shot.onclick = async () => {
            try {
              const c = document.createElement('canvas'); const vw = v.videoWidth || 1920, vh = v.videoHeight || 1080;
              c.width = vw; c.height = vh; c.getContext('2d', { alpha:false }).drawImage(v, 0, 0, vw, vh);
              const blob = await new Promise(r=>c.toBlob(r, 'image/jpeg', 0.9));
              resolve(new File([blob], 'camera.jpg', { type: 'image/jpeg' }));
            } catch (e) { reject(e); }
            finally { try { stream.getTracks().forEach(t=>t.stop()); } catch{} wrap.remove(); }
          };
        });
        return file;
      }

      async function downscale(f, maxW=1600, q=0.85) {
        try {
          const img = new Image(); const url = URL.createObjectURL(f);
          await new Promise((ok,bad)=>{ img.onload=ok; img.onerror=bad; img.src=url; });
          const scale = Math.min(1, maxW / img.width); URL.revokeObjectURL(url);
          if (scale >= 1) return f;
          const c = document.createElement('canvas'); c.width = Math.round(img.width*scale); c.height = Math.round(img.height*scale);
          c.getContext('2d', { alpha:false }).drawImage(img,0,0,c.width,c.height);
          const blob = await new Promise(r=>c.toBlob(r,'image/jpeg',q));
          return new File([blob], f.name.replace(/\.\w+$/, '-scaled.jpg'), { type:'image/jpeg' });
        } catch { return f; }
      }

      async function toB64(f){ return await new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(String(r.result)); r.onerror=rej; r.readAsDataURL(f); }); }

      w.CameraUploader = {
        async pick({ prefer='input', downscaleImage=true } = {}) {
          try {
            if (w.NativePerms) await w.NativePerms.request('camera');
            let f;
            if (prefer==='gum') { try { f = await pickViaGUM(); } catch { f = await pickViaInput(); } }
            else { try { f = await pickViaInput(); } catch { f = await pickViaGUM(); } }
            if (downscaleImage) f = await downscale(f);
            const base64 = await toB64(f);
            return { ok:true, fileName:f.name, mime:f.type, size:f.size, base64 };
          } catch (e) { return { ok:false, error:String(e) }; }
        },
        async upload({ endpoint, fieldName='photo', extra={}, headers={}, method='POST', prefer='input', downscaleImage=true } = {}) {
          if (!endpoint) return { ok:false, error:'Missing endpoint' };
          try {
            const picked = await this.pick({ prefer, downscaleImage });
            if (!picked.ok) return picked;
            const resp = await fetch(picked.base64); const blob = await resp.blob();
            const file = new File([blob], picked.fileName || 'photo.jpg', { type:picked.mime || 'image/jpeg' });
            const fd = new FormData(); fd.append(fieldName, file, file.name);
            Object.entries(extra).forEach(([k,v])=>fd.append(k, String(v)));
            const rsp = await fetch(endpoint, { method, body: fd, headers });
            const ct = rsp.headers.get('content-type') || '';
            const payload = ct.includes('application/json') ? await rsp.json().catch(()=>({})) : await rsp.text();
            return { ok:rsp.ok, status:rsp.status, data:payload };
          } catch (e) { return { ok:false, error:String(e) }; }
        }
      };
    })();
  </script>

  <!-- Flutter bootstrap -->
  <script defer src="flutter_bootstrap.js"></script>
</body>
</html>







































import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import '../models/auth_models.dart';
import '../utils/app_logger.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client.send(request).timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      // Extract cookies from response headers for future requests
      final cookieHeader = response.headers['set-cookie'];
      if (cookieHeader != null) {
        _logger.debug('Received cookies: $cookieHeader');
      }

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    final result = await authenticateUser(userID: userId, password: password);
    if (result['success'] == true) {
      final loginResponse = result['data'] as LoginResponse;
      // Create a new UserData instance with the userID preserved
      final userDataWithId = UserData(
        emplName: loginResponse.data.emplName,
        areaCode: loginResponse.data.areaCode,
        roles: loginResponse.data.roles,
        pages: loginResponse.data.pages,
        userID: userId, // Preserve the original userID from login
      );
      AuthManager.setUser(userDataWithId);
      return true;
    }
    return false;
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    // Try to logout from server first
    final serverLogout = await logoutFromServer();
    if (!serverLogout['success']) {
      _logger.warning('Server logout failed, clearing local session anyway');
    }

    AuthManager.clearUser();
    await Future.delayed(const Duration(milliseconds: 500));
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }

  // Session validation endpoint
  static Future<Map<String, dynamic>> validateSession() async {
    try {
      _logger.info('Validating user session');

      final uri = Uri.parse('$baseUrl/auth/me');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .get(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Session validation response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Session validation failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Session validation error', e);
      return {
        'success': false,
        'error': 'Network error during session validation',
        'statusCode': 0,
      };
    }
  }

  // Token refresh endpoint
  static Future<Map<String, dynamic>> refreshToken() async {
    try {
      _logger.info('Refreshing access token');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  // Enhanced logout with server-side session clearing
  static Future<Map<String, dynamic>> logoutFromServer() async {
    try {
      _logger.info('Logging out from server');

      final uri = Uri.parse('$baseUrl/auth/logout');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Server logout response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Server logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout',
        'statusCode': 0,
      };
    }
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;
    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;
    _notifyAuthChanged();
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}





































import 'dart:async';
import 'dart:convert';
import 'dart:io' show File;
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:web/web.dart' as web;
import '../utils/app_logger.dart';

class ApiService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  // Base URL configuration with fallback options
  static String get baseUrl {
    return 'https://qa.birlawhite.com:55232';
  }

  static List<String> get fallbackUrls => [
    'http://10.166.220.122',
    'http://[::1]',
    'http://localhost',
    'http://127.0.0.1',
  ];

  static bool get _isInAppWebView {
    if (kIsWeb) {
      try {
        final ua = web.window.navigator.userAgent.toLowerCase();
        final vendor = web.window.navigator.vendor.toLowerCase();
        final loc = web.window.location;

        return ua.contains('inapp') ||
            ua.contains('webview') ||
            ua.contains('inappbrowser') ||
            ua.contains('capacitor') ||
            ua.contains('cordova') ||
            ua.contains('phonegap') ||
            vendor.contains('inapp') ||
            loc.protocol == 'file:' ||
            loc.protocol == 'capacitor:' ||
            loc.protocol == 'ionic:' ||
            (loc.hostname == 'localhost' && loc.port.isEmpty) ||
            (ua.contains('mobile') && !ua.contains('chrome'));
      } catch (_) {
        return true;
      }
    }
    return false;
  }

  // Remove duplicate - using the new fallbackUrls getter above

  // Flag to prevent multiple simultaneous refresh attempts
  static bool _isRefreshing = false;

  // Generic HTTP methods with automatic 401 handling
  static Future<Map<String, dynamic>> makeRequest({
    required String method,
    required String endpoint,
    Map<String, dynamic>? body,
    Map<String, String>? headers,
    Duration? timeout,
    bool includeCredentials = true,
    bool retryOn401 = true,
  }) async {
    return _makeRequestWithRetry(
      method: method,
      endpoint: endpoint,
      body: body,
      headers: headers,
      timeout: timeout,
      includeCredentials: includeCredentials,
      retryOn401: retryOn401,
      isRetry: false,
    );
  }

  static Future<Map<String, dynamic>> _makeRequestWithRetry({
    required String method,
    required String endpoint,
    Map<String, dynamic>? body,
    Map<String, String>? headers,
    Duration? timeout,
    bool includeCredentials = true,
    bool retryOn401 = true,
    required bool isRetry,
  }) async {
    try {
      _logger.info('Making $method request to $endpoint${isRetry ? ' (retry)' : ''}');

      final uri = Uri.parse('$baseUrl$endpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        ...?headers,
      };

      http.Response response;
      final timeoutDuration = timeout ?? _defaultTimeout;

      // Create request with credentials if needed for web
      if (kIsWeb && includeCredentials) {
        final client = http.Client();
        final request = http.Request(method.toUpperCase(), uri);
        request.headers.addAll(requestHeaders);

        if (body != null && (method.toUpperCase() == 'POST' || method.toUpperCase() == 'PUT')) {
          request.body = jsonEncode(body);
        }

        final streamedResponse = await client.send(request).timeout(timeoutDuration);
        response = await http.Response.fromStream(streamedResponse);
      } else {
        switch (method.toUpperCase()) {
          case 'GET':
            response = await http
                .get(uri, headers: requestHeaders)
                .timeout(timeoutDuration);
            break;
          case 'POST':
            response = await http
                .post(
                  uri,
                  headers: requestHeaders,
                  body: jsonEncode(body ?? <String, dynamic>{}),
                )
                .timeout(timeoutDuration);
            break;
          case 'PUT':
            response = await http
                .put(
                  uri,
                  headers: requestHeaders,
                  body: jsonEncode(body ?? <String, dynamic>{}),
                )
                .timeout(timeoutDuration);
            break;
          case 'DELETE':
            response = await http
                .delete(uri, headers: requestHeaders)
                .timeout(timeoutDuration);
            break;
          default:
            throw Exception('Unsupported HTTP method: $method');
        }
      }

      _logger.debug('Response ${response.statusCode} for $method $endpoint');
      _logger.debug('Response body: ${response.body}');

      final parsed = _safeJson(response.body);

      // Handle 401 Unauthorized with automatic refresh
      if (response.statusCode == 401 && retryOn401 && !isRetry) {
        _logger.info('Received 401, attempting token refresh');

        if (!_isRefreshing) {
          _isRefreshing = true;
          try {
            // Call refresh endpoint directly to avoid circular dependency
            final refreshResult = await _refreshTokenDirect();

            if (refreshResult['success'] == true) {
              _logger.info('Token refreshed successfully, retrying original request');

              // Retry the original request once
              return await _makeRequestWithRetry(
                method: method,
                endpoint: endpoint,
                body: body,
                headers: headers,
                timeout: timeout,
                includeCredentials: includeCredentials,
                retryOn401: false, // Don't retry again to avoid infinite loops
                isRetry: true,
              );
            } else {
              _logger.warning('Token refresh failed, redirecting to login');

              return {
                'success': false,
                'error': 'Authentication expired. Please login again.',
                'statusCode': 401,
                'requiresLogin': true,
              };
            }
          } finally {
            _isRefreshing = false;
          }
        } else {
          // Wait for ongoing refresh to complete
          while (_isRefreshing) {
            await Future.delayed(const Duration(milliseconds: 100));
          }

          // Retry once after refresh completes
          return await _makeRequestWithRetry(
            method: method,
            endpoint: endpoint,
            body: body,
            headers: headers,
            timeout: timeout,
            includeCredentials: includeCredentials,
            retryOn401: false,
            isRetry: true,
          );
        }
      }

      if (response.statusCode >= 200 && response.statusCode < 300) {
        return {
          'success': true,
          'data': parsed,
          'statusCode': response.statusCode,
        };
      } else {
        final msg = _extractProblemMessage(
          parsed,
          fallback: response.reasonPhrase ?? 'Request failed',
        );
        return {
          'success': false,
          'error': msg,
          'statusCode': response.statusCode,
          'data': parsed,
        };
      }
    } catch (e) {
      _logger.error('Request failed', e);
      return {'success': false, 'error': 'Network error: $e', 'statusCode': 0};
    }
  }

  // Direct refresh token call to avoid circular dependencies
  static Future<Map<String, dynamic>> _refreshTokenDirect() async {
    try {
      _logger.info('Refreshing access token directly');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  /// Turns ASP.NET ProblemDetails (title/detail/errors) into a readable string.
  static String _extractProblemMessage(
    Map<String, dynamic> j, {
    String fallback = 'Request failed',
  }) {
    // Prefer ProblemDetails shape
    final title = j['title']?.toString();
    final detail = j['detail']?.toString();
    String combined = (title ?? '').trim();
    if (detail != null && detail.isNotEmpty) {
      combined = combined.isEmpty ? detail : '$combined — $detail';
    }

    // Flatten validation "errors"
    if (j['errors'] is Map) {
      final errs = j['errors'] as Map;
      final parts = <String>[];
      errs.forEach((k, v) {
        if (v is List && v.isNotEmpty) {
          parts.add('$k: ${v.join("; ")}');
        } else if (v != null) {
          parts.add('$k: $v');
        }
      });
      if (parts.isNotEmpty) {
        final flat = parts.join(' | ');
        combined = combined.isEmpty ? flat : '$combined | $flat';
      }
    }

    if (combined.isNotEmpty) return combined;

    // Fallbacks
    if (j['message'] != null) return j['message'].toString();
    if (j['error'] != null) return j['error'].toString();
    if (j['raw'] is String && (j['raw'] as String).isNotEmpty)
      return j['raw'] as String;
    return fallback;
  }

  // Authentication APIs
  static Future<Map<String, dynamic>> login(
    String userId,
    String password,
  ) async {
    await Future.delayed(const Duration(seconds: 1)); // Simulate delay

    if (userId.isNotEmpty && password.isNotEmpty) {
      return {
        'success': true,
        'data': {
          'token': 'mock_jwt_token_${DateTime.now().millisecondsSinceEpoch}',
          'user': {
            'id': userId,
            'name': 'User Name',
            'email': '$userId@example.com',
          },
        },
      };
    }

    return {'success': false, 'error': 'Invalid credentials'};
  }

  static Future<Map<String, dynamic>> loginWithOtp(
    String mobile,
    String otp,
  ) async {
    await Future.delayed(const Duration(seconds: 1));

    if (mobile.isNotEmpty && otp.isNotEmpty) {
      return {
        'success': true,
        'data': {
          'token': 'mock_jwt_token_${DateTime.now().millisecondsSinceEpoch}',
          'user': {'id': mobile, 'name': 'Mobile User', 'phone': mobile},
        },
      };
    }

    return {'success': false, 'error': 'Invalid OTP'};
  }

  static Future<Map<String, dynamic>> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));

    if (mobile.isNotEmpty) {
      return {
        'success': true,
        'data': {
          'message': 'OTP sent successfully',
          'otpId': 'otp_${DateTime.now().millisecondsSinceEpoch}',
        },
      };
    }

    return {'success': false, 'error': 'Invalid mobile number'};
  }

  static Future<Map<String, dynamic>> logout() async {
    await Future.delayed(const Duration(milliseconds: 500));
    return {
      'success': true,
      'data': {'message': 'Logged out successfully'},
    };
  }

  // File Upload APIs
  static Future<Map<String, dynamic>> uploadFile(
    String filePath, {
    String? originalName,
  }) async {
    return await _uploadWithFallback(filePath, originalName: originalName);
  }

  static Future<Map<String, dynamic>> _uploadWithFallback(
    String filePath, {
    String? originalName,
  }) async {
    var result = await _uploadToUrl(
      baseUrl,
      filePath,
      originalName: originalName,
    );
    if (result['success'] == true) return result;

    for (final url in fallbackUrls) {
      result = await _uploadToUrl(url, filePath, originalName: originalName);
      if (result['success'] == true) return result;
    }

    return result;
  }

  static Future<Map<String, dynamic>> _uploadToUrl(
    String baseUrl,
    String filePath, {
    String? originalName,
  }) async {
    try {
      final uri = Uri.parse('$baseUrl/upload');
      final request = http.MultipartRequest('POST', uri);

      request.headers['Accept'] = 'application/json';

      if (kIsWeb) {
        if (filePath.startsWith('data:')) {
          final parts = filePath.split(',');
          if (parts.length != 2) {
            throw Exception('Invalid data URL format');
          }
          final header = parts[0];
          final mimeType = header.split(':')[1].split(';')[0];
          final bytes = base64Decode(parts[1]);

          request.files.add(
            http.MultipartFile.fromBytes(
              'file',
              bytes,
              filename: originalName ?? 'upload.${_extFromMime(mimeType)}',
            ),
          );
        } else {
          throw Exception(
            'Unsupported web file path format (expected data: URL)',
          );
        }
      } else {
        final file = File(filePath);
        if (!await file.exists()) {
          throw Exception('File does not exist: $filePath');
        }
        request.files.add(
          await http.MultipartFile.fromPath(
            'file',
            filePath,
            filename: originalName ?? file.path.split('/').last,
          ),
        );
      }

      final timeout = _isInAppWebView
          ? const Duration(seconds: 20)
          : const Duration(seconds: 30);

      final streamed = await request.send().timeout(
        timeout,
        onTimeout: () {
          throw Exception('Upload timed out after ${timeout.inSeconds}s');
        },
      );
      final response = await http.Response.fromStream(streamed);

      if (response.statusCode == 200) {
        final data = _safeJson(response.body);
        return {'success': true, 'data': data};
      } else {
        final err = _safeJson(response.body);
        final msg = (err['error'] ?? 'Upload failed').toString();
        return {
          'success': false,
          'error': _isInAppWebView ? 'InAppWebView upload error: $msg' : msg,
        };
      }
    } catch (e) {
      String msg = 'Upload failed: $e';
      if (_isInAppWebView) {
        if (e.toString().contains('timed out')) {
          msg =
              'Upload timed out in InAppWebView. Please check your connection and try again.';
        } else if (e.toString().contains('SocketException') ||
            e.toString().contains('Connection')) {
          msg =
              'Network connection failed in InAppWebView. Ensure the server is reachable.';
        } else {
          msg = 'InAppWebView upload error: $e';
        }
      }
      return {'success': false, 'error': msg};
    }
  }

  // OCR Processing APIs
  static Future<Map<String, dynamic>> processUAEId(String imagePath) async {
    try {
      _logger.info('Processing UAE ID via API');

      // For now, return mock data - in real implementation, this would call OCR service
      await Future.delayed(const Duration(seconds: 2));

      return {
        'success': true,
        'data': {
          'name': 'Sample Name',
          'idNumber': '784-1234-1234567-1',
          'dateOfBirth': '01/01/1990',
          'nationality': 'UAE',
          'issuingDate': '01/01/2020',
          'expiryDate': '01/01/2030',
          'sex': 'M',
          'isValid': true,
        },
      };
    } catch (e) {
      _logger.error('UAE ID processing failed', e);
      return {'success': false, 'error': 'Failed to process UAE ID: $e'};
    }
  }

  static Future<Map<String, dynamic>> processBankDetails(
    String imagePath,
  ) async {
    try {
      _logger.info('Processing bank details via API');

      // For now, return mock data - in real implementation, this would call OCR service
      await Future.delayed(const Duration(seconds: 2));

      return {
        'success': true,
        'data': {
          'accountHolderName': 'Sample Account Holder',
          'accountNumber': '1234567890',
          'ibanNumber': 'AE12345678901234567890123',
          'bankName': 'Emirates NBD',
          'branchName': 'Dubai Main Branch',
          'swiftCode': 'EBILAEAD',
          'isValid': true,
        },
      };
    } catch (e) {
      _logger.error('Bank details processing failed', e);
      return {'success': false, 'error': 'Failed to process bank details: $e'};
    }
  }

  // QR Code APIs
  static Future<Map<String, dynamic>> processQRCode(String qrData) async {
    try {
      _logger.info('Processing QR code via API');

      await Future.delayed(const Duration(milliseconds: 500));

      return {
        'success': true,
        'data': {
          'qrData': qrData,
          'productInfo': {
            'name': 'Sample Product',
            'code': qrData,
            'points': 50,
            'category': 'Construction Material',
          },
          'points': 50,
        },
      };
    } catch (e) {
      _logger.error('QR code processing failed', e);
      return {'success': false, 'error': 'Failed to process QR code: $e'};
    }
  }

  // Analytics APIs
  static Future<Map<String, dynamic>> getBusinessMetrics() async {
    try {
      _logger.info('Fetching business metrics via API');

      await Future.delayed(const Duration(milliseconds: 500));

      return {
        'success': true,
        'data': {
          'totalScans': 1234,
          'redeemedPoints': 856,
          'activeCampaigns': 5,
          'monthlyTargetProgress': 78.0,
          'totalPoints': 2450,
          'monthlyScans': 124,
          'rewardsEarned': 18,
        },
      };
    } catch (e) {
      _logger.error('Failed to fetch business metrics', e);
      return {
        'success': false,
        'error': 'Failed to fetch business metrics: $e',
      };
    }
  }

  static Future<Map<String, dynamic>> getRecentActivities({
    int limit = 10,
  }) async {
    try {
      _logger.info('Fetching recent activities via API');

      await Future.delayed(const Duration(milliseconds: 300));

      return {
        'success': true,
        'data': {
          'activities': [
            {
              'id': '1',
              'title': 'QR Code Scanned',
              'subtitle': 'Birla White Primacoat Primer - +70 points',
              'timestamp': DateTime.now()
                  .subtract(const Duration(hours: 2))
                  .toIso8601String(),
              'iconName': 'qr_code_scanner',
              'colorName': 'successGreen',
              'points': 70,
            },
            {
              'id': '2',
              'title': 'Reward Redeemed',
              'subtitle': 'Amazon Gift Card - 500 points',
              'timestamp': DateTime.now()
                  .subtract(const Duration(days: 1))
                  .toIso8601String(),
              'iconName': 'card_giftcard',
              'colorName': 'warningAmber',
              'points': -500,
            },
            {
              'id': '3',
              'title': 'Level Up',
              'subtitle': 'Reached Gold Member Status',
              'timestamp': DateTime.now()
                  .subtract(const Duration(days: 3))
                  .toIso8601String(),
              'iconName': 'emoji_events',
              'colorName': 'accentBlue',
              'points': 100,
            },
          ],
        },
      };
    } catch (e) {
      _logger.error('Failed to fetch recent activities', e);
      return {
        'success': false,
        'error': 'Failed to fetch recent activities: $e',
      };
    }
  }

  static Future<Map<String, dynamic>> trackQRScan(
    String qrCode, {
    int pointsEarned = 0,
  }) async {
    try {
      _logger.info('Tracking QR scan via API');

      final body = {
        'qrCode': qrCode,
        'pointsEarned': pointsEarned,
        'timestamp': DateTime.now().toIso8601String(),
      };

      return await makeRequest(
        method: 'POST',
        endpoint: '/analytics/track/qr-scan',
        body: body,
      );
    } catch (e) {
      _logger.error('Failed to track QR scan', e);
      return {'success': false, 'error': 'Failed to track QR scan: $e'};
    }
  }

  static Future<Map<String, dynamic>> trackRewardRedemption(
    String rewardName,
    int pointsSpent,
  ) async {
    try {
      _logger.info('Tracking reward redemption via API');

      final body = {
        'rewardName': rewardName,
        'pointsSpent': pointsSpent,
        'timestamp': DateTime.now().toIso8601String(),
      };

      return await makeRequest(
        method: 'POST',
        endpoint: '/analytics/track/reward-redemption',
        body: body,
      );
    } catch (e) {
      _logger.error('Failed to track reward redemption', e);
      return {
        'success': false,
        'error': 'Failed to track reward redemption: $e',
      };
    }
  }

  static Future<Map<String, dynamic>> trackUserInteraction(
    String action, {
    Map<String, dynamic>? metadata,
  }) async {
    try {
      _logger.info('Tracking user interaction via API');

      final body = {
        'action': action,
        'metadata': metadata,
        'timestamp': DateTime.now().toIso8601String(),
      };

      return await makeRequest(
        method: 'POST',
        endpoint: '/analytics/track/user-interaction',
        body: body,
      );
    } catch (e) {
      _logger.error('Failed to track user interaction', e);
      return {
        'success': false,
        'error': 'Failed to track user interaction: $e',
      };
    }
  }

  // Product APIs
  static Future<Map<String, dynamic>> createProduct(
    Map<String, dynamic> productData,
  ) async {
    try {
      _logger.info('Creating product via API');

      return await makeRequest(
        method: 'POST',
        endpoint: '/products',
        body: productData,
      );
    } catch (e) {
      _logger.error('Failed to create product', e);
      return {'success': false, 'error': 'Failed to create product: $e'};
    }
  }

  static Future<Map<String, dynamic>> updateProduct(
    String productId,
    Map<String, dynamic> productData,
  ) async {
    try {
      _logger.info('Updating product via API');

      return await makeRequest(
        method: 'PUT',
        endpoint: '/products/$productId',
        body: productData,
      );
    } catch (e) {
      _logger.error('Failed to update product', e);
      return {'success': false, 'error': 'Failed to update product: $e'};
    }
  }

  static Future<Map<String, dynamic>> getProducts({
    int? limit,
    int? offset,
  }) async {
    try {
      _logger.info('Fetching products via API');

      var endpoint = '/products';
      if (limit != null || offset != null) {
        endpoint += '?';
        if (limit != null) endpoint += 'limit=$limit&';
        if (offset != null) endpoint += 'offset=$offset&';
        endpoint = endpoint.substring(0, endpoint.length - 1);
      }

      return await makeRequest(method: 'GET', endpoint: endpoint);
    } catch (e) {
      _logger.error('Failed to fetch products', e);
      return {'success': false, 'error': 'Failed to fetch products: $e'};
    }
  }

  // Registration APIs
  static Future<Map<String, dynamic>> registerUser(
    Map<String, dynamic> userData,
  ) async {
    try {
      _logger.info('Registering user via API');

      return await makeRequest(
        method: 'POST',
        endpoint: '/auth/register',
        body: userData,
      );
    } catch (e) {
      _logger.error('Failed to register user', e);
      return {'success': false, 'error': 'Failed to register user: $e'};
    }
  }

  static Future<Map<String, dynamic>> updateUserProfile(
    String userId,
    Map<String, dynamic> profileData,
  ) async {
    try {
      _logger.info('Updating user profile via API');

      return await makeRequest(
        method: 'PUT',
        endpoint: '/users/$userId/profile',
        body: profileData,
      );
    } catch (e) {
      _logger.error('Failed to update user profile', e);
      return {'success': false, 'error': 'Failed to update user profile: $e'};
    }
  }

  // Quality Control APIs
  static Future<Map<String, dynamic>> submitQualityReport(
    Map<String, dynamic> reportData,
  ) async {
    try {
      _logger.info('Submitting quality report via API');

      return await makeRequest(
        method: 'POST',
        endpoint: '/quality-control/reports',
        body: reportData,
      );
    } catch (e) {
      _logger.error('Failed to submit quality report', e);
      return {'success': false, 'error': 'Failed to submit quality report: $e'};
    }
  }

  static Future<Map<String, dynamic>> getQualityReports({
    String? status,
    int? limit,
  }) async {
    try {
      _logger.info('Fetching quality reports via API');

      var endpoint = '/quality-control/reports';
      if (status != null || limit != null) {
        endpoint += '?';
        if (status != null) endpoint += 'status=$status&';
        if (limit != null) endpoint += 'limit=$limit&';
        endpoint = endpoint.substring(0, endpoint.length - 1);
      }

      return await makeRequest(method: 'GET', endpoint: endpoint);
    } catch (e) {
      _logger.error('Failed to fetch quality reports', e);
      return {'success': false, 'error': 'Failed to fetch quality reports: $e'};
    }
  }

  // Retail APIs
  static Future<Map<String, dynamic>> registerRetailer(
    Map<String, dynamic> retailerData,
  ) async {
    try {
      _logger.info('Registering retailer via API');

      return await makeRequest(
        method: 'POST',
        endpoint: '/retail/register',
        body: retailerData,
      );
    } catch (e) {
      _logger.error('Failed to register retailer', e);
      return {'success': false, 'error': 'Failed to register retailer: $e'};
    }
  }

  static Future<Map<String, dynamic>> submitRetailEntry(
    Map<String, dynamic> entryData,
  ) async {
    try {
      _logger.info('Submitting retail entry via API');

      return await makeRequest(
        method: 'POST',
        endpoint: '/retail/entries',
        body: entryData,
      );
    } catch (e) {
      _logger.error('Failed to submit retail entry', e);
      return {'success': false, 'error': 'Failed to submit retail entry: $e'};
    }
  }

  // Contractor Registration APIs
  static Future<Map<String, dynamic>> registerContractor(
    Map<String, dynamic> contractorData,
  ) async {
    try {
      _logger.info('Registering contractor via API');

      return await makeRequest(
        method: 'POST',
        endpoint: '/api/Contractor/register',
        body: contractorData,
      );
    } catch (e) {
      _logger.error('Failed to register contractor', e);
      return {'success': false, 'error': 'Failed to register contractor: $e'};
    }
  }

  static Future<Map<String, dynamic>> uploadContractorDocument({
    required String filePath,
    required String documentType,
    String? originalName,
  }) async {
    try {
      _logger.info('Uploading contractor document via API');

      final uri = Uri.parse('$baseUrl/api/Contractor/upload-document');
      final request = http.MultipartRequest('POST', uri);

      request.headers['Accept'] = 'application/json';
      request.fields['documentType'] = documentType;

      if (kIsWeb) {
        if (filePath.startsWith('data:')) {
          final parts = filePath.split(',');
          if (parts.length != 2) {
            throw Exception('Invalid data URL format');
          }
          final header = parts[0];
          final mimeType = header.split(':')[1].split(';')[0];
          final bytes = base64Decode(parts[1]);

          request.files.add(
            http.MultipartFile.fromBytes(
              'file',
              bytes,
              filename: originalName ?? 'document.${_extFromMime(mimeType)}',
            ),
          );
        } else {
          throw Exception(
            'Unsupported web file path format (expected data: URL)',
          );
        }
      } else {
        final file = File(filePath);
        if (!await file.exists()) {
          throw Exception('File does not exist: $filePath');
        }
        request.files.add(
          await http.MultipartFile.fromPath(
            'file',
            filePath,
            filename: originalName ?? file.path.split('/').last,
          ),
        );
      }

      final timeout = _isInAppWebView
          ? const Duration(seconds: 20)
          : const Duration(seconds: 30);

      final streamed = await request.send().timeout(
        timeout,
        onTimeout: () {
          throw Exception('Upload timed out after ${timeout.inSeconds}s');
        },
      );
      final response = await http.Response.fromStream(streamed);

      if (response.statusCode == 200) {
        final data = _safeJson(response.body);
        return {'success': true, 'data': data};
      } else {
        final err = _safeJson(response.body);
        final msg = (err['error'] ?? 'Upload failed').toString();
        return {
          'success': false,
          'error': _isInAppWebView ? 'InAppWebView upload error: $msg' : msg,
        };
      }
    } catch (e) {
      _logger.error('Failed to upload contractor document', e);
      String msg = 'Upload failed: $e';
      if (_isInAppWebView) {
        if (e.toString().contains('timed out')) {
          msg =
              'Upload timed out in InAppWebView. Please check your connection and try again.';
        } else if (e.toString().contains('SocketException') ||
            e.toString().contains('Connection')) {
          msg =
              'Network connection failed in InAppWebView. Ensure the server is reachable.';
        } else {
          msg = 'InAppWebView upload error: $e';
        }
      }
      return {'success': false, 'error': msg};
    }
  }

  static Future<Map<String, dynamic>> getContractorTypes() async {
    try {
      _logger.info('Fetching contractor types via API');

      return await makeRequest(
        method: 'GET',
        endpoint: '/api/Contractor/contractor-types',
      );
    } catch (e) {
      _logger.error('Failed to fetch contractor types', e);
      return {
        'success': false,
        'error': 'Failed to fetch contractor types: $e',
      };
    }
  }

  static Future<Map<String, dynamic>> getEmiratesList() async {
    try {
      _logger.info('Fetching emirates list via API');

      return await makeRequest(
        method: 'GET',
        endpoint: '/api/Contractor/emirates-list',
      );
    } catch (e) {
      _logger.error('Failed to fetch emirates list', e);
      return {'success': false, 'error': 'Failed to fetch emirates list: $e'};
    }
  }

  // Health Check
  static Future<Map<String, dynamic>> testConnectivity() async {
    try {
      final resp = await http
          .get(
            Uri.parse('$baseUrl/health'),
            headers: {'Accept': 'application/json'},
          )
          .timeout(
            const Duration(seconds: 10),
            onTimeout: () => throw Exception('Timeout'),
          );

      return {
        'success': resp.statusCode == 200,
        'statusCode': resp.statusCode,
        'data': _safeJson(resp.body),
      };
    } catch (e) {
      _logger.error('Connectivity test failed', e);
      return {'success': false, 'error': 'Connectivity test failed: $e'};
    }
  }

  // Utility methods
  static String _extFromMime(String mime) {
    switch (mime) {
      case 'image/jpeg':
        return 'jpg';
      case 'image/png':
        return 'png';
      case 'image/gif':
        return 'gif';
      case 'image/webp':
        return 'webp';
      case 'application/pdf':
        return 'pdf';
      case 'text/plain':
        return 'txt';
      default:
        return 'bin';
    }
  }

  static Map<String, dynamic> _safeJson(String body) {
    try {
      final parsed = json.decode(body);
      return parsed is Map<String, dynamic>
          ? parsed
          : <String, dynamic>{'raw': parsed};
    } catch (_) {
      return <String, dynamic>{'raw': body};
    }
  }
}






































<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <system.webServer>
    <!-- Enable CORS with credentials support -->
    <httpProtocol>
      <customHeaders>
        <!-- Production domain for RAK application -->
        <add name="Access-Control-Allow-Origin" value="https://rak.birlawhite.com" />
        <add name="Access-Control-Allow-Credentials" value="true" />
        <add name="Access-Control-Allow-Methods" value="GET, POST, PUT, DELETE, OPTIONS" />
        <add name="Access-Control-Allow-Headers" value="Origin, X-Requested-With, Content-Type, Accept, Authorization" />
        <add name="Access-Control-Max-Age" value="3600" />
      </customHeaders>
    </httpProtocol>

    <!-- Handle preflight OPTIONS requests -->
    <handlers>
      <add name="OptionsHandler" verb="OPTIONS" path="*"
           type="System.Web.DefaultHttpHandler"
           resourceType="Unspecified"
           requireAccess="None" />
    </handlers>

    <!-- Security headers -->
    <httpHeaders>
      <add name="X-Content-Type-Options" value="nosniff" />
      <add name="X-Frame-Options" value="SAMEORIGIN" />
      <add name="X-XSS-Protection" value="1; mode=block" />
      <add name="Referrer-Policy" value="strict-origin-when-cross-origin" />
      <add name="Permissions-Policy" value="geolocation=(self), camera=(self), microphone=(self)" />
    </httpHeaders>

    <!-- Ensure cookies are properly handled -->
    <httpCookies sameSite="Lax" requireSSL="true" />

    <!-- Default document -->
    <defaultDocument>
      <files>
        <clear />
        <add value="index.html" />
      </files>
    </defaultDocument>

    <!-- MIME types for Flutter web assets -->
    <staticContent>
      <mimeMap fileExtension=".js" mimeType="application/javascript" />
      <mimeMap fileExtension=".json" mimeType="application/json" />
      <mimeMap fileExtension=".wasm" mimeType="application/wasm" />
      <mimeMap fileExtension=".br" mimeType="application/octet-stream" />
      <mimeMap fileExtension=".gz" mimeType="application/octet-stream" />
    </staticContent>

    <!-- URL Rewrite for SPA routing -->
    <rewrite>
      <rules>
        <rule name="Angular Routes" stopProcessing="true">
          <match url=".*" />
          <conditions logicalGrouping="MatchAll">
            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
            <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
            <add input="{REQUEST_URI}" pattern="^/(api)" negate="true" />
          </conditions>
          <action type="Rewrite" url="/" />
        </rule>
      </rules>
    </rewrite>
  </system.webServer>

  <!-- For ASP.NET applications, configure session and authentication -->
  <system.web>
    <!-- Session configuration for secure cookies -->
    <httpCookies requireSSL="true" sameSite="Lax" />

    <!-- Machine key for secure cookie encryption (generate your own) -->
    <!--
    <machineKey
      validationKey="[GENERATE_YOUR_OWN_VALIDATION_KEY]"
      decryptionKey="[GENERATE_YOUR_OWN_DECRYPTION_KEY]"
      validation="HMACSHA256"
      decryption="AES" />
    -->

    <!-- Authentication configuration -->
    <authentication mode="None" />

    <!-- Session state configuration -->
    <sessionState
      cookieName="ASP.NET_SessionId"
      cookieSecure="true"
      cookieSameSite="Lax"
      cookieTimeout="60"
      regenerateExpiredSessionId="true" />
  </system.web>
</configuration>
