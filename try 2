import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import '../models/auth_models.dart';
import '../utils/app_logger.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client.send(request).timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      // Extract cookies from response headers for future requests
      final cookieHeader = response.headers['set-cookie'];
      if (cookieHeader != null) {
        _logger.debug('Received cookies: $cookieHeader');
      }

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    final result = await authenticateUser(userID: userId, password: password);
    if (result['success'] == true) {
      final loginResponse = result['data'] as LoginResponse;
      // Create a new UserData instance with the userID preserved
      final userDataWithId = UserData(
        emplName: loginResponse.data.emplName,
        areaCode: loginResponse.data.areaCode,
        roles: loginResponse.data.roles,
        pages: loginResponse.data.pages,
        userID: userId, // Preserve the original userID from login
      );
      await AuthManager.setUser(userDataWithId);
      return true;
    }
    return false;
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    // Try to logout from server first
    final serverLogout = await logoutFromServer();
    if (!serverLogout['success']) {
      _logger.warning('Server logout failed, clearing local session anyway');
    }

    await AuthManager.clearUser();
    await Future.delayed(const Duration(milliseconds: 500));
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }

  // Session validation endpoint
  static Future<Map<String, dynamic>> validateSession() async {
    try {
      _logger.info('Validating user session');

      final uri = Uri.parse('$baseUrl/auth/me');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .get(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Session validation response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Session validation failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Session validation error', e);
      return {
        'success': false,
        'error': 'Network error during session validation',
        'statusCode': 0,
      };
    }
  }

  // Token refresh endpoint
  static Future<Map<String, dynamic>> refreshToken() async {
    try {
      _logger.info('Refreshing access token');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  // Enhanced logout with server-side session clearing
  static Future<Map<String, dynamic>> logoutFromServer() async {
    try {
      _logger.info('Logging out from server');

      final uri = Uri.parse('$baseUrl/auth/logout');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Server logout response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Server logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout',
        'statusCode': 0,
      };
    }
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);
  static bool _isInitialized = false;

  // SharedPreferences keys
  static const String _userDataKey = 'user_data';
  static const String _authTokenKey = 'auth_token';
  static const String _loginTimeKey = 'login_time';
  static const String _sessionExpiryKey = 'session_expiry';

  // Session duration (24 hours)
  static const Duration _sessionDuration = Duration(hours: 24);

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  static Future<void> initialize() async {
    if (_isInitialized) return;

    try {
      final prefs = await SharedPreferences.getInstance();

      // Check if session has expired
      final sessionExpiryString = prefs.getString(_sessionExpiryKey);
      if (sessionExpiryString != null) {
        final sessionExpiry = DateTime.parse(sessionExpiryString);
        if (DateTime.now().isAfter(sessionExpiry)) {
          // Session expired, clear data
          await _clearStoredSession();
          _isInitialized = true;
          return;
        }
      }

      // Restore user session
      final userDataString = prefs.getString(_userDataKey);
      final authToken = prefs.getString(_authTokenKey);

      if (userDataString != null) {
        final userDataMap = jsonDecode(userDataString) as Map<String, dynamic>;
        _currentUser = UserData.fromJson(userDataMap);
        _authToken = authToken;
        _notifyAuthChanged();
      }
    } catch (e) {
      AppLogger().error('Failed to initialize AuthManager', e);
      await _clearStoredSession();
    }

    _isInitialized = true;
  }

  static Future<void> setUser(UserData userData, {String? token}) async {
    _currentUser = userData;
    _authToken = token;

    // Store session data
    await _storeSession(userData, token);
    _notifyAuthChanged();
  }

  static Future<void> clearUser() async {
    _currentUser = null;
    _authToken = null;

    // Clear stored session
    await _clearStoredSession();
    _notifyAuthChanged();
  }

  static Future<void> _storeSession(UserData userData, String? token) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final loginTime = DateTime.now();
      final sessionExpiry = loginTime.add(_sessionDuration);

      await prefs.setString(_userDataKey, jsonEncode(userData.toJson()));
      if (token != null) {
        await prefs.setString(_authTokenKey, token);
      }
      await prefs.setString(_loginTimeKey, loginTime.toIso8601String());
      await prefs.setString(_sessionExpiryKey, sessionExpiry.toIso8601String());
    } catch (e) {
      AppLogger().error('Failed to store session', e);
    }
  }

  static Future<void> _clearStoredSession() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_userDataKey);
      await prefs.remove(_authTokenKey);
      await prefs.remove(_loginTimeKey);
      await prefs.remove(_sessionExpiryKey);
    } catch (e) {
      AppLogger().error('Failed to clear stored session', e);
    }
  }

  static Future<bool> isSessionValid() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final sessionExpiryString = prefs.getString(_sessionExpiryKey);

      if (sessionExpiryString == null) return false;

      final sessionExpiry = DateTime.parse(sessionExpiryString);
      return DateTime.now().isBefore(sessionExpiry);
    } catch (e) {
      AppLogger().error('Failed to check session validity', e);
      return false;
    }
  }

  static Future<void> extendSession() async {
    if (_currentUser != null) {
      await _storeSession(_currentUser!, _authToken);
    }
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}




































import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'dart:async';
import '../core/services/auth_service.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with TickerProviderStateMixin {
  late AnimationController _fadeController;
  late AnimationController _scaleController;
  late AnimationController _slideController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;
  late Animation<Offset> _slideAnimation;
  late AnimationController _particleController;
  late Animation<double> _particleAnimation;

  @override
  void initState() {
    super.initState();

    // Initialize animation controllers
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );

    _slideController = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );

    _particleController = AnimationController(
      duration: const Duration(milliseconds: 3000),
      vsync: this,
    );

    // Define animations
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut),
    );

    _scaleAnimation = Tween<double>(begin: 0.5, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut),
    );

    _slideAnimation =
        Tween<Offset>(begin: const Offset(0, 0.5), end: Offset.zero).animate(
          CurvedAnimation(parent: _slideController, curve: Curves.easeOutCubic),
        );

    _particleAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _particleController, curve: Curves.easeInOut),
    );

    // Start animations
    _fadeController.forward();
    _scaleController.forward();
    _slideController.forward();
    _particleController.repeat();

    // Initialize auth and navigate after splash screen
    Timer(const Duration(milliseconds: 3000), () async {
      if (mounted) {
        await _initializeAndNavigate();
      }
    });
  }

  Future<void> _initializeAndNavigate() async {
    try {
      // Initialize the AuthManager to restore any existing session
      await AuthManager.initialize();

      if (mounted) {
        // Check if user is logged in after initialization
        if (AuthManager.isLoggedIn) {
          // User has a valid session, go to home
          context.go('/home');
        } else {
          // No valid session, go to login
          context.go('/login-password');
        }
      }
    } catch (e) {
      // If there's an error, default to login screen
      if (mounted) {
        context.go('/login-password');
      }
    }
  }

  @override
  void dispose() {
    _fadeController.dispose();
    _scaleController.dispose();
    _slideController.dispose();
    _particleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: Stack(
        children: [
          // Background gradient
          Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [
                  const Color(0xFFFFFFFF),
                  const Color(0xFFF5F7FA),
                  const Color(0xFFE9ECEF),
                ],
              ),
            ),
          ),

          // Animated particles background
          AnimatedBuilder(
            animation: _particleAnimation,
            builder: (context, child) {
              return CustomPaint(
                painter: ParticlePainter(_particleAnimation.value),
                size: Size.infinite,
              );
            },
          ),

          // Main content
          Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Logo/Icon container
                // Logo/Icon container
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: ScaleTransition(
                    scale: _scaleAnimation,
                    child: Container(
                      width: 140,
                      height: 140,
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                          colors: [
                            const Color(0xFF2C5282),
                            const Color(0xFF2B6CB0),
                            const Color(0xFF3182CE),
                          ],
                        ),
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.3),
                            blurRadius: 20,
                            offset: const Offset(0, 10),
                          ),
                          BoxShadow(
                            color: const Color(0xFF3182CE).withOpacity(0.4),
                            blurRadius: 25,
                            offset: const Offset(0, 5),
                          ),
                        ],
                      ),
                      padding: const EdgeInsets.all(8),
                      child: Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.1),
                              blurRadius: 8,
                              offset: const Offset(0, 3),
                            ),
                          ],
                        ),
                        child: ClipOval(
                          child: Image.asset(
                            "assets/images/rak_logo.jpg",
                            fit: BoxFit.cover,
                            errorBuilder: (context, error, stackTrace) {
                              return const Icon(
                                Icons.business,
                                color: Color(0xFF2C5282),
                                size: 60,
                              );
                            },
                          ),
                        ),
                      ),
                    ),
                  ),
                ),

                const SizedBox(height: 40),

                // Company name
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: SlideTransition(
                    position: _slideAnimation,
                    child: Column(
                      children: [
                        Text(
                          'RAK',
                          style: TextStyle(
                            fontSize: 48,
                            fontWeight: FontWeight.bold,
                            color: const Color(0xFF2C5282),
                            letterSpacing: 3,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'WHITE CEMENT',
                          style: TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.w600,
                            color: const Color(0xFF4A5568),
                            letterSpacing: 2,
                          ),
                        ),
                        const SizedBox(height: 16),
                        Container(
                          width: 60,
                          height: 3,
                          decoration: BoxDecoration(
                            gradient: LinearGradient(
                              colors: [
                                const Color(0xFF3182CE),
                                const Color(0xFF2B6CB0),
                              ],
                            ),
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Construction Materials',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w400,
                            color: const Color(0xFF718096),
                            letterSpacing: 1,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 60),

                // Loading indicator
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: Column(
                    children: [
                      SizedBox(
                        width: 40,
                        height: 40,
                        child: CircularProgressIndicator(
                          strokeWidth: 3,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            const Color(0xFF3182CE),
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'Loading...',
                        style: TextStyle(
                          fontSize: 14,
                          color: const Color(0xFF718096),
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),

          // Bottom footer
          Positioned(
            bottom: 30,
            left: 0,
            right: 0,
            child: FadeTransition(
              opacity: _fadeAnimation,
              child: Column(
                children: [
                  Text(
                    'Est. 1980',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Ras Al Khaimah, United Arab Emirates',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w400,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ParticlePainter extends CustomPainter {
  final double animationValue;

  ParticlePainter(this.animationValue);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = Colors.blue.withOpacity(0.1);

    // Create floating particles
    for (int i = 0; i < 20; i++) {
      final x = (size.width / 20) * i + (animationValue * 50) % size.width;
      final y =
          size.height * 0.5 +
          (animationValue * 100 + i * 30) % size.height -
          size.height * 0.25;

      canvas.drawCircle(Offset(x, y), 2 + (animationValue * 2) % 3, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

