name: rak_web
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.8.1

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter
  flutter_web_plugins:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8

  # Architecture dependencies
  provider: ^6.1.2
  go_router: ^14.2.0
  get_it: ^7.7.0
  equatable: ^2.0.5
  dartz: ^0.10.1

  # Device identification
  device_info_plus: ^10.1.2
  crypto: ^3.0.3

  # Existing dependencies
  image_picker: ^0.8.7+4
  google_mlkit_text_recognition: ^0.7.0
  file_picker: ^8.0.0+1
  http: ^1.1.0
  tesseract_ocr: ^0.5.0
  universal_html: ^2.2.4
  qr_code_scanner_plus: ^2.0.10+1
  qr_flutter: ^4.1.0
  shared_preferences: ^2.5.3
  flutter_inappwebview: ^6.1.5
  permission_handler: ^11.3.1
  web: ^1.1.0
  pdfx: ^2.6.0
  intl: ^0.20.2




dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  assets:
    - assets/images/

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package





































import 'dart:convert';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:crypto/crypto.dart';
import '../models/auth_models.dart';
import '../utils/app_logger.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';
  static const String autoLoginEndpoint = '/api/Auth/auto-login';
  static const String logoutEndpoint = '/api/Auth/logout';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client
          .send(request)
          .timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      // Extract cookies from response headers for future requests
      final cookieHeader = response.headers['set-cookie'];
      if (cookieHeader != null) {
        _logger.debug('Received cookies: $cookieHeader');
      }

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    try {
      print('üîê Starting login for userId: "$userId"');

      // First authenticate with backend to get user data
      final result = await authenticateUser(userID: userId, password: password);
      print('üîç Backend auth result: ${result['success']}');
      if (result['success'] == true) {
        final loginResponse = result['data'] as LoginResponse;

        print('üìä Backend login successful, generating device ID...');

        // Create user data
        final userDataWithId = UserData(
          emplName: loginResponse.data.emplName,
          areaCode: loginResponse.data.areaCode,
          roles: loginResponse.data.roles,
          pages: loginResponse.data.pages,
          userID: userId,
        );

        // Generate device-specific unique ID
        final deviceId = await _getDeviceUniqueId();
        print('üîë Generated device ID: $deviceId');

        // Store user data and device ID locally for autologin
        await _storeUserDataLocally(userDataWithId, deviceId);
        print('üì± Device ID stored for autologin');

        // Set user in AuthManager
        AuthManager.setUser(userDataWithId);
        return true;
      } else {
        print('‚ùå Backend authentication failed: ${result['error']}');
      }
      return false;
    } catch (e) {
      _logger.error('Login error', e);
      return false;
    }
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    try {
      // Get device ID before clearing
      final prefs = await SharedPreferences.getInstance();
      final deviceId = prefs.getString('device_id');

      // Call backend logout endpoint if we have a device ID
      if (deviceId != null) {
        final backendLogout = await _performBackendLogout(deviceId);
        if (backendLogout['success']) {
          print('‚úÖ Backend logout successful');
        } else {
          print('‚ö†Ô∏è Backend logout failed: ${backendLogout['error']}');
        }
      }

      // Clear stored user data
      await _clearStoredUserData();

      // Clear user from AuthManager
      AuthManager.clearUser();

      await Future.delayed(const Duration(milliseconds: 500));
      print('‚úÖ Complete logout successful');
    } catch (e) {
      print('‚ùå Logout error: $e');
      // Still clear local data even if logout fails
      await _clearStoredUserData();
      AuthManager.clearUser();
    }
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }

  // Session validation endpoint
  static Future<Map<String, dynamic>> validateSession() async {
    try {
      _logger.info('Validating user session');

      final uri = Uri.parse('$baseUrl/auth/me');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .get(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Session validation response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Session validation failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Session validation error', e);
      return {
        'success': false,
        'error': 'Network error during session validation',
        'statusCode': 0,
      };
    }
  }

  // Token refresh endpoint
  static Future<Map<String, dynamic>> refreshToken() async {
    try {
      _logger.info('Refreshing access token');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  // Enhanced logout with server-side session clearing
  static Future<Map<String, dynamic>> logoutFromServer() async {
    try {
      _logger.info('Logging out from server');

      final uri = Uri.parse('$baseUrl/auth/logout');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Server logout response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Server logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout',
        'statusCode': 0,
      };
    }
  }

  // Generate device-specific unique ID
  static Future<String> _getDeviceUniqueId() async {
    try {
      final deviceInfo = DeviceInfoPlugin();
      String deviceId = '';

      if (kIsWeb) {
        final webInfo = await deviceInfo.webBrowserInfo;
        // Create a unique identifier based on browser info
        final browserData =
            '${webInfo.browserName}_${webInfo.platform}_${webInfo.userAgent}';
        final bytes = utf8.encode(browserData);
        final hash = sha256.convert(bytes);
        deviceId = 'WEB_${hash.toString().substring(0, 16)}';
      } else {
        // For mobile platforms (if needed later)
        deviceId = 'MOBILE_${DateTime.now().millisecondsSinceEpoch}';
      }

      // Add timestamp for session uniqueness
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      return '${deviceId}_$timestamp';
    } catch (e) {
      // Fallback if device info fails
      final random = Random().nextInt(999999);
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      return 'FALLBACK_${timestamp}_$random';
    }
  }

  // Store user data locally for autologin
  static Future<void> _storeUserDataLocally(
    UserData userData, [
    String? deviceId,
  ]) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('user_data', jsonEncode(userData.toJson()));
      await prefs.setString('user_id', userData.userID ?? '');
      await prefs.setBool('is_logged_in', true);

      if (deviceId != null) {
        await prefs.setString('device_id', deviceId);
      }

      print('üìä User data stored locally for autologin');
    } catch (e) {
      print('‚ùå Failed to store user data locally: $e');
    }
  }

  // Clear stored user data
  static Future<void> _clearStoredUserData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('user_data');
      await prefs.remove('user_id');
      await prefs.remove('device_id');
      await prefs.setBool('is_logged_in', false);
      print('üóëÔ∏è Stored user data cleared');
    } catch (e) {
      print('‚ùå Failed to clear stored user data: $e');
    }
  }

  // Check for autologin on app start
  static Future<bool> checkAutologin() async {
    try {
      print('üîÑ Checking for autologin...');

      // Get stored data
      final prefs = await SharedPreferences.getInstance();
      final isLoggedIn = prefs.getBool('is_logged_in') ?? false;
      final deviceId = prefs.getString('device_id');

      if (!isLoggedIn || deviceId == null) {
        print('‚ùå No stored session or device ID found');
        return false;
      }

      print('üîë Found stored device ID: $deviceId');

      // Try auto-login with backend using device ID
      final autoLoginResult = await _performBackendAutoLogin(deviceId);

      if (autoLoginResult['success'] == true) {
        final userData = autoLoginResult['userData'] as UserData;

        // Update stored user data (in case roles/pages changed)
        await _storeUserDataLocally(userData, deviceId);

        // Set user in AuthManager
        AuthManager.setUser(userData);
        print(
          '‚úÖ Backend autologin successful for user: ${userData.userID ?? "unknown"}',
        );
        return true;
      } else {
        print('‚ùå Backend autologin failed: ${autoLoginResult['error']}');
        await _clearStoredUserData();
        return false;
      }
    } catch (e) {
      print('‚ùå Autologin failed: $e');
      await _clearStoredUserData();
      return false;
    }
  }

  // Backend auto-login using device ID
  static Future<Map<String, dynamic>> _performBackendAutoLogin(
    String deviceId,
  ) async {
    try {
      _logger.info('Attempting backend auto-login with device ID');

      final uri = Uri.parse('$baseUrl$autoLoginEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode({'appRegId': deviceId});

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Auto-login response status: ${response.statusCode}');
      _logger.debug('Auto-login response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;
        final data = responseData['data'] as Map<String, dynamic>;

        // Create UserData from backend response
        final userData = UserData(
          emplName: data['emplName'] as String,
          areaCode: data['areaCode'] as String,
          roles: (data['roles'] as List<dynamic>).cast<String>(),
          pages: (data['pages'] as List<dynamic>).cast<String>(),
          userID: data['userID'] as String,
        );

        _logger.info('Backend auto-login successful');
        return {
          'success': true,
          'userData': userData,
          'statusCode': response.statusCode,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Auto-login failed';

        _logger.warning('Backend auto-login failed: $errorMessage');
        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Backend auto-login error', e);
      return {
        'success': false,
        'error': 'Network error during auto-login: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  // Backend logout using device ID
  static Future<Map<String, dynamic>> _performBackendLogout(
    String deviceId,
  ) async {
    try {
      _logger.info('Attempting backend logout with device ID');

      final uri = Uri.parse('$baseUrl$logoutEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode({'appRegId': deviceId});

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Backend logout response status: ${response.statusCode}');
      _logger.debug('Backend logout response body: ${response.body}');

      if (response.statusCode == 200) {
        _logger.info('Backend logout successful');
        return {'success': true, 'statusCode': response.statusCode};
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Backend logout failed';

        _logger.warning('Backend logout failed: $errorMessage');
        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Backend logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;


  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;

    print('üë§ User set in AuthManager: ${userData.userID ?? "unknown"}');
    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;

    print('üóëÔ∏è User cleared from AuthManager');
    _notifyAuthChanged();
  }


  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}





































import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'dart:async';
import '../core/services/auth_service.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with TickerProviderStateMixin {
  late AnimationController _fadeController;
  late AnimationController _scaleController;
  late AnimationController _slideController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;
  late Animation<Offset> _slideAnimation;
  late AnimationController _particleController;
  late Animation<double> _particleAnimation;

  @override
  void initState() {
    super.initState();

    // Initialize animation controllers
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );

    _slideController = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );

    _particleController = AnimationController(
      duration: const Duration(milliseconds: 3000),
      vsync: this,
    );

    // Define animations
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut),
    );

    _scaleAnimation = Tween<double>(begin: 0.5, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut),
    );

    _slideAnimation =
        Tween<Offset>(begin: const Offset(0, 0.5), end: Offset.zero).animate(
          CurvedAnimation(parent: _slideController, curve: Curves.easeOutCubic),
        );

    _particleAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _particleController, curve: Curves.easeInOut),
    );

    // Start animations
    _fadeController.forward();
    _scaleController.forward();
    _slideController.forward();
    _particleController.repeat();

    // Initialize auth state routing
    _initializeAuthRouting();
  }

  void _initializeAuthRouting() {
    // Check Flutter auth state after animation
    Timer(const Duration(milliseconds: 1500), () {
      if (mounted) {
        if (AuthManager.isLoggedIn) {
          _navigateToHome();
        } else {
          _navigateToLogin();
        }
      }
    });
  }


  void _navigateToLogin() {
    if (mounted) {
      context.go('/login-password');
    }
  }

  void _navigateToHome() {
    if (mounted) {
      context.go('/home');
    }
  }

  @override
  void dispose() {
    _fadeController.dispose();
    _scaleController.dispose();
    _slideController.dispose();
    _particleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: Stack(
        children: [
          // Background gradient
          Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [
                  const Color(0xFFFFFFFF),
                  const Color(0xFFF5F7FA),
                  const Color(0xFFE9ECEF),
                ],
              ),
            ),
          ),

          // Animated particles background
          AnimatedBuilder(
            animation: _particleAnimation,
            builder: (context, child) {
              return CustomPaint(
                painter: ParticlePainter(_particleAnimation.value),
                size: Size.infinite,
              );
            },
          ),

          // Main content
          Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Logo/Icon container
                // Logo/Icon container
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: ScaleTransition(
                    scale: _scaleAnimation,
                    child: Container(
                      width: 140,
                      height: 140,
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                          colors: [
                            const Color(0xFF2C5282),
                            const Color(0xFF2B6CB0),
                            const Color(0xFF3182CE),
                          ],
                        ),
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.3),
                            blurRadius: 20,
                            offset: const Offset(0, 10),
                          ),
                          BoxShadow(
                            color: const Color(0xFF3182CE).withOpacity(0.4),
                            blurRadius: 25,
                            offset: const Offset(0, 5),
                          ),
                        ],
                      ),
                      padding: const EdgeInsets.all(8),
                      child: Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.1),
                              blurRadius: 8,
                              offset: const Offset(0, 3),
                            ),
                          ],
                        ),
                        child: ClipOval(
                          child: Image.asset(
                            "assets/images/rak_logo.jpg",
                            fit: BoxFit.cover,
                            errorBuilder: (context, error, stackTrace) {
                              return const Icon(
                                Icons.business,
                                color: Color(0xFF2C5282),
                                size: 60,
                              );
                            },
                          ),
                        ),
                      ),
                    ),
                  ),
                ),

                const SizedBox(height: 40),

                // Company name
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: SlideTransition(
                    position: _slideAnimation,
                    child: Column(
                      children: [
                        Text(
                          'RAK',
                          style: TextStyle(
                            fontSize: 48,
                            fontWeight: FontWeight.bold,
                            color: const Color(0xFF2C5282),
                            letterSpacing: 3,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'WHITE CEMENT',
                          style: TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.w600,
                            color: const Color(0xFF4A5568),
                            letterSpacing: 2,
                          ),
                        ),
                        const SizedBox(height: 16),
                        Container(
                          width: 60,
                          height: 3,
                          decoration: BoxDecoration(
                            gradient: LinearGradient(
                              colors: [
                                const Color(0xFF3182CE),
                                const Color(0xFF2B6CB0),
                              ],
                            ),
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Construction Materials',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w400,
                            color: const Color(0xFF718096),
                            letterSpacing: 1,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 60),

                // Loading indicator
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: Column(
                    children: [
                      SizedBox(
                        width: 40,
                        height: 40,
                        child: CircularProgressIndicator(
                          strokeWidth: 3,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            const Color(0xFF3182CE),
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'Loading...',
                        style: TextStyle(
                          fontSize: 14,
                          color: const Color(0xFF718096),
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),

          // Bottom footer
          Positioned(
            bottom: 30,
            left: 0,
            right: 0,
            child: FadeTransition(
              opacity: _fadeAnimation,
              child: Column(
                children: [
                  Text(
                    'Est. 1980',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Ras Al Khaimah, United Arab Emirates',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w400,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ParticlePainter extends CustomPainter {
  final double animationValue;

  ParticlePainter(this.animationValue);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = Colors.blue.withOpacity(0.1);

    // Create floating particles
    for (int i = 0; i < 20; i++) {
      final x = (size.width / 20) * i + (animationValue * 50) % size.width;
      final y =
          size.height * 0.5 +
          (animationValue * 100 + i * 30) % size.height -
          size.height * 0.25;

      canvas.drawCircle(Offset(x, y), 2 + (animationValue * 2) % 3, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}
