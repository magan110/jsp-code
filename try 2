import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/auth_models.dart';
import '../utils/app_logger.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';
  static const String autoLoginEndpoint = '/api/Auth/auto-login';
  static const String logoutEndpoint = '/api/Auth/logout';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client
          .send(request)
          .timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      // Extract cookies from response headers for future requests
      final cookieHeader = response.headers['set-cookie'];
      if (cookieHeader != null) {
        _logger.debug('Received cookies: $cookieHeader');
      }

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    try {
      print('üîê Starting login for userId: "$userId"');

      // First authenticate with backend to get user data
      final result = await authenticateUser(userID: userId, password: password);
      print('üîç Backend auth result: ${result['success']}');
      if (result['success'] == true) {
        final loginResponse = result['data'] as LoginResponse;

        print('üìä Backend login successful, proceeding with Firebase auth...');

        // Create user data
        final userDataWithId = UserData(
          emplName: loginResponse.data.emplName,
          areaCode: loginResponse.data.areaCode,
          roles: loginResponse.data.roles,
          pages: loginResponse.data.pages,
          userID: userId,
        );

        // Generate unique ID for this session
        final uniqueId = _generateUniqueId(userId);
        print('üîë Generated unique ID: $uniqueId');

        // Store user data and unique ID locally for autologin
        await _storeUserDataLocally(userDataWithId, uniqueId);
        print('üì± Unique ID stored for autologin');

        // Set user in AuthManager
        AuthManager.setUser(userDataWithId);
        return true;
      } else {
        print('‚ùå Backend authentication failed: ${result['error']}');
      }
      return false;
    } catch (e) {
      _logger.error('Login error', e);
      return false;
    }
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    try {
      // Get unique ID before clearing
      final prefs = await SharedPreferences.getInstance();
      final uniqueId = prefs.getString('unique_id');

      // Call backend logout endpoint if we have a unique ID
      if (uniqueId != null) {
        final backendLogout = await _performBackendLogout(uniqueId);
        if (backendLogout['success']) {
          print('‚úÖ Backend logout successful');
        } else {
          print('‚ö†Ô∏è Backend logout failed: ${backendLogout['error']}');
        }
      }

      // Clear stored user data
      await _clearStoredUserData();

      // Clear user from AuthManager
      AuthManager.clearUser();

      await Future.delayed(const Duration(milliseconds: 500));
      print('‚úÖ Complete logout successful');
    } catch (e) {
      print('‚ùå Logout error: $e');
      // Still clear local data even if logout fails
      await _clearStoredUserData();
      AuthManager.clearUser();
    }
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }

  // Session validation endpoint
  static Future<Map<String, dynamic>> validateSession() async {
    try {
      _logger.info('Validating user session');

      final uri = Uri.parse('$baseUrl/auth/me');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .get(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Session validation response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Session validation failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Session validation error', e);
      return {
        'success': false,
        'error': 'Network error during session validation',
        'statusCode': 0,
      };
    }
  }

  // Token refresh endpoint
  static Future<Map<String, dynamic>> refreshToken() async {
    try {
      _logger.info('Refreshing access token');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  // Enhanced logout with server-side session clearing
  static Future<Map<String, dynamic>> logoutFromServer() async {
    try {
      _logger.info('Logging out from server');

      final uri = Uri.parse('$baseUrl/auth/logout');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Server logout response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Server logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout',
        'statusCode': 0,
      };
    }
  }

  // Firebase Anonymous Authentication
  static Future<Map<String, dynamic>> _firebaseSignInAnonymous(
    UserData userData,
  ) async {
    try {
      print('üîê Attempting Firebase anonymous authentication for userID: ${userData.userID ?? "unknown"}');

      // Check if already signed in anonymously
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser != null && currentUser.isAnonymous) {
        print('‚úÖ Already signed in anonymously, updating profile');

        // Update user profile with display name and custom claims in local storage
        await currentUser.updateDisplayName(userData.emplName);
        return {'success': true, 'user': currentUser};
      }

      // Sign in anonymously
      final userCredential = await FirebaseAuth.instance.signInAnonymously();

      // Update user profile with display name
      await userCredential.user?.updateDisplayName(userData.emplName);

      print('‚úÖ Firebase anonymous sign in successful for: ${userData.userID ?? "unknown"}');
      return {'success': true, 'user': userCredential.user};
    } on FirebaseAuthException catch (e) {
      print('‚ùå Firebase anonymous sign in failed: ${e.message}');
      return {'success': false, 'error': 'Anonymous sign in failed: ${e.message}'};
    } catch (e) {
      print('‚ùå Firebase auth error: $e');
      return {'success': false, 'error': 'Firebase authentication failed: $e'};
    }
  }

  // Generate unique ID for autologin
  static String _generateUniqueId(String userId) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = DateTime.now().microsecond;
    return 'APP_${userId}_${timestamp}_$random';
  }

  // Store user data locally for autologin
  static Future<void> _storeUserDataLocally(UserData userData, [String? uniqueId]) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('user_data', jsonEncode(userData.toJson()));
      await prefs.setString('user_id', userData.userID ?? '');
      await prefs.setBool('is_logged_in', true);

      if (uniqueId != null) {
        await prefs.setString('unique_id', uniqueId);
      }

      print('üìä User data stored locally for autologin');
    } catch (e) {
      print('‚ùå Failed to store user data locally: $e');
    }
  }

  // Clear stored user data
  static Future<void> _clearStoredUserData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('user_data');
      await prefs.remove('user_id');
      await prefs.remove('unique_id');
      await prefs.setBool('is_logged_in', false);
      print('üóëÔ∏è Stored user data cleared');
    } catch (e) {
      print('‚ùå Failed to clear stored user data: $e');
    }
  }

  // Check for autologin on app start
  static Future<bool> checkAutologin() async {
    try {
      print('üîÑ Checking for autologin...');

      // Get stored data
      final prefs = await SharedPreferences.getInstance();
      final isLoggedIn = prefs.getBool('is_logged_in') ?? false;
      final uniqueId = prefs.getString('unique_id');

      if (!isLoggedIn || uniqueId == null) {
        print('‚ùå No stored session or unique ID found');
        return false;
      }

      print('üîë Found stored unique ID: $uniqueId');

      // Try auto-login with backend using unique ID
      final autoLoginResult = await _performBackendAutoLogin(uniqueId);

      if (autoLoginResult['success'] == true) {
        final userData = autoLoginResult['userData'] as UserData;

        // Update stored user data (in case roles/pages changed)
        await _storeUserDataLocally(userData, uniqueId);

        // Set user in AuthManager
        AuthManager.setUser(userData);
        print('‚úÖ Backend autologin successful for user: ${userData.userID ?? "unknown"}');
        return true;
      } else {
        print('‚ùå Backend autologin failed: ${autoLoginResult['error']}');
        await _clearStoredUserData();
        return false;
      }
    } catch (e) {
      print('‚ùå Autologin failed: $e');
      await _clearStoredUserData();
      return false;
    }
  }

  // Backend auto-login using unique ID
  static Future<Map<String, dynamic>> _performBackendAutoLogin(String uniqueId) async {
    try {
      _logger.info('Attempting backend auto-login with unique ID');

      final uri = Uri.parse('$baseUrl$autoLoginEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode({'appRegId': uniqueId});

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Auto-login response status: ${response.statusCode}');
      _logger.debug('Auto-login response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;
        final data = responseData['data'] as Map<String, dynamic>;

        // Create UserData from backend response
        final userData = UserData(
          emplName: data['emplName'] as String,
          areaCode: data['areaCode'] as String,
          roles: (data['roles'] as List<dynamic>).cast<String>(),
          pages: (data['pages'] as List<dynamic>).cast<String>(),
          userID: data['userID'] as String,
        );

        _logger.info('Backend auto-login successful');
        return {
          'success': true,
          'userData': userData,
          'statusCode': response.statusCode,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Auto-login failed';

        _logger.warning('Backend auto-login failed: $errorMessage');
        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Backend auto-login error', e);
      return {
        'success': false,
        'error': 'Network error during auto-login: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  // Backend logout using unique ID
  static Future<Map<String, dynamic>> _performBackendLogout(String uniqueId) async {
    try {
      _logger.info('Attempting backend logout with unique ID');

      final uri = Uri.parse('$baseUrl$logoutEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode({'appRegId': uniqueId});

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Backend logout response status: ${response.statusCode}');
      _logger.debug('Backend logout response body: ${response.body}');

      if (response.statusCode == 200) {
        _logger.info('Backend logout successful');
        return {
          'success': true,
          'statusCode': response.statusCode,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Backend logout failed';

        _logger.warning('Backend logout failed: $errorMessage');
        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Backend logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  // Firebase Authentication Helper Methods
  static Future<Map<String, dynamic>> _firebaseSignIn(
    String email,
    String password,
  ) async {
    try {
      _logger.info('Attempting Firebase sign in for: $email');

      final userCredential = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      _logger.info('Firebase sign in successful');
      return {'success': true, 'user': userCredential.user};
    } on FirebaseAuthException catch (e) {
      _logger.warning('Firebase sign in failed: ${e.message}');
      return {'success': false, 'error': e.message ?? 'Unknown Firebase error'};
    } catch (e) {
      _logger.error('Firebase sign in error', e);
      return {'success': false, 'error': 'Firebase authentication failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> _firebaseSignOut() async {
    try {
      _logger.info('Signing out from Firebase');

      await FirebaseAuth.instance.signOut();

      _logger.info('Firebase sign out successful');
      return {'success': true};
    } catch (e) {
      _logger.error('Firebase sign out error', e);
      return {'success': false, 'error': 'Firebase sign out failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> firebaseSignInWithPhone(
    String phoneNumber,
  ) async {
    try {
      _logger.info('Attempting Firebase phone sign in for: $phoneNumber');

      // Note: Phone auth requires reCAPTCHA setup in production
      // For now, this is a placeholder for future implementation
      return {'success': false, 'error': 'Phone authentication not configured yet'};
    } catch (e) {
      _logger.error('Firebase phone sign in error', e);
      return {
        'success': false,
        'error': 'Firebase phone authentication failed: $e',
      };
    }
  }

  // Helper method to validate email format
  static bool _isValidEmail(String email) {
    return RegExp(
      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
    ).hasMatch(email);
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);
  static bool _firebaseInitialized = false;

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  // Initialize Firebase auth state sync
  static Future<void> initializeFirebaseSync() async {
    if (_firebaseInitialized) return;

    try {
      // Set up Firebase auth state listener
      FirebaseAuth.instance.authStateChanges().listen((User? user) {
        print('Firebase auth state changed: ${user != null ? 'signed in' : 'signed out'}');

        if (user == null && _currentUser != null) {
          // User signed out, clear local data
          clearUser();
        }
      });

      _firebaseInitialized = true;
      print('‚úÖ Firebase auth state listener initialized');
    } catch (e) {
      print('‚ùå Failed to initialize Firebase sync: $e');
    }
  }

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;

    print('üë§ User set in AuthManager: ${userData.userID ?? "unknown"}');
    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;

    print('üóëÔ∏è User cleared from AuthManager');
    _notifyAuthChanged();
  }

  // Restore user session from Firebase auth state and local storage
  static Future<bool> restoreUserFromFirebase() async {
    try {
      print('üîÑ Checking Firebase auth state for session restoration...');

      final firebaseUser = FirebaseAuth.instance.currentUser;

      if (firebaseUser != null && firebaseUser.isAnonymous) {
        print('‚úÖ Firebase anonymous user found, checking local storage...');

        // Get stored user data from SharedPreferences
        final prefs = await SharedPreferences.getInstance();
        final userDataJson = prefs.getString('user_data');
        final isLoggedIn = prefs.getBool('is_logged_in') ?? false;

        if (isLoggedIn && userDataJson != null) {
          // Restore full user data from local storage
          final userDataMap = jsonDecode(userDataJson) as Map<String, dynamic>;
          final userData = UserData.fromJson(userDataMap);

          _currentUser = userData;
          _notifyAuthChanged();

          print('‚úÖ User session restored: ${userData.userID ?? "unknown"}');
          return true;
        } else {
          print('‚ùå No stored user data found, signing out Firebase user');
          await FirebaseAuth.instance.signOut();
        }
      } else {
        print('‚ùå No Firebase anonymous user found');
      }
    } catch (e) {
      print('‚ùå Failed to restore user from Firebase: $e');
    }

    return false;
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}









































import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_web_plugins/url_strategy.dart';

import 'core/theme/theme.dart';
import 'core/di/service_locator.dart';
import 'core/navigation/app_router.dart';
import 'core/services/auth_service.dart';

final RouteObserver<PageRoute> routeObserver = RouteObserver<PageRoute>();

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Keep hash URLs for Flutter Web (prevents 404s on hard refresh)
  setUrlStrategy(const HashUrlStrategy());

  // Global error handlers (surface real stack traces on web)
  FlutterError.onError = (FlutterErrorDetails details) {
    FlutterError.dumpErrorToConsole(details);
  };

  await runZonedGuarded<Future<void>>(
    () async {
      // Ensure services are ready before runApp
      await setupServiceLocator();

      // Check for autologin
      await AuthService.checkAutologin();

      runApp(const MyApp());
    },
    (error, stack) {
      debugPrint('Zoned error: $error');
      debugPrint('$stack');
    },
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      debugShowCheckedModeBanner: false,

      title: 'RAK Business Management',

      theme: AppTheme.lightTheme,

      themeMode: ThemeMode.light,

      routerConfig: AppRouter.router,
    );
  }
}
