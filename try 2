// upload_service.dart
import 'dart:convert';
import 'dart:io' show File; // used only on mobile paths
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:file_picker/file_picker.dart';
// Web-only
import 'package:web/web.dart' as web;
import '../models/image_upload_models.dart';

class UploadService {
  // Pending uploads management
  static final Map<String, PendingImageUpload> _pendingUploads = {};

  // Detect webview-ish contexts (wider net than widget side)
  static bool get _isInAppWebView {
    if (kIsWeb) {
      try {
        final ua = web.window.navigator.userAgent.toLowerCase();
        final vendor = web.window.navigator.vendor.toLowerCase();
        final loc = web.window.location;

        final isInAppWebView =
            ua.contains('inapp') ||
            ua.contains('webview') ||
            ua.contains('inappbrowser') ||
            ua.contains('capacitor') ||
            ua.contains('cordova') ||
            ua.contains('phonegap') ||
            vendor.contains('inapp') ||
            loc.protocol == 'file:' ||
            loc.protocol == 'capacitor:' ||
            loc.protocol == 'ionic:' ||
            (loc.hostname == 'localhost' && loc.port.isEmpty) ||
            (ua.contains('mobile') && !ua.contains('chrome'));

        return isInAppWebView;
      } catch (_) {
        return true;
      }
    }
    return false;
  }

  static List<String> get _fallbackUrls => <String>[
    'http://10.4.64.23:8521/api', // Your API endpoint
  ];

  static String get baseUrl {
    return 'http://10.4.64.23:8521/api';
  }

  /// Upload file to server only - no local storage fallback
  static Future<Map<String, dynamic>> uploadFile(
    String filePath, {
    String? originalName,
    String attFilTy = "01",
    String createId = "SYSTEM",
  }) async {
    return await _uploadWithFallback(
      filePath,
      originalName: originalName,
      attFilTy: attFilTy,
      createId: createId,
    );
  }

  static Future<Map<String, dynamic>> _uploadWithFallback(
    String filePath, {
    String? originalName,
    String attFilTy = "01",
    String createId = "SYSTEM",
  }) async {
    // Try primary URL first
    var result = await _uploadToUrl(
      baseUrl,
      filePath,
      originalName: originalName,
      attFilTy: attFilTy,
      createId: createId,
    );
    if (result['success'] == true) return result;

    // Try fallbacks
    for (final url in _fallbackUrls) {
      result = await _uploadToUrl(
        url,
        filePath,
        originalName: originalName,
        attFilTy: attFilTy,
        createId: createId,
      );
      if (result['success'] == true) return result;
    }

    // Give up; caller may choose local fallback
    return result;
  }

  static Future<Map<String, dynamic>> _uploadToUrl(
    String baseUrl,
    String filePath, {
    String? originalName,
    String attFilTy = "01",
    String createId = "SYSTEM",
  }) async {
    try {
      final uri = Uri.parse('$baseUrl/ImageUpload/upload');
      final request = http.MultipartRequest('POST', uri);

      // Helpful (but CORS must be on server)
      request.headers['Accept'] = 'application/json';

      // Add required metadata fields
      request.fields['attFilTy'] = attFilTy;
      request.fields['createId'] = createId;

      if (kIsWeb) {
        if (filePath.startsWith('data:')) {
          final parts = filePath.split(',');
          if (parts.length != 2) {
            throw Exception('Invalid data URL format');
          }
          final header = parts[0]; // data:<mime>;base64
          final mimeType = header.split(':')[1].split(';')[0];
          final bytes = base64Decode(parts[1]);
          final fileName = originalName ?? 'upload.${_extFromMime(mimeType)}';

          // Add file metadata fields
          request.fields['fileName'] = fileName;
          request.fields['fileSize'] = bytes.length.toString();
          request.fields['fileExtension'] = _extFromMime(mimeType);

          request.files.add(
            http.MultipartFile.fromBytes(
              'file',
              bytes,
              filename: fileName,
            ),
          );
        } else {
          // If you support blob: or object URLs, you'd need to fetch them first in JS and pass data:
          throw Exception(
            'Unsupported web file path format (expected data: URL)',
          );
        }
      } else {
        final file = File(filePath);
        if (!await file.exists()) {
          throw Exception('File does not exist: $filePath');
        }

        final fileName = originalName ?? file.path.split('/').last;
        final fileSize = await file.length();
        final fileExtension = fileName.split('.').last;

        // Add file metadata fields
        request.fields['fileName'] = fileName;
        request.fields['fileSize'] = fileSize.toString();
        request.fields['fileExtension'] = fileExtension;

        request.files.add(
          await http.MultipartFile.fromPath(
            'file',
            filePath,
            filename: fileName,
          ),
        );
      }

      // Reasonable timeouts
      final timeout = _isInAppWebView
          ? const Duration(seconds: 20)
          : const Duration(seconds: 30);

      final streamed = await request.send().timeout(
        timeout,
        onTimeout: () {
          throw Exception('Upload timed out after ${timeout.inSeconds}s');
        },
      );
      final response = await http.Response.fromStream(streamed);

      if (response.statusCode == 200) {
        final data = _safeJson(response.body);
        return {'success': true, 'data': data};
      } else {
        final err = _safeJson(response.body);
        final msg = (err['error'] ?? 'Upload failed').toString();
        return {
          'success': false,
          'error': _isInAppWebView ? 'InAppWebView upload error: $msg' : msg,
        };
      }
    } catch (e) {
      String msg = 'Upload failed: $e';
      if (_isInAppWebView) {
        if (e.toString().contains('timed out')) {
          msg =
              'Upload timed out in InAppWebView. Please check your connection and try again.';
        } else if (e.toString().contains('SocketException') ||
            e.toString().contains('Connection')) {
          msg =
              'Network connection failed in InAppWebView. Ensure the server is reachable.';
        } else {
          msg = 'InAppWebView upload error: $e';
        }
      }
      return {'success': false, 'error': msg};
    }
  }

  static Future<bool> testConnectivity() async {
    try {
      final resp = await http
          .get(
            Uri.parse('$baseUrl/health'),
            headers: {'Accept': 'application/json'},
          )
          .timeout(
            const Duration(seconds: 10),
            onTimeout: () => throw Exception('Timeout'),
          );
      return resp.statusCode == 200;
    } catch (_) {
      return false;
    }
  }

  // -------- Image Upload Methods --------

  static Future<PendingImageUpload?> selectImage({
    String attFilTy = "01",
    String createId = "SYSTEM",
  }) async {
    try {
      final file = await pickImage();
      if (file == null) return null;

      if (!isValidImageFile(file)) {
        throw Exception('Invalid file type. Only image files are allowed.');
      }

      final id = DateTime.now().millisecondsSinceEpoch.toString();
      String filePath;

      if (kIsWeb) {
        if (file.bytes != null) {
          final bytes = file.bytes!;
          final base64String = base64Encode(bytes);
          final mimeType = _getMimeType(file.extension);
          filePath = 'data:$mimeType;base64,$base64String';
        } else {
          throw Exception('File bytes are null');
        }
      } else {
        filePath = file.path ?? '';
      }

      final pendingUpload = PendingImageUpload(
        id: id,
        fileName: file.name,
        filePath: filePath,
        fileBytes: file.bytes,
        fileExtension: file.extension ?? '',
        fileSize: file.size,
        attFilTy: attFilTy,
        createId: createId,
      );

      _pendingUploads[id] = pendingUpload;
      return pendingUpload;
    } catch (e) {
      throw Exception('Failed to select image: ${e.toString()}');
    }
  }

  static void removePendingUpload(String id) {
    _pendingUploads.remove(id);
  }

  static List<PendingImageUpload> getPendingUploads() {
    return _pendingUploads.values.toList();
  }

  static PendingImageUpload? getPendingUpload(String id) {
    return _pendingUploads[id];
  }

  static void clearPendingUploads() {
    _pendingUploads.clear();
  }

  static Future<List<ImageUploadResponse>> uploadPendingImages() async {
    final results = <ImageUploadResponse>[];
    final uploads = List<PendingImageUpload>.from(_pendingUploads.values);

    for (final upload in uploads) {
      try {
        final result = await uploadFile(
          upload.filePath,
          originalName: upload.fileName,
          attFilTy: upload.attFilTy,
          createId: upload.createId,
        );

        if (result['success'] == true) {
          final data = result['data'] as Map<String, dynamic>?;
          results.add(ImageUploadResponse(
            msg: 'Image uploaded successfully',
            success: true,
            data: data != null ? ImageUploadData.fromJson(data) : null,
          ));
          _pendingUploads.remove(upload.id);
        } else {
          results.add(ImageUploadResponse(
            msg: result['error']?.toString() ?? 'Upload failed for ${upload.fileName}',
            success: false,
          ));
        }
      } catch (e) {
        results.add(ImageUploadResponse(
          msg: 'Network error for ${upload.fileName}: ${e.toString()}',
          success: false,
        ));
      }
    }

    return results;
  }

  static Future<ImageUploadResponse> uploadSinglePendingImage(String id) async {
    final upload = _pendingUploads[id];
    if (upload == null) {
      return ImageUploadResponse(
        msg: 'Pending upload not found',
        success: false,
      );
    }

    try {
      final result = await uploadFile(
        upload.filePath,
        originalName: upload.fileName,
        attFilTy: upload.attFilTy,
        createId: upload.createId,
      );

      if (result['success'] == true) {
        final data = result['data'] as Map<String, dynamic>?;
        _pendingUploads.remove(id);
        return ImageUploadResponse(
          msg: 'Image uploaded successfully',
          success: true,
          data: data != null ? ImageUploadData.fromJson(data) : null,
        );
      } else {
        return ImageUploadResponse(
          msg: result['error']?.toString() ?? 'Upload failed',
          success: false,
        );
      }
    } catch (e) {
      return ImageUploadResponse(
        msg: 'Network error: ${e.toString()}',
        success: false,
      );
    }
  }

  static Future<PlatformFile?> pickImage() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: false,
        withData: true, // This ensures bytes are loaded
      );

      if (result != null && result.files.isNotEmpty) {
        return result.files.first;
      }
      return null;
    } catch (e) {
      throw Exception('Failed to pick image: ${e.toString()}');
    }
  }

  static bool isValidImageFile(PlatformFile file) {
    const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];
    final fileExtension = file.extension?.toLowerCase();

    if (fileExtension == null) return false;

    return allowedExtensions.contains('.$fileExtension');
  }

  static String formatFileSize(int bytes) {
    if (bytes <= 0) return "0 B";
    const suffixes = ["B", "KB", "MB", "GB"];
    int i = 0;
    double size = bytes.toDouble();

    while (size >= 1024 && i < suffixes.length - 1) {
      size /= 1024;
      i++;
    }

    return "${size.toStringAsFixed(1)} ${suffixes[i]}";
  }

  // -------- helpers --------

  static String _extFromMime(String mime) {
    switch (mime) {
      case 'image/jpeg':
        return 'jpg';
      case 'image/png':
        return 'png';
      case 'image/gif':
        return 'gif';
      case 'image/webp':
        return 'webp';
      case 'application/pdf':
        return 'pdf';
      case 'text/plain':
        return 'txt';
      default:
        return 'bin';
    }
  }

  static String _getMimeType(String? extension) {
    if (extension == null) return 'application/octet-stream';

    switch (extension.toLowerCase()) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'gif':
        return 'image/gif';
      case 'bmp':
        return 'image/bmp';
      case 'webp':
        return 'image/webp';
      default:
        return 'application/octet-stream';
    }
  }

  static Map<String, dynamic> _safeJson(String body) {
    try {
      final parsed = json.decode(body);
      return parsed is Map<String, dynamic>
          ? parsed
          : <String, dynamic>{'raw': parsed};
    } catch (_) {
      return <String, dynamic>{'raw': body};
    }
  }
}
