using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using sparshWebService.DataAccess;
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

namespace sparshWebService.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly DatabaseHelper _db;
        private const int ITERATION_NUMBER = 1; // matches your current scheme

        public AuthController(DatabaseHelper dbHelper) => _db = dbHelper;

        // ---------------- Response Envelope ----------------
        public sealed class ApiResponse<T>
        {
            public bool Success { get; set; }
            public T Data { get; set; }
            public string Error { get; set; }
            public static ApiResponse<T> Ok(T d) => new() { Success = true, Data = d };
            public static ApiResponse<T> Fail(string m) => new() { Success = false, Error = m };
        }

        // ---------------- DTOs ----------------
        public class LoginRequest
        {
            public string userID { get; set; }
            public string password { get; set; }
            public string appRegId { get; set; } // Flutter-generated preferred; server will fallback if empty
        }

        public class AutoLoginRequest
        {
            public string appRegId { get; set; }
        }

        public class LogoutRequest
        {
            public string appRegId { get; set; }
        }

        public class UserDetails
        {
            public string emplName { get; set; }
            public string areaCode { get; set; }
            public HashSet<string> roles { get; set; }
            public HashSet<string> pages { get; set; }
        }

        // ===================================================
        //                  LOGIN (sets appRegId)
        // ===================================================
        [AllowAnonymous]
        [HttpPost("login")]
        public IActionResult Login([FromBody] LoginRequest request)
        {
            if (request == null ||
                string.IsNullOrWhiteSpace(request.userID) ||
                string.IsNullOrWhiteSpace(request.password))
            {
                return BadRequest(ApiResponse<object>.Fail("Parameters 'userID' and 'password' are required."));
            }

            try
            {
                // 1) Fetch stored hash + salt
                const string credSql = @"SELECT loginIdm, hashPass, hashSalt
                                         FROM wcmUserCred WITH (NOLOCK)
                                         WHERE loginIdM = @userID";
                var credParams = new Dictionary<string, object> { { "@userID", request.userID } };
                var credRows = _db.QaEWebBean(credSql, credParams);

                if (credRows == null || credRows.Count == 0)
                    return Unauthorized(ApiResponse<object>.Fail("Invalid userID."));

                string storedHash = credRows[0]["hashPass"]?.ToString();
                string storedSalt = credRows[0]["hashSalt"]?.ToString();
                if (string.IsNullOrWhiteSpace(storedHash) || string.IsNullOrWhiteSpace(storedSalt))
                    return BadRequest(ApiResponse<object>.Fail("Hash or salt not configured for this user."));

                // 2) Verify password (salted SHA-1 with 1 extra iteration to match your current scheme)
                string inputHash = HashPassword(request.password, storedSalt);
                if (!string.Equals(inputHash, storedHash, StringComparison.Ordinal))
                    return Unauthorized(ApiResponse<object>.Fail("Invalid password."));

                // 3) Decide appRegId: prefer Flutter-provided, else fallback to server-generated
                string appRegId = string.IsNullOrWhiteSpace(request.appRegId)
                    ? $"APP_{request.userID}_{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}_{Guid.NewGuid():N}"
                    : request.appRegId;

                // 4) Store/Update appRegId
                const string updSql = @"UPDATE wcmUserCred
                                        SET appRegId = @appRegId,
                                            updateDt = GETDATE(),
                                            updateID = @userID
                                        WHERE loginIdm = @userID";
                var updParams = new Dictionary<string, object>
                {
                    { "@appRegId", appRegId },
                    { "@userID", request.userID }
                };
                _db.QaEWebBean(updSql, updParams);

                // 5) Pull user details (roles/pages)
                var details = GetUserDetails(request.userID);
                if (details == null)
                    return Unauthorized(ApiResponse<object>.Fail("No active role/page data found."));

                // 6) Done
                var payload = new
                {
                    appRegId,
                    userID = request.userID,
                    emplName = details.emplName,
                    areaCode = details.areaCode,
                    roles = details.roles,
                    pages = details.pages
                };
                return Ok(ApiResponse<object>.Ok(payload));
            }
            catch (Exception ex)
            {
                return StatusCode(500, ApiResponse<object>.Fail($"Internal server error: {ex.Message}"));
            }
        }

        // ===================================================
        //                 AUTO-LOGIN (by appRegId)
        // ===================================================
        [AllowAnonymous]
        [HttpPost("auto-login")]
        public IActionResult AutoLogin([FromBody] AutoLoginRequest request)
        {
            if (request == null || string.IsNullOrWhiteSpace(request.appRegId))
                return BadRequest(ApiResponse<object>.Fail("Parameter 'appRegId' is required."));

            try
            {
                // 1) Lookup user by appRegId
                const string findSql = @"SELECT loginIdm
                                         FROM wcmUserCred WITH (NOLOCK)
                                         WHERE appRegId = @appRegId";
                var findParams = new Dictionary<string, object> { { "@appRegId", request.appRegId } };
                var rows = _db.QaEWebBean(findSql, findParams);

                if (rows == null || rows.Count == 0)
                    return Unauthorized(ApiResponse<object>.Fail("App registration not found."));

                string userID = rows[0]["loginIdm"]?.ToString();
                if (string.IsNullOrWhiteSpace(userID))
                    return Unauthorized(ApiResponse<object>.Fail("Invalid app registration record."));

                // 2) User details
                var details = GetUserDetails(userID);
                if (details == null)
                    return Unauthorized(ApiResponse<object>.Fail("No active role/page data found."));

                // 3) Touch last access time (optional)
                const string touchSql = @"UPDATE wcmUserCred
                                          SET updateDt = GETDATE()
                                          WHERE loginIdm = @userID";
                _db.QaEWebBean(touchSql, new Dictionary<string, object> { { "@userID", userID } });

                var payload = new
                {
                    userID,
                    emplName = details.emplName,
                    areaCode = details.areaCode,
                    roles = details.roles,
                    pages = details.pages
                };
                return Ok(ApiResponse<object>.Ok(payload));
            }
            catch (Exception ex)
            {
                return StatusCode(500, ApiResponse<object>.Fail($"Internal server error: {ex.Message}"));
            }
        }

        // ===================================================
        //                       LOGOUT
        // ===================================================
        [AllowAnonymous]
        [HttpPost("logout")]
        public IActionResult Logout([FromBody] LogoutRequest request)
        {
            if (request == null || string.IsNullOrWhiteSpace(request.appRegId))
                return BadRequest(ApiResponse<object>.Fail("Parameter 'appRegId' is required."));

            try
            {
                const string updSql = @"UPDATE wcmUserCred
                                        SET appRegId = NULL,
                                            updateDt = GETDATE()
                                        WHERE appRegId = @appRegId";
                _db.QaEWebBean(updSql, new Dictionary<string, object> { { "@appRegId", request.appRegId } });

                return Ok(ApiResponse<object>.Ok(new { msg = "Logout successful" }));
            }
            catch (Exception ex)
            {
                return StatusCode(500, ApiResponse<object>.Fail($"Internal server error: {ex.Message}"));
            }
        }

        // ===================================================
        //                  HELPERS (private)
        // ===================================================
        private UserDetails GetUserDetails(string userID)
        {
            const string detailSql = @"
                SELECT
                    a.emplName AS emplName,
                    a.areaCode AS areaCode,
                    b.roleCode AS roleCode,
                    c.mobPagId AS mobPagId
                FROM prmEmployee a WITH (NOLOCK)
                JOIN wcmEmplRole b WITH (NOLOCK) ON a.loginIdM = b.loginIdM
                JOIN wcmMobPgMas c WITH (NOLOCK) ON b.roleCode = c.roleCode
                WHERE
                    a.isActive = 'Y'
                    AND b.isActive = 'Y'
                    AND c.isActive = 'Y'
                    AND a.loginIdM = @userID";

            var param = new Dictionary<string, object> { { "@userID", userID } };
            var rset = _db.QaEWebBean(detailSql, param);
            if (rset == null || rset.Count == 0) return null;

            var roles = new HashSet<string>();
            var pages = new HashSet<string>();

            string emplName = rset[0]["emplName"]?.ToString();
            string areaCode = rset[0]["areaCode"]?.ToString();

            foreach (var row in rset)
            {
                var role = row["roleCode"]?.ToString();
                var page = row["mobPagId"]?.ToString();
                if (!string.IsNullOrWhiteSpace(role)) roles.Add(role);
                if (!string.IsNullOrWhiteSpace(page)) pages.Add(page);
            }

            return new UserDetails
            {
                emplName = emplName,
                areaCode = areaCode,
                roles = roles,
                pages = pages
            };
        }

        private static string HashPassword(string password, string saltBase64)
        {
            if (string.IsNullOrWhiteSpace(password) || string.IsNullOrWhiteSpace(saltBase64))
                return null;

            byte[] saltBytes = Convert.FromBase64String(saltBase64);
            byte[] passwordBytes = Encoding.UTF8.GetBytes(password);

            using var sha1 = SHA1.Create();

            // SHA1(salt + password)
            byte[] combined = new byte[saltBytes.Length + passwordBytes.Length];
            Buffer.BlockCopy(saltBytes, 0, combined, 0, saltBytes.Length);
            Buffer.BlockCopy(passwordBytes, 0, combined, saltBytes.Length, passwordBytes.Length);

            byte[] hash = sha1.ComputeHash(combined);

            // Apply iteration(s) to match your stored hashes
            for (int i = 0; i < ITERATION_NUMBER; i++)
                hash = sha1.ComputeHash(hash);

            return Convert.ToBase64String(hash);
        }
    }
}
