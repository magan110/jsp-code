import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'dart:js' as js;
import '../models/auth_models.dart';
import '../utils/app_logger.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client.send(request).timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      // Extract cookies from response headers for future requests
      final cookieHeader = response.headers['set-cookie'];
      if (cookieHeader != null) {
        _logger.debug('Received cookies: $cookieHeader');
      }

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    try {
      print('üîê Starting login for userId: "$userId"');

      // First authenticate with backend to get user data
      final result = await authenticateUser(userID: userId, password: password);
      if (result['success'] == true) {
        final loginResponse = result['data'] as LoginResponse;

        print('üìä Backend login successful, creating user data...');
        print('üìä Login response data: ${loginResponse.data}');

        // Create user data
        final userDataWithId = UserData(
          emplName: loginResponse.data.emplName,
          areaCode: loginResponse.data.areaCode,
          roles: loginResponse.data.roles,
          pages: loginResponse.data.pages,
          userID: userId, // Make sure userId parameter is used
        );

        print('üìä Created UserData: userID="${userDataWithId.userID}", name="${userDataWithId.emplName}"');

        // Set user in AuthManager first
        AuthManager.setUser(userDataWithId);

        // Then sign in to Firebase for web session management
        if (kIsWeb) {
          final firebaseResult = await _firebaseSignIn(userId, password);
          if (firebaseResult['success'] != true) {
            _logger.warning('Firebase authentication failed but backend succeeded');
            // Continue anyway - Firebase is for session management only
          }
        }

        print('‚úÖ Login completed successfully');
        return true;
      } else {
        print('‚ùå Backend authentication failed: ${result['error']}');
      }
      return false;
    } catch (e) {
      _logger.error('Login error', e);
      return false;
    }
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    // Firebase sign out first
    if (kIsWeb) {
      await _firebaseSignOut();
    }

    // Try to logout from server
    final serverLogout = await logoutFromServer();
    if (!serverLogout['success']) {
      _logger.warning('Server logout failed, clearing local session anyway');
    }

    AuthManager.clearUser();
    await Future.delayed(const Duration(milliseconds: 500));
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }

  // Session validation endpoint
  static Future<Map<String, dynamic>> validateSession() async {
    try {
      _logger.info('Validating user session');

      final uri = Uri.parse('$baseUrl/auth/me');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .get(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Session validation response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Session validation failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Session validation error', e);
      return {
        'success': false,
        'error': 'Network error during session validation',
        'statusCode': 0,
      };
    }
  }

  // Token refresh endpoint
  static Future<Map<String, dynamic>> refreshToken() async {
    try {
      _logger.info('Refreshing access token');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  // Enhanced logout with server-side session clearing
  static Future<Map<String, dynamic>> logoutFromServer() async {
    try {
      _logger.info('Logging out from server');

      final uri = Uri.parse('$baseUrl/auth/logout');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Server logout response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Server logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout',
        'statusCode': 0,
      };
    }
  }

  // Firebase Authentication Helper Methods
  static Future<Map<String, dynamic>> _firebaseSignIn(String email, String password) async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Attempting Firebase sign in for: $email');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            return await window.FirebaseAuthManager.signInWithEmailAndPassword('$email', '$password');
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase sign in successful');
        return {'success': true, 'user': result['user']};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase sign in failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase sign in error', e);
      return {'success': false, 'error': 'Firebase authentication failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> _firebaseSignOut() async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Signing out from Firebase');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            return await window.FirebaseAuthManager.signOut();
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase sign out successful');
        return {'success': true};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase sign out failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase sign out error', e);
      return {'success': false, 'error': 'Firebase sign out failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> firebaseSignInWithPhone(String phoneNumber) async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Attempting Firebase phone sign in for: $phoneNumber');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            // Note: Phone auth requires reCAPTCHA setup in production
            // For now, this is a placeholder for future implementation
            return { success: false, error: 'Phone authentication not configured' };
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase phone sign in successful');
        return {'success': true, 'confirmationResult': result['confirmationResult']};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase phone sign in failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase phone sign in error', e);
      return {'success': false, 'error': 'Firebase phone authentication failed: $e'};
    }
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);
  static bool _firebaseInitialized = false;

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  // Initialize Firebase auth state sync
  static Future<void> initializeFirebaseSync() async {
    if (!kIsWeb || _firebaseInitialized) return;

    try {
      // Set up Firebase auth state listener
      js.context.callMethod('eval', ['''
        if (window.FirebaseAuthManager) {
          window.FirebaseAuthManager.onAuthStateChanged((user) => {
            console.log('Firebase auth state changed:', user ? 'signed in' : 'signed out');

            // Communicate with Flutter
            if (window.flutter_inappwebview && window.flutter_inappwebview.callHandler) {
              window.flutter_inappwebview.callHandler('firebase_auth_changed', {
                isSignedIn: !!user,
                uid: user ? user.uid : null,
                email: user ? user.email : null
              });
            } else {
              // For regular browser, use custom event
              window.dispatchEvent(new CustomEvent('firebaseAuthChanged', {
                detail: {
                  isSignedIn: !!user,
                  uid: user ? user.uid : null,
                  email: user ? user.email : null
                }
              }));
            }
          });
        }
      ''']);

      _firebaseInitialized = true;
    } catch (e) {
      print('Failed to initialize Firebase sync: $e');
    }
  }

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;

    // Save user session to localStorage for persistence across tabs
    if (kIsWeb) {
      _saveUserSession(userData);
    }

    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;

    // Clear user session from localStorage
    if (kIsWeb) {
      _clearUserSession();
    }

    _notifyAuthChanged();
  }

  // Try to restore user session on app startup
  static Future<bool> restoreUserSession() async {
    if (!kIsWeb) {
      print('üì± Not web platform, skipping session restoration');
      return false;
    }

    try {
      print('üîÑ Calling SessionManager.restoreUserSession()...');

      // Check if SessionManager exists first
      final sessionManagerExists = js.context.callMethod('eval', ['''
        typeof window.SessionManager !== 'undefined'
      ''']);

      if (!sessionManagerExists) {
        print('‚ùå SessionManager not available');
        return false;
      }

      final sessionData = js.context.callMethod('eval', ['''
        window.SessionManager.restoreUserSession()
      ''']);

      print('üìä Session data received: $sessionData');
      print('üìä Session data type: ${sessionData.runtimeType}');

      if (sessionData != null) {
        // Convert JavaScript object to Dart Map
        final Map<String, dynamic> dataMap = {};

        try {
          dataMap['emplName'] = js.context.callMethod('eval', ['''
            window.SessionManager.restoreUserSession()?.emplName || ''
          ''']);
          dataMap['areaCode'] = js.context.callMethod('eval', ['''
            window.SessionManager.restoreUserSession()?.areaCode || ''
          ''']);
          dataMap['userID'] = js.context.callMethod('eval', ['''
            window.SessionManager.restoreUserSession()?.userID || ''
          ''']);

          final rolesData = js.context.callMethod('eval', ['''
            JSON.stringify(window.SessionManager.restoreUserSession()?.roles || [])
          ''']);
          final pagesData = js.context.callMethod('eval', ['''
            JSON.stringify(window.SessionManager.restoreUserSession()?.pages || [])
          ''']);

          dataMap['roles'] = jsonDecode(rolesData.toString());
          dataMap['pages'] = jsonDecode(pagesData.toString());

          print('üìä Parsed data: $dataMap');

          final restoredUserID = dataMap['userID']?.toString();
          if (restoredUserID != null && restoredUserID.isNotEmpty && restoredUserID != 'null') {
            final userData = UserData(
              emplName: dataMap['emplName']?.toString() ?? '',
              areaCode: dataMap['areaCode']?.toString() ?? '',
              roles: List<String>.from(dataMap['roles'] ?? []),
              pages: List<String>.from(dataMap['pages'] ?? []),
              userID: restoredUserID,
            );

            _currentUser = userData;
            _notifyAuthChanged();

            print('‚úÖ User session restored successfully: $restoredUserID');
            return true;
          } else {
            print('‚ùå Invalid session data - missing or invalid userID: $restoredUserID');
          }
        } catch (parseError) {
          print('‚ùå Failed to parse session data: $parseError');
        }
      } else {
        print('‚ùå No session data found');
      }
    } catch (e) {
      print('‚ùå Failed to restore user session: $e');
    }

    return false;
  }

  static void _saveUserSession(UserData userData) {
    try {
      // Validate userID before saving
      final userID = userData.userID;
      if (userID == null || userID.isEmpty) {
        print('‚ùå Cannot save session: userID is null or empty');
        return;
      }

      print('üíæ Saving user session for: $userID');

      // Create safe data object
      final sessionData = {
        'emplName': userData.emplName,
        'areaCode': userData.areaCode,
        'roles': userData.roles,
        'pages': userData.pages,
        'userID': userID, // Use the validated userID
      };

      print('üíæ Session data to save: $sessionData');

      js.context.callMethod('eval', ['''
        if (window.SessionManager) {
          window.SessionManager.saveUserSession(${jsonEncode(sessionData)});
        } else {
          console.error('‚ùå SessionManager not available');
        }
      ''']);
    } catch (e) {
      print('‚ùå Failed to save user session: $e');
    }
  }

  static void _clearUserSession() {
    try {
      js.context.callMethod('eval', ['''
        if (window.SessionManager) {
          window.SessionManager.clearUserSession();
        }
      ''']);
    } catch (e) {
      print('Failed to clear user session: $e');
    }
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}
