using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace SparshWebServices.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TokenScanController : ControllerBase
    {
        private readonly IConfiguration _cfg;
        private readonly ILogger<TokenScanController> _log;

        public TokenScanController(IConfiguration cfg, ILogger<TokenScanController> log)
        {
            _cfg = cfg;
            _log = log;
        }

        // --------------------------------------------------------------------
        //  GET /api/tokenscan/rand   -> right(newid(),16)
        // --------------------------------------------------------------------
        [HttpGet("rand")]
        public async Task<ActionResult<RandResponse>> GetRandAsync(CancellationToken ct)
        {
            const string sql = "SELECT RIGHT(CONVERT(varchar(36), NEWID()), 16);";
            try
            {
                await using var con = new SqlConnection(_cfg.GetConnectionString("bwlive"));
                await con.OpenAsync(ct);
                await using var cmd = new SqlCommand(sql, con);
                var val = (string?)await cmd.ExecuteScalarAsync(ct) ?? Guid.NewGuid().ToString("N")[^16..];
                return Ok(new RandResponse { RandNumb = val });
            }
            catch (Exception ex)
            {
                _log.LogError(ex, "rand failed");
                return Problem("Could not generate random id.");
            }
        }

        // --------------------------------------------------------------------
        //  POST /api/tokenscan/validate
        //  ONLY checks existence + CVV requirement (as you requested).
        // --------------------------------------------------------------------
        [HttpPost("validate")]
        public async Task<ActionResult<ValidateTokenResponse>> ValidateAsync(
            [FromBody] ValidateTokenRequest req, CancellationToken ct)
        {
            if (!ModelState.IsValid) return ValidationProblem(ModelState);

            const string sql = @"
SET NOCOUNT ON;

;WITH U AS (
    SELECT TOP (1)
        tokenNum,
        CAST(numCvvNo AS nvarchar(16)) AS cvv,
        isActive
    FROM [bwlive].dbo.dpmTokenNos WITH (NOLOCK)
    WHERE tokenNum = @token

    UNION ALL
    SELECT TOP (1)
        tokenNum,
        CAST(numCvvNo AS nvarchar(16)) AS cvv,
        isActive
    FROM [bwlive].dbo.dpaTokenNos WITH (NOLOCK)
    WHERE tokenNum = @token
)
SELECT TOP 1 tokenNum, ISNULL(LTRIM(RTRIM(cvv)),'') AS cvv, ISNULL(isActive,'') AS isActive
FROM U;
";
            try
            {
                await using var con = new SqlConnection(_cfg.GetConnectionString("bwlive"));
                await con.OpenAsync(ct);
                await using var cmd = new SqlCommand(sql, con);
                cmd.Parameters.AddWithValue("@token", req.TokenNum?.Trim() ?? string.Empty);

                await using var rdr = await cmd.ExecuteReaderAsync(ct);
                if (!await rdr.ReadAsync(ct))
                {
                    return Ok(new ValidateTokenResponse
                    {
                        TokenNum = req.TokenNum,
                        Found = false,
                        RequiresCvv = false,
                        CvvLength = null
                    });
                }

                var cvvRaw = rdr.GetString(1);
                var requires = !string.IsNullOrWhiteSpace(cvvRaw) && !cvvRaw.Equals("0");

                return Ok(new ValidateTokenResponse
                {
                    TokenNum = rdr.GetString(0),
                    Found = true,
                    RequiresCvv = requires,
                    CvvLength = requires ? cvvRaw.Length : (int?)null
                });
            }
            catch (Exception ex)
            {
                _log.LogError(ex, "validate failed for token {token}", req.TokenNum);
                return Problem("Unexpected error during validation.");
            }
        }

        // --------------------------------------------------------------------
        //  POST /api/tokenscan/scan-preview
        //  Mirrors JSPâ€™s MK_02004 result: token facts + amounts + flags.
        //  NOTE: This does not persist anything; it just prepares the line.
        // --------------------------------------------------------------------
        [HttpPost("scan-preview")]
        public async Task<ActionResult<ScanPreviewResponse>> ScanPreviewAsync(
            [FromBody] ScanPreviewRequest req, CancellationToken ct)
        {
            if (!ModelState.IsValid) return ValidationProblem(ModelState);
            var token = req.TokenNum?.Trim() ?? "";
            if (token.Length == 0) return BadRequest(new { message = "tokenNum required" });

            await using var con = new SqlConnection(_cfg.GetConnectionString("bwlive"));
            await con.OpenAsync(ct);
            await using var tx = await con.BeginTransactionAsync(ct);

            try
            {
                // 1) Read master info (tokenIdn, isActive, validity, scanndBy, bcTknTyp, numCvvNo)
                var m = await FetchMasterAsync(con, tx, token, ct);
                if (!m.Found)
                {
                    await tx.CommitAsync(ct);
                    return Ok(new ScanPreviewResponse { Found = false, TokenNum = token });
                }

                // Compute validity end (approximate JSP; exact uses db funcs dpfTknValDt/dpfTknValDy)
                var baseValidTo = m.PrintgDt?.AddDays(m.ValidDay ?? 0);
                // If you need exact parity with JSP area-wise grace, call your DB function here and override baseValidTo.
                var expr = (baseValidTo.HasValue && DateTime.Now > baseValidTo.Value) ? "Y" : "N";

                // 2) Multi-scan row if exists and active
                var ml = await FetchMultiScanAsync(con, tx, token, ct);

                // 3) Amounts/rates via stored proc (same as JSP: exec bwlive.dbo.dppToknProc 'jav01', @token, 0)
                var dpp = await CallDppToknProcAsync(con, tx, token, ct);

                // If SP not available, keep zeros but still return flags/master
                var tokDspVl = dpp.TokEndVl; // JSP uses tokDspVl in UI; map to TokEndVl

                await tx.CommitAsync(ct);

                return Ok(new ScanPreviewResponse
                {
                    Found = true,
                    TokenNum = token,
                    TokenIdn = m.TokenIdn,
                    IsActive = Normalize(m.IsActive),
                    ValidUpto = baseValidTo,
                    ScannedBy = m.UpdateId,
                    TokenVal = dpp.TokenVal,
                    HandRate = dpp.HandRate,
                    ScannerDedRate = dpp.ScnrDdRt,
                    TokEndVl = dpp.TokEndVl,
                    TokDisplayVal = tokDspVl,
                    MultiScanStatus = ml.IsActive,
                    MultiScanCount = ml.ScnMlCnt,
                    MultiScanAllow = ml.ScnMlAlw,
                    UpdIdAct = m.UpdateId,
                    UpdIdMlt = ml.UpdateId,
                    BcTknTyp = !string.IsNullOrWhiteSpace(dpp.BcTknTyp) ? dpp.BcTknTyp : m.BcTknTyp,
                    ExprFlag = expr,
                    RequiresCvv = !string.IsNullOrWhiteSpace(m.NumCvvNo) && m.NumCvvNo != "0",
                    CvvLength = string.IsNullOrWhiteSpace(m.NumCvvNo) ? (int?)null : m.NumCvvNo.Length
                });
            }
            catch (Exception ex)
            {
                await tx.RollbackAsync(ct);
                _log.LogError(ex, "scan-preview failed for token {token}", token);
                return Problem("Unexpected error during token info fetch.");
            }
        }

        // --------------------------------------------------------------------
        //  POST /api/tokenscan/submit
        //  Mirrors the JSP submit: header + details + master updates, totals.
        // --------------------------------------------------------------------
        [HttpPost("submit")]
        public async Task<ActionResult<SubmitTokensResponse>> SubmitAsync(
            [FromBody] SubmitTokensRequest req, CancellationToken ct)
        {
            if (!ModelState.IsValid) return ValidationProblem(ModelState);
            if (req.TokenNums is null || req.TokenNums.Count == 0)
                return BadRequest(new { message = "No tokens to submit." });

            // Create/resolve a docu number (JSP obtains via WebSessBean.getDocumentNo)
            var docuNumb = string.IsNullOrWhiteSpace(req.DocuNumb)
                ? $"TKN-{req.AreaCode}-{DateTime.UtcNow:yyyyMMddHHmmss}-{Random.Shared.Next(100,999)}"
                : req.DocuNumb!.Trim();

            await using var con = new SqlConnection(_cfg.GetConnectionString("bwlive"));
            await con.OpenAsync(ct);
            await using var tx = await con.BeginTransactionAsync(ct);

            try
            {
                // Header placeholder (will update totals later)
                await ExecAsync(con, tx, @"
INSERT INTO [bwlive].dbo.cdtTokenRec
  (docuNumb, docuDate, tokenTyp, cdnDocTy, custCode, prodCode,
   recptQty, basTknAm, handAmnt, scnDedAm, payblAmt,
   statFlag, createId, createDt)
VALUES
  (@docu, CONVERT(date, GETDATE()), 'BC', 'CRN', @cust, 0,
   0, 0, 0, 0, 0, 'A', @login, GETDATE());
", new Dictionary<string, object?>
                {
                    ["@docu"] = docuNumb,
                    ["@cust"] = req.CustCode,
                    ["@login"] = req.LoginId
                }, ct);

                // Totals like JSP
                int rightEnt = 0, already = 0, expired = 0, invalid = 0;
                int prodCodeHdr = 0;
                decimal basTknAm = 0, handAmnt = 0, payblAmt = 0, scnDedAm = 0;

                string? bcTknTypLast = null; // used for cdtCusToPay row if you later add it
                foreach (var raw in req.TokenNums)
                {
                    var token = (raw ?? "").Trim();
                    if (token.Length == 0) continue;

                    // amounts/flags
                    var dpp = await CallDppToknProcAsync(con, tx, token, ct); // may return zeros if SP missing
                    var mst = await FetchMasterAsync(con, tx, token, ct);
                    var ml  = await FetchMultiScanAsync(con, tx, token, ct);

                    // Expiry flag (approx; for exact parity inject DB function)
                    var baseValidTo = mst.PrintgDt?.AddDays(mst.ValidDay ?? 0);
                    var expr = (baseValidTo.HasValue && DateTime.Now > baseValidTo.Value) ? "Y" : "N";

                    // Area/type guard like JSP (client-side check is enforced again here)
                    if (!AreaAllowed(req.AreaCode, dpp.BcTknTyp ?? mst.BcTknTyp))
                    {
                        invalid++;
                        // detail row still gets inserted as 'N'
                        await InsertDetailAsync(con, tx, docuNumb, token, "N", expr, mst.IsActive, dpp, req.InflCode, req.LoginId, ct);
                        continue;
                    }

                    string tokenVld;
                    if (expr == "Y")
                    {
                        expired++;
                        tokenVld = "E";
                    }
                    else if (Normalize(mst.IsActive) == "Z")
                    {
                        already++;
                        tokenVld = "Z";
                    }
                    else if ((dpp.ProdCode ?? 0) <= 0)
                    {
                        invalid++;
                        tokenVld = "N";
                    }
                    else
                    {
                        // OK
                        rightEnt++;
                        tokenVld = "Y";
                        basTknAm += dpp.TokenVal ?? 0m;
                        handAmnt += dpp.HandRate ?? 0m;
                        payblAmt += dpp.TokEndVl ?? 0m;
                        scnDedAm += dpp.ScnrDdRt ?? 0m;
                        prodCodeHdr = dpp.ProdCode ?? prodCodeHdr;
                        bcTknTypLast = dpp.BcTknTyp ?? mst.BcTknTyp;
                    }

                    // Insert detail
                    await InsertDetailAsync(con, tx, docuNumb, token, tokenVld, expr, mst.IsActive, dpp, req.InflCode, req.LoginId, ct);

                    // Update master to Z (like JSP) and optional multi-scan
                    if (tokenVld == "Y")
                    {
                        // The JSP adds an extra validity predicate using dpfTknValDt/dpfTknValDy.
                        // If you need that exact predicate, add it here.
                        await ExecAsync(con, tx, @"
UPDATE [bwlive].dbo.dpmTokenNos
   SET isActive = 'Z', updateId = @login, updateDt = GETDATE()
 WHERE tokenNum = @token AND isActive IN ('Y','Z');
", new Dictionary<string, object?>
                        {
                            ["@login"] = req.LoginId, ["@token"] = token
                        }, ct);

                        await ExecAsync(con, tx, @"
IF OBJECT_ID(N'[bwlive].dbo.dpmToknMlSc', N'U') IS NOT NULL
BEGIN
    UPDATE [bwlive].dbo.dpmToknMlSc
       SET scnMlCnt = scnMlCnt + 1,
           isActive = CASE WHEN scnMlCnt + 1 >= scnMlAlw THEN 'Z' ELSE 'Y' END,
           updateId = @login, updateDt = GETDATE()
     WHERE tokenNum = @token AND isActive = 'Y' AND scnMlCnt < scnMlAlw;
END
", new Dictionary<string, object?>
                        {
                            ["@login"] = req.LoginId, ["@token"] = token
                        }, ct);
                    }
                }

                // Update header totals
                await ExecAsync(con, tx, @"
UPDATE [bwlive].dbo.cdtTokenRec
   SET recptQty = @qty,
       basTknAm = @bas,
       handAmnt = @hand,
       scnDedAm = @scn,
       payblAmt = @pay,
       prodCode  = @prod,
       updateId  = @login,
       updateDt  = GETDATE()
 WHERE docuNumb = @docu;
", new Dictionary<string, object?>
                {
                    ["@qty"] = rightEnt,
                    ["@bas"] = basTknAm,
                    ["@hand"] = handAmnt,
                    ["@scn"] = scnDedAm,
                    ["@pay"] = payblAmt,
                    ["@prod"] = prodCodeHdr,
                    ["@login"] = req.LoginId,
                    ["@docu"] = docuNumb
                }, ct);

                // JSP: if many wrong entries, block user
                var wrongEnt = invalid + expired; // already scanned is handled as 'Z' bucket in JSP UI; wrongEnt counted as not-updated master
                if (wrongEnt > 10)
                {
                    await ExecAsync(con, tx, @"
IF OBJECT_ID(N'[bwlive].dbo.wcmUserCred', N'U') IS NOT NULL
    UPDATE [bwlive].dbo.wcmUserCred
       SET blckedDt = GETDATE(), updateId = @login, updateDt = GETDATE()
     WHERE loginIdM = @login;
", new Dictionary<string, object?> { ["@login"] = req.LoginId }, ct);
                }

                await tx.CommitAsync(ct);

                return Ok(new SubmitTokensResponse
                {
                    DocuNumb = docuNumb,
                    Right = rightEnt,
                    Already = already,
                    Expired = expired,
                    Invalid = invalid,
                    BasTknAm = basTknAm,
                    HandAmnt = handAmnt,
                    ScnDedAm = scnDedAm,
                    PayblAmt = payblAmt,
                    Message = $"Batch {docuNumb}: Right={rightEnt}, Already={already}, Expired={expired}, Invalid={invalid}, Payable={payblAmt}"
                });
            }
            catch (Exception ex)
            {
                await tx.RollbackAsync(ct);
                _log.LogError(ex, "submit failed {docu} {login}", docuNumb, req.LoginId);
                return Problem("Could not save tokens. Transaction rolled back.");
            }
        }

        // ========================== Helpers ===============================

        private static string Normalize(string? s) => string.IsNullOrWhiteSpace(s) ? "" : s.Trim().ToUpperInvariant();

        private static decimal? SafeDec(IDataRecord r, int i) => r.IsDBNull(i) ? (decimal?)null : Convert.ToDecimal(r.GetValue(i), CultureInfo.InvariantCulture);

        private async Task ExecAsync(SqlConnection con, SqlTransaction tx, string sql, IDictionary<string, object?> p, CancellationToken ct)
        {
            await using var cmd = new SqlCommand(sql, con, tx);
            foreach (var kv in p) cmd.Parameters.AddWithValue(kv.Key, kv.Value ?? DBNull.Value);
            await cmd.ExecuteNonQueryAsync(ct);
        }

        private static bool AreaAllowed(string? areaCode, string? bcTknTyp)
        {
            var area = Normalize(areaCode);
            var typ  = Normalize(bcTknTyp);
            // JSP rules:
            // B1 -> only EXE/EXN/EXR
            if (typ == "B1") return area is "EXE" or "EXN" or "EXR";
            // E1 -> only EXB/EXC/EXG
            if (typ == "E1") return area is "EXB" or "EXC" or "EXG";
            // other/empty -> allowed (front-end warns)
            return true;
        }

        private async Task<MasterRow> FetchMasterAsync(SqlConnection con, SqlTransaction tx, string token, CancellationToken ct)
        {
            const string sql = @"
;WITH U AS (
    SELECT TOP (1)
        tokenNum, tokenIdn, isActive, updateId, printgDt, validDay, bcTknTyp,
        CAST(numCvvNo AS nvarchar(16)) AS numCvvNo
    FROM [bwlive].dbo.dpmTokenNos WITH (NOLOCK)
    WHERE tokenNum = @token

    UNION ALL
    SELECT TOP (1)
        tokenNum, tokenIdn, isActive, updateId, printgDt, validDay, bcTknTyp,
        CAST(numCvvNo AS nvarchar(16)) AS numCvvNo
    FROM [bwlive].dbo.dpaTokenNos WITH (NOLOCK)
    WHERE tokenNum = @token
)
SELECT TOP 1 tokenNum, tokenIdn, isActive, updateId, printgDt, validDay, bcTknTyp, ISNULL(LTRIM(RTRIM(numCvvNo)),'') AS numCvvNo
FROM U;
";
            await using var cmd = new SqlCommand(sql, con, tx);
            cmd.Parameters.AddWithValue("@token", token);
            await using var rdr = await cmd.ExecuteReaderAsync(ct);
            if (!await rdr.ReadAsync(ct)) return new MasterRow { Found = false };

            return new MasterRow
            {
                Found = true,
                TokenNum = rdr.GetString(0),
                TokenIdn = rdr.IsDBNull(1) ? (long?)null : Convert.ToInt64(rdr.GetValue(1)),
                IsActive = rdr.IsDBNull(2) ? "" : rdr.GetString(2),
                UpdateId = rdr.IsDBNull(3) ? "" : rdr.GetString(3),
                PrintgDt = rdr.IsDBNull(4) ? (DateTime?)null : rdr.GetDateTime(4),
                ValidDay = rdr.IsDBNull(5) ? (int?)null : Convert.ToInt32(rdr.GetValue(5)),
                BcTknTyp = rdr.IsDBNull(6) ? "" : rdr.GetString(6),
                NumCvvNo = rdr.IsDBNull(7) ? "" : rdr.GetString(7)
            };
        }

        private async Task<MultiScanRow> FetchMultiScanAsync(SqlConnection con, SqlTransaction tx, string token, CancellationToken ct)
        {
            const string sql = @"
IF OBJECT_ID(N'[bwlive].dbo.dpmToknMlSc', N'U') IS NULL
BEGIN
    SELECT CAST(NULL AS varchar(1)) AS isActive,
           CAST(0 AS int) AS scnMlCnt,
           CAST(0 AS int) AS scnMlAlw,
           CAST(NULL AS varchar(30)) AS updateId;
END
ELSE
BEGIN
    SELECT TOP (1) isActive, scnMlCnt, scnMlAlw, ISNULL(updateId,'')
    FROM [bwlive].dbo.dpmToknMlSc WITH (NOLOCK)
    WHERE tokenNum = @token AND isActive = 'Y' AND scnMlCnt < scnMlAlw;
END";
            await using var cmd = new SqlCommand(sql, con, tx);
            cmd.Parameters.AddWithValue("@token", token);
            await using var rdr = await cmd.ExecuteReaderAsync(ct);
            if (!await rdr.ReadAsync(ct)) return new MultiScanRow();

            return new MultiScanRow
            {
                IsActive = rdr.IsDBNull(0) ? "" : rdr.GetString(0),
                ScnMlCnt = rdr.IsDBNull(1) ? 0 : rdr.GetInt32(1),
                ScnMlAlw = rdr.IsDBNull(2) ? 0 : rdr.GetInt32(2),
                UpdateId = rdr.IsDBNull(3) ? "" : rdr.GetString(3)
            };
        }

        // Mirrors: exec bwlive.dbo.dppToknProc 'jav01', @token, 0
        private async Task<DppRow> CallDppToknProcAsync(SqlConnection con, SqlTransaction tx, string token, CancellationToken ct)
        {
            try
            {
                await using var cmd = new SqlCommand("bwlive.dbo.dppToknProc", con, tx)
                {
                    CommandType = CommandType.StoredProcedure,
                    CommandTimeout = 60
                };
                cmd.Parameters.AddWithValue("@mode", "jav01");
                cmd.Parameters.AddWithValue("@tokenNum", token);
                cmd.Parameters.AddWithValue("@dummy", 0);

                await using var rdr = await cmd.ExecuteReaderAsync(ct);
                if (await rdr.ReadAsync(ct))
                {
                    return new DppRow
                    {
                        BcTknTyp = rdr.IsDBNull(0) ? "" : rdr.GetString(0),
                        TokenVal = SafeDec(rdr, 1) ?? 0m,
                        HandRate = SafeDec(rdr, 2) ?? 0m,
                        ScnrDdRt = SafeDec(rdr, 3) ?? 0m,
                        TokEndVl = SafeDec(rdr, 4) ?? 0m,
                        ProdCode = rdr.IsDBNull(5) ? 0 : rdr.GetInt32(5),
                        UpdateId = rdr.IsDBNull(6) ? "" : rdr.GetString(6),
                        DbActSts = rdr.IsDBNull(7) ? "" : rdr.GetString(7),
                        ExprFlag = rdr.IsDBNull(8) ? "" : rdr.GetString(8)
                    };
                }
            }
            catch (SqlException ex) when (ex.Number == 2812 /* proc not found */)
            {
                _log.LogWarning(ex, "dppToknProc missing; continuing with zeros.");
            }
            catch (Exception ex)
            {
                _log.LogError(ex, "dppToknProc failed for token {token}", token);
            }
            return new DppRow(); // zeros/defaults
        }

        private async Task InsertDetailAsync(SqlConnection con, SqlTransaction tx,
            string docuNumb, string token, string tokenVld, string exprFlag,
            string? toknStat, DppRow dpp, string? inflCode, string loginId, CancellationToken ct)
        {
            await ExecAsync(con, tx, @"
INSERT INTO [bwlive].dbo.dptTokenRecDtl
  (docuNumb, tokenNum, tokenVld, exprFlag, toknStat, bcTknTyp,
   tokenVal, handRate, tokEndVl, prodCode, inflCode, statFlag,
   createId, createDt)
VALUES
  (@docu, @token, @vld, @expr, @stat, @typ,
   @tval, @hr, @endv, @prod, @infl, 'A',
   @login, GETDATE());
", new Dictionary<string, object?>
            {
                ["@docu"] = docuNumb,
                ["@token"] = token,
                ["@vld"] = tokenVld,
                ["@expr"] = string.IsNullOrWhiteSpace(exprFlag) ? (object)DBNull.Value : exprFlag,
                ["@stat"] = string.IsNullOrWhiteSpace(toknStat) ? (object)DBNull.Value : toknStat,
                ["@typ"]  = string.IsNullOrWhiteSpace(dpp.BcTknTyp) ? (object)DBNull.Value : dpp.BcTknTyp,
                ["@tval"] = dpp.TokenVal ?? 0m,
                ["@hr"]   = dpp.HandRate ?? 0m,
                ["@endv"] = dpp.TokEndVl ?? 0m,
                ["@prod"] = dpp.ProdCode ?? 0,
                ["@infl"] = string.IsNullOrWhiteSpace(inflCode) ? "INF00000" : inflCode!,
                ["@login"]= loginId
            }, ct);
        }

        // ========================== DTOs/Records ============================

        public sealed class RandResponse { public string RandNumb { get; set; } = ""; }

        public sealed class ValidateTokenRequest
        {
            [Required, StringLength(20)]
            public string TokenNum { get; set; } = default!;
        }

        public sealed class ValidateTokenResponse
        {
            public string TokenNum { get; set; } = "";
            public bool Found { get; set; }
            public bool RequiresCvv { get; set; }
            public int? CvvLength { get; set; }
        }

        public sealed class ScanPreviewRequest
        {
            [Required, StringLength(20)]
            public string TokenNum { get; set; } = default!;

            // Optional â€” exact JSP validity grace depends on area/cust.
            public string? AreaCode { get; set; }
            public string? CustCode { get; set; }
        }

        public sealed class ScanPreviewResponse
        {
            public bool Found { get; set; }
            public string TokenNum { get; set; } = "";
            public long? TokenIdn { get; set; }
            public string? IsActive { get; set; }     // Y/Z/E/T/...
            public DateTime? ValidUpto { get; set; }  // display-friendly
            public string? ScannedBy { get; set; }
            public decimal? TokenVal { get; set; }
            public decimal? HandRate { get; set; }
            public decimal? ScannerDedRate { get; set; }
            public decimal? TokEndVl { get; set; }
            public decimal? TokDisplayVal { get; set; }
            public string? MultiScanStatus { get; set; }
            public int    MultiScanCount { get; set; }
            public int    MultiScanAllow { get; set; }
            public string? UpdIdAct { get; set; }
            public string? UpdIdMlt { get; set; }
            public string? BcTknTyp { get; set; }
            public string? ExprFlag { get; set; }     // Y/N
            public bool   RequiresCvv { get; set; }
            public int?   CvvLength { get; set; }
        }

        public sealed class SubmitTokensRequest
        {
            [Required, StringLength(8)] public string CustCode { get; set; } = default!;
            [Required, StringLength(4)] public string AreaCode { get; set; } = default!;
            [Required, StringLength(10)] public string LoginId { get; set; } = default!;
            [StringLength(16)] public string? InflCode { get; set; } = "INF00000";
            [Required] public List<string> TokenNums { get; set; } = new();
            public string? DocuNumb { get; set; } // optional
        }

        public sealed class SubmitTokensResponse
        {
            public string DocuNumb { get; set; } = "";
            public int Right { get; set; }
            public int Already { get; set; }
            public int Expired { get; set; }
            public int Invalid { get; set; }
            public decimal BasTknAm { get; set; }
            public decimal HandAmnt { get; set; }
            public decimal ScnDedAm { get; set; }
            public decimal PayblAmt { get; set; }
            public string Message { get; set; } = "";
        }

        private sealed class MasterRow
        {
            public bool   Found { get; set; }
            public string TokenNum { get; set; } = "";
            public long?  TokenIdn { get; set; }
            public string? IsActive { get; set; }
            public string? UpdateId { get; set; }
            public DateTime? PrintgDt { get; set; }
            public int?   ValidDay { get; set; }
            public string? BcTknTyp { get; set; }
            public string? NumCvvNo { get; set; }
        }

        private sealed class MultiScanRow
        {
            public string? IsActive { get; set; }
            public int ScnMlCnt { get; set; }
            public int ScnMlAlw { get; set; }
            public string? UpdateId { get; set; }
        }

        private sealed class DppRow
        {
            public string?  BcTknTyp  { get; set; }
            public decimal? TokenVal  { get; set; }
            public decimal? HandRate  { get; set; }
            public decimal? ScnrDdRt  { get; set; }
            public decimal? TokEndVl  { get; set; }
            public int?     ProdCode  { get; set; }
            public string?  UpdateId  { get; set; }
            public string?  DbActSts  { get; set; }
            public string?  ExprFlag  { get; set; }
        }
    }
}
