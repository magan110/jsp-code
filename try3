import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'dart:js' as js;
import 'package:shared_preferences/shared_preferences.dart';
import '../models/auth_models.dart';
import '../utils/app_logger.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';
  static const String autoLoginEndpoint = '/api/Auth/auto-login';
  static const String logoutEndpoint = '/api/Auth/logout';

  // Storage keys
  static const String _appRegIdKey = 'app_reg_id';
  static const String _userIdKey = 'user_id';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client.send(request).timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      // Extract cookies from response headers for future requests
      final cookieHeader = response.headers['set-cookie'];
      if (cookieHeader != null) {
        _logger.debug('Received cookies: $cookieHeader');
      }

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    try {
      print('üîê Starting Firebase-only login for userId: "$userId"');

      // First authenticate with backend to get user data
      final result = await authenticateUser(userID: userId, password: password);
      if (result['success'] == true) {
        final loginResponse = result['data'] as LoginResponse;

        print('üìä Backend login successful, proceeding with Firebase auth...');

        // Create user data
        final userDataWithId = UserData(
          emplName: loginResponse.data.emplName,
          areaCode: loginResponse.data.areaCode,
          roles: loginResponse.data.roles,
          pages: loginResponse.data.pages,
          userID: userId,
        );

        // Firebase Authentication for web
        if (kIsWeb) {
          final firebaseResult = await _firebaseCustomAuth(userId, password, userDataWithId);
          if (firebaseResult['success'] == true) {
            print('‚úÖ Firebase authentication successful');

            // Set user in AuthManager after Firebase auth succeeds
            AuthManager.setUser(userDataWithId);

            // Store appRegId for auto-login
            await _storeAppRegId(loginResponse.data.appRegId, userId);
            return true;
          } else {
            print('‚ùå Firebase authentication failed: ${firebaseResult['error']}');
            return false;
          }
        } else {
          // For non-web platforms, just use AuthManager
          AuthManager.setUser(userDataWithId);

          // Store appRegId for auto-login
          await _storeAppRegId(loginResponse.data.appRegId, userId);
          return true;
        }
      } else {
        print('‚ùå Backend authentication failed: ${result['error']}');
      }
      return false;
    } catch (e) {
      _logger.error('Login error', e);
      return false;
    }
  }

  // Store appRegId and userID for auto-login
  static Future<void> _storeAppRegId(String? appRegId, String userID) async {
    if (appRegId == null) return;

    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_appRegIdKey, appRegId);
      await prefs.setString(_userIdKey, userID);
      _logger.info('AppRegId stored for auto-login: ${appRegId.substring(0, 10)}...');
    } catch (e) {
      _logger.error('Failed to store appRegId', e);
    }
  }

  // Get stored appRegId
  static Future<String?> getStoredAppRegId() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString(_appRegIdKey);
    } catch (e) {
      _logger.error('Failed to get stored appRegId', e);
      return null;
    }
  }

  // Get stored userID
  static Future<String?> getStoredUserId() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      return prefs.getString(_userIdKey);
    } catch (e) {
      _logger.error('Failed to get stored userID', e);
      return null;
    }
  }

  // Clear stored credentials
  static Future<void> clearStoredCredentials() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_appRegIdKey);
      await prefs.remove(_userIdKey);
      _logger.info('Stored credentials cleared');
    } catch (e) {
      _logger.error('Failed to clear stored credentials', e);
    }
  }

  // Auto-login using stored appRegId
  static Future<Map<String, dynamic>> tryAutoLogin() async {
    try {
      final appRegId = await getStoredAppRegId();
      if (appRegId == null) {
        return {
          'success': false,
          'error': 'No stored appRegId found',
          'statusCode': 0,
        };
      }

      _logger.info('Attempting auto-login with stored appRegId');

      final autoLoginRequest = AutoLoginRequest(appRegId: appRegId);
      final uri = Uri.parse('$baseUrl$autoLoginEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(autoLoginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client.send(request).timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      _logger.debug('Auto-login response status: ${response.statusCode}');
      _logger.debug('Auto-login response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          // Parse the response to get user data
          final userData = UserData.fromJson(responseData['data'] as Map<String, dynamic>);
          _logger.info('Auto-login successful');

          return {
            'success': true,
            'data': userData,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse auto-login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Auto-login failed - token expired';

        _logger.warning('Auto-login failed: $errorMessage');

        // Clear invalid stored credentials
        await clearStoredCredentials();

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Auto-login server error';

        _logger.error('Auto-login server error: ${response.statusCode} - $errorMessage');

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Auto-login error', e);
      return {
        'success': false,
        'error': 'Auto-login network error: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  // Public auto-login method for splash screen
  static Future<bool> attemptAutoLogin() async {
    try {
      _logger.info('Attempting auto-login...');

      final result = await tryAutoLogin();

      if (result['success'] == true) {
        final userData = result['data'] as UserData;

        // Create complete user data with userID
        final storedUserId = await getStoredUserId();
        final userDataWithId = UserData(
          emplName: userData.emplName,
          areaCode: userData.areaCode,
          roles: userData.roles,
          pages: userData.pages,
          userID: storedUserId,
          appRegId: await getStoredAppRegId(),
        );

        // Set user in AuthManager
        AuthManager.setUser(userDataWithId);

        // For web platforms, also sync with Firebase if possible
        if (kIsWeb) {
          // Optional: Try to restore Firebase auth state if needed
          // This would depend on your Firebase setup
        }

        _logger.info('Auto-login successful for user: $storedUserId');
        return true;
      } else {
        _logger.info('Auto-login failed: ${result['error']}');
        return false;
      }
    } catch (e) {
      _logger.error('Auto-login attempt failed', e);
      return false;
    }
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    // Firebase sign out first
    if (kIsWeb) {
      await _firebaseSignOut();
    }

    // Try to logout from server with appRegId
    final appRegId = await getStoredAppRegId();
    if (appRegId != null) {
      final serverLogout = await logoutFromServer(appRegId);
      if (!serverLogout['success']) {
        _logger.warning('Server logout failed, clearing local session anyway');
      }
    }

    // Clear stored credentials
    await clearStoredCredentials();

    AuthManager.clearUser();
    await Future.delayed(const Duration(milliseconds: 500));
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }

  // Session validation endpoint
  static Future<Map<String, dynamic>> validateSession() async {
    try {
      _logger.info('Validating user session');

      final uri = Uri.parse('$baseUrl/auth/me');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .get(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Session validation response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Session validation failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Session validation error', e);
      return {
        'success': false,
        'error': 'Network error during session validation',
        'statusCode': 0,
      };
    }
  }

  // Token refresh endpoint
  static Future<Map<String, dynamic>> refreshToken() async {
    try {
      _logger.info('Refreshing access token');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  // Enhanced logout with server-side session clearing
  static Future<Map<String, dynamic>> logoutFromServer(String appRegId) async {
    try {
      _logger.info('Logging out from server');

      final logoutRequest = LogoutRequest(appRegId: appRegId);
      final uri = Uri.parse('$baseUrl$logoutEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(logoutRequest.toJson());

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Server logout response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Server logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout',
        'statusCode': 0,
      };
    }
  }

  // Firebase Custom Authentication for any userID/email input
  static Future<Map<String, dynamic>> _firebaseCustomAuth(String userID, String password, UserData userData) async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      print('üîê Attempting Firebase custom auth for input: $userID');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseCustomAuth) {
            return await window.FirebaseCustomAuth.signInWithUserID('$userID', '$password');
          }
          return { success: false, error: 'FirebaseCustomAuth not available' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        print('‚úÖ Firebase custom auth successful for input: $userID');

        // Store user data in Firebase user profile or custom claims
        await _storeUserDataInFirebase(userData);

        return {'success': true, 'user': result['user']};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        print('‚ùå Firebase custom auth failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      print('‚ùå Firebase custom auth error: $e');
      return {'success': false, 'error': 'Firebase authentication failed: $e'};
    }
  }

  // Store user data in Firebase user profile
  static Future<void> _storeUserDataInFirebase(UserData userData) async {
    try {
      await js.context.callMethod('eval', ['''
        (async function() {
          const user = firebase.auth().currentUser;
          if (user) {
            // Store user data in Firebase user profile
            await user.updateProfile({
              displayName: "${userData.emplName}",
            });

            console.log('üìä User data stored in Firebase profile');
          }
        })()
      ''']);
    } catch (e) {
      print('‚ùå Failed to store user data in Firebase: $e');
    }
  }

  // Firebase Authentication Helper Methods
  static Future<Map<String, dynamic>> _firebaseSignIn(String email, String password) async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Attempting Firebase sign in for: $email');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            return await window.FirebaseAuthManager.signInWithEmailAndPassword('$email', '$password');
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase sign in successful');
        return {'success': true, 'user': result['user']};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase sign in failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase sign in error', e);
      return {'success': false, 'error': 'Firebase authentication failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> _firebaseSignOut() async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Signing out from Firebase');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            return await window.FirebaseAuthManager.signOut();
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase sign out successful');
        return {'success': true};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase sign out failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase sign out error', e);
      return {'success': false, 'error': 'Firebase sign out failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> firebaseSignInWithPhone(String phoneNumber) async {
    if (!kIsWeb) {
      return {'success': false, 'error': 'Firebase auth only available on web'};
    }

    try {
      _logger.info('Attempting Firebase phone sign in for: $phoneNumber');

      final result = await js.context.callMethod('eval', ['''
        (async function() {
          if (window.FirebaseAuthManager) {
            // Note: Phone auth requires reCAPTCHA setup in production
            // For now, this is a placeholder for future implementation
            return { success: false, error: 'Phone authentication not configured' };
          }
          return { success: false, error: 'Firebase not initialized' };
        })()
      ''']);

      if (result != null && result['success'] == true) {
        _logger.info('Firebase phone sign in successful');
        return {'success': true, 'confirmationResult': result['confirmationResult']};
      } else {
        final error = result?['error'] ?? 'Unknown Firebase error';
        _logger.warning('Firebase phone sign in failed: $error');
        return {'success': false, 'error': error};
      }
    } catch (e) {
      _logger.error('Firebase phone sign in error', e);
      return {'success': false, 'error': 'Firebase phone authentication failed: $e'};
    }
  }

  // Helper method to validate email format
  static bool _isValidEmail(String email) {
    return RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$').hasMatch(email);
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);
  static bool _firebaseInitialized = false;

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  // Initialize Firebase auth state sync
  static Future<void> initializeFirebaseSync() async {
    if (!kIsWeb || _firebaseInitialized) return;

    try {
      // Set up Firebase auth state listener
      js.context.callMethod('eval', ['''
        if (window.FirebaseAuthManager) {
          window.FirebaseAuthManager.onAuthStateChanged((user) => {
            console.log('Firebase auth state changed:', user ? 'signed in' : 'signed out');

            // Communicate with Flutter
            if (window.flutter_inappwebview && window.flutter_inappwebview.callHandler) {
              window.flutter_inappwebview.callHandler('firebase_auth_changed', {
                isSignedIn: !!user,
                uid: user ? user.uid : null,
                email: user ? user.email : null
              });
            } else {
              // For regular browser, use custom event
              window.dispatchEvent(new CustomEvent('firebaseAuthChanged', {
                detail: {
                  isSignedIn: !!user,
                  uid: user ? user.uid : null,
                  email: user ? user.email : null
                }
              }));
            }
          });
        }
      ''']);

      _firebaseInitialized = true;
    } catch (e) {
      print('Failed to initialize Firebase sync: $e');
    }
  }

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;

    print('üë§ User set in AuthManager: ${userData.userID}');
    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;

    print('üóëÔ∏è User cleared from AuthManager');
    _notifyAuthChanged();
  }

  // Restore user session from Firebase auth state
  static Future<bool> restoreUserFromFirebase() async {
    if (!kIsWeb) return false;

    try {
      print('üîÑ Checking Firebase auth state for session restoration...');

      final firebaseUser = js.context.callMethod('eval', ['''
        window.FirebaseAuthManager ? window.FirebaseAuthManager.getCurrentUser() : null
      ''']);

      if (firebaseUser != null) {
        print('‚úÖ Firebase user found, restoring session from Firebase profile');

        // Get user data from Firebase profile
        final displayName = js.context.callMethod('eval', ['''
          firebase.auth().currentUser?.displayName || 'User'
        ''']);

        final email = js.context.callMethod('eval', ['''
          firebase.auth().currentUser?.email || ''
        ''']);

        // Extract original userID from Firebase email (remove @temp.rakauth.com)
        final originalUserID = email.toString().replaceAll('@temp.rakauth.com', '');

        // Create basic user data (roles and pages would need to be stored in Firebase custom claims)
        final userData = UserData(
          emplName: displayName.toString(),
          areaCode: '', // Store in Firebase custom claims for full functionality
          roles: ['user'], // Store in Firebase custom claims for full functionality
          pages: [], // Store in Firebase custom claims for full functionality
          userID: originalUserID,
        );

        _currentUser = userData;
        _notifyAuthChanged();

        print('‚úÖ User session restored from Firebase: ${userData.userID}');
        return true;
      } else {
        print('‚ùå No Firebase user found');
      }
    } catch (e) {
      print('‚ùå Failed to restore user from Firebase: $e');
    }

    return false;
  }




  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}































class LoginRequest {
  final String userID;
  final String password;
  final String appRegId;

  const LoginRequest({
    required this.userID,
    required this.password,
    required this.appRegId,
  });

  Map<String, dynamic> toJson() => {
        'userID': userID,
        'password': password,
        'appRegId': appRegId,
      };

  factory LoginRequest.fromJson(Map<String, dynamic> json) => LoginRequest(
        userID: json['userID'] as String,
        password: json['password'] as String,
        appRegId: json['appRegId'] as String,
      );
}

class LoginResponse {
  final String msg;
  final UserData data;

  const LoginResponse({
    required this.msg,
    required this.data,
  });

  factory LoginResponse.fromJson(Map<String, dynamic> json) => LoginResponse(
        msg: json['msg'] as String,
        data: UserData.fromJson(json['data'] as Map<String, dynamic>),
      );

  Map<String, dynamic> toJson() => {
        'msg': msg,
        'data': data.toJson(),
      };
}

class UserData {
  final String emplName;
  final String areaCode;
  final List<String> roles;
  final List<String> pages;
  final String? userID; // Add userID field
  final String? appRegId; // Add appRegId field

  const UserData({
    required this.emplName,
    required this.areaCode,
    required this.roles,
    required this.pages,
    this.userID,
    this.appRegId,
  });

  factory UserData.fromJson(Map<String, dynamic> json) => UserData(
        emplName: json['emplName'] as String,
        areaCode: json['areaCode'] as String,
        roles: (json['roles'] as List<dynamic>).cast<String>(),
        pages: (json['pages'] as List<dynamic>).cast<String>(),
        userID: json['userID'] as String?,
        appRegId: json['appRegId'] as String?,
      );

  Map<String, dynamic> toJson() => {
        'emplName': emplName,
        'areaCode': areaCode,
        'roles': roles,
        'pages': pages,
        'userID': userID,
        'appRegId': appRegId,
      };

  bool hasRole(String role) => roles.contains(role);
  bool hasPage(String page) => pages.contains(page);
  bool hasAnyRole(List<String> roleList) => roleList.any((role) => roles.contains(role));
  bool hasAnyPage(List<String> pageList) => pageList.any((page) => pages.contains(page));
}

class AutoLoginRequest {
  final String appRegId;

  const AutoLoginRequest({
    required this.appRegId,
  });

  Map<String, dynamic> toJson() => {
        'appRegId': appRegId,
      };

  factory AutoLoginRequest.fromJson(Map<String, dynamic> json) => AutoLoginRequest(
        appRegId: json['appRegId'] as String,
      );
}

class LogoutRequest {
  final String appRegId;

  const LogoutRequest({
    required this.appRegId,
  });

  Map<String, dynamic> toJson() => {
        'appRegId': appRegId,
      };

  factory LogoutRequest.fromJson(Map<String, dynamic> json) => LogoutRequest(
        appRegId: json['appRegId'] as String,
      );
}






































import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter/foundation.dart';
import 'dart:async';
import 'dart:js' as js;
import '../core/services/auth_service.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with TickerProviderStateMixin {
  late AnimationController _fadeController;
  late AnimationController _scaleController;
  late AnimationController _slideController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;
  late Animation<Offset> _slideAnimation;
  late AnimationController _particleController;
  late Animation<double> _particleAnimation;

  @override
  void initState() {
    super.initState();

    // Initialize animation controllers
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );

    _slideController = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );

    _particleController = AnimationController(
      duration: const Duration(milliseconds: 3000),
      vsync: this,
    );

    // Define animations
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut),
    );

    _scaleAnimation = Tween<double>(begin: 0.5, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut),
    );

    _slideAnimation =
        Tween<Offset>(begin: const Offset(0, 0.5), end: Offset.zero).animate(
          CurvedAnimation(parent: _slideController, curve: Curves.easeOutCubic),
        );

    _particleAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _particleController, curve: Curves.easeInOut),
    );

    // Start animations
    _fadeController.forward();
    _scaleController.forward();
    _slideController.forward();
    _particleController.repeat();

    // Initialize Firebase Auth state listener for routing
    _initializeFirebaseAuthRouting();
  }

  void _initializeFirebaseAuthRouting() {
    // Try auto-login first for all platforms
    Timer(const Duration(milliseconds: 1000), () async {
      if (!mounted) return;

      try {
        print('üîÑ Attempting auto-login with stored appRegId...');
        final autoLoginSuccess = await AuthService.attemptAutoLogin();

        if (autoLoginSuccess && AuthManager.isLoggedIn) {
          print('‚úÖ Auto-login successful, navigating to home');
          await Future.delayed(const Duration(milliseconds: 500));
          if (mounted) {
            _navigateToHome();
            return;
          }
        } else {
          print('‚ùå Auto-login failed or no stored credentials');
        }

        // Fallback to platform-specific auth checks
        if (kIsWeb) {
          // For web, try Firebase session restoration as fallback
          try {
            print('üîÑ Trying Firebase session restoration as fallback...');
            final sessionRestored = await AuthManager.restoreUserFromFirebase();
            if (sessionRestored) {
              print('‚úÖ Firebase session restored as fallback');

              await Future.delayed(const Duration(milliseconds: 500));
              if (mounted && AuthManager.isLoggedIn) {
                print('‚úÖ Firebase fallback successful, navigating to home');
                _navigateToHome();
                return;
              }
            }
          } catch (e) {
            print('‚ùå Firebase session restoration failed: $e');
          }

          // Final fallback: check Firebase state
          _checkFirebaseAuthState();
        } else {
          // Non-web platforms - direct check
          if (AuthManager.isLoggedIn) {
            _navigateToHome();
          } else {
            _navigateToLogin();
          }
        }
      } catch (e) {
        print('‚ùå Auto-login attempt failed: $e');

        // Fallback to login screen
        if (mounted) {
          _navigateToLogin();
        }
      }
    });
  }

  void _checkFirebaseAuthState() {
    // Check both Firebase and Flutter auth state
    Timer.periodic(const Duration(milliseconds: 500), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }

      try {
        // Check if Firebase is initialized
        final firebaseReady = js.context['FirebaseAuthManager'] != null;

        if (firebaseReady) {
          timer.cancel();

          // Check Firebase auth state
          final currentUser = js.context.callMethod('eval', ['''
            window.FirebaseAuthManager.getCurrentUser()
          ''']);

          // If Firebase has a user, check Flutter auth state
          if (currentUser != null) {
            print('üî• Firebase user found, checking Flutter auth state');
            print('üì± Flutter isLoggedIn: ${AuthManager.isLoggedIn}');

            // Check if Flutter also has user data
            if (AuthManager.isLoggedIn) {
              print('‚úÖ Both Firebase and Flutter have user, navigating to home');
              _navigateToHome();
            } else {
              print('‚ùå Firebase user but no Flutter user data, navigating to login');
              _navigateToLogin();
            }
          } else {
            print('‚ùå No Firebase user, checking Flutter auth state');
            print('üì± Flutter isLoggedIn: ${AuthManager.isLoggedIn}');

            // No Firebase user, but check if Flutter has cached user data
            if (AuthManager.isLoggedIn) {
              print('üì± Flutter has cached user data, navigating to home');
              _navigateToHome();
            } else {
              print('‚ùå No user data, navigating to login');
              _navigateToLogin();
            }
          }
        } else if (timer.tick > 8) { // 4 seconds timeout
          timer.cancel();
          print('Firebase timeout, checking Flutter auth state');

          // Fallback to Flutter auth state
          if (AuthManager.isLoggedIn) {
            _navigateToHome();
          } else {
            _navigateToLogin();
          }
        }
      } catch (e) {
        timer.cancel();
        print('Firebase Auth routing error: \$e');

        // Fallback to Flutter auth state
        if (AuthManager.isLoggedIn) {
          _navigateToHome();
        } else {
          _navigateToLogin();
        }
      }
    });
  }

  void _navigateToLogin() {
    if (mounted) {
      context.go('/login-password');
    }
  }

  void _navigateToHome() {
    if (mounted) {
      context.go('/home');
    }
  }

  @override
  void dispose() {
    _fadeController.dispose();
    _scaleController.dispose();
    _slideController.dispose();
    _particleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: Stack(
        children: [
          // Background gradient
          Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [
                  const Color(0xFFFFFFFF),
                  const Color(0xFFF5F7FA),
                  const Color(0xFFE9ECEF),
                ],
              ),
            ),
          ),

          // Animated particles background
          AnimatedBuilder(
            animation: _particleAnimation,
            builder: (context, child) {
              return CustomPaint(
                painter: ParticlePainter(_particleAnimation.value),
                size: Size.infinite,
              );
            },
          ),

          // Main content
          Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Logo/Icon container
                // Logo/Icon container
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: ScaleTransition(
                    scale: _scaleAnimation,
                    child: Container(
                      width: 140,
                      height: 140,
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                          colors: [
                            const Color(0xFF2C5282),
                            const Color(0xFF2B6CB0),
                            const Color(0xFF3182CE),
                          ],
                        ),
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.3),
                            blurRadius: 20,
                            offset: const Offset(0, 10),
                          ),
                          BoxShadow(
                            color: const Color(0xFF3182CE).withOpacity(0.4),
                            blurRadius: 25,
                            offset: const Offset(0, 5),
                          ),
                        ],
                      ),
                      padding: const EdgeInsets.all(8),
                      child: Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.1),
                              blurRadius: 8,
                              offset: const Offset(0, 3),
                            ),
                          ],
                        ),
                        child: ClipOval(
                          child: Image.asset(
                            "assets/images/rak_logo.jpg",
                            fit: BoxFit.cover,
                            errorBuilder: (context, error, stackTrace) {
                              return const Icon(
                                Icons.business,
                                color: Color(0xFF2C5282),
                                size: 60,
                              );
                            },
                          ),
                        ),
                      ),
                    ),
                  ),
                ),

                const SizedBox(height: 40),

                // Company name
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: SlideTransition(
                    position: _slideAnimation,
                    child: Column(
                      children: [
                        Text(
                          'RAK',
                          style: TextStyle(
                            fontSize: 48,
                            fontWeight: FontWeight.bold,
                            color: const Color(0xFF2C5282),
                            letterSpacing: 3,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'WHITE CEMENT',
                          style: TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.w600,
                            color: const Color(0xFF4A5568),
                            letterSpacing: 2,
                          ),
                        ),
                        const SizedBox(height: 16),
                        Container(
                          width: 60,
                          height: 3,
                          decoration: BoxDecoration(
                            gradient: LinearGradient(
                              colors: [
                                const Color(0xFF3182CE),
                                const Color(0xFF2B6CB0),
                              ],
                            ),
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Construction Materials',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w400,
                            color: const Color(0xFF718096),
                            letterSpacing: 1,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 60),

                // Loading indicator
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: Column(
                    children: [
                      SizedBox(
                        width: 40,
                        height: 40,
                        child: CircularProgressIndicator(
                          strokeWidth: 3,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            const Color(0xFF3182CE),
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'Loading...',
                        style: TextStyle(
                          fontSize: 14,
                          color: const Color(0xFF718096),
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),

          // Bottom footer
          Positioned(
            bottom: 30,
            left: 0,
            right: 0,
            child: FadeTransition(
              opacity: _fadeAnimation,
              child: Column(
                children: [
                  Text(
                    'Est. 1980',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Ras Al Khaimah, United Arab Emirates',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w400,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ParticlePainter extends CustomPainter {
  final double animationValue;

  ParticlePainter(this.animationValue);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = Colors.blue.withOpacity(0.1);

    // Create floating particles
    for (int i = 0; i < 20; i++) {
      final x = (size.width / 20) * i + (animationValue * 50) % size.width;
      final y =
          size.height * 0.5 +
          (animationValue * 100 + i * 30) % size.height -
          size.height * 0.25;

      canvas.drawCircle(Offset(x, y), 2 + (animationValue * 2) % 3, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}
