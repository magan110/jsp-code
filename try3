// --------------------------------------------------------------------------------------
// PREREQUISITES:
// 1. Install NuGet: 'Tesseract'
// 2. Install NuGet: 'PdfiumViewer'
// 3. Install NuGet: 'PdfiumViewer.Native.x86_64.v8-xfa'
// 4. Install NuGet: 'System.Drawing.Common'
// 5. Ensure 'tessdata/eng.traineddata' exists and is set to "Copy if newer".
// --------------------------------------------------------------------------------------

using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using PdfiumViewer;
using System;
using System.Collections.Generic;
using System.Drawing.Imaging;
using System.IO;
using System.Text;
using System.Text.RegularExpressions; // Required for Key-Value extraction
using Tesseract;

namespace ocr.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class OCRController : ControllerBase
    {
        private readonly IWebHostEnvironment _env;

        public OCRController(IWebHostEnvironment env)
        {
            _env = env;
        }

        [HttpPost("upload")]
        public IActionResult UploadAndExtract(IFormFile file)
        {
            if (file == null || file.Length == 0)
            {
                return BadRequest("Please upload a valid file.");
            }

            try
            {
                string tessDataPath = Path.Combine(_env.ContentRootPath, "tessdata");

                if (!Directory.Exists(tessDataPath))
                {
                    return StatusCode(500, $"Server Error: 'tessdata' folder missing at: {tessDataPath}.");
                }

                // Initialize Tesseract
                using (var engine = new TesseractEngine(tessDataPath, "eng", EngineMode.Default))
                {
                    var resultText = new StringBuilder();
                    float totalConfidence = 0;
                    int pageCount = 0;

                    using (var memoryStream = new MemoryStream())
                    {
                        file.CopyTo(memoryStream);
                        byte[] fileBytes = memoryStream.ToArray();

                        memoryStream.Position = 0;

                        var extension = Path.GetExtension(file.FileName).ToLower();

                        if (extension == ".pdf")
                        {
                            // --- PDF HANDLING ---
                            using (var pdfDocument = PdfDocument.Load(memoryStream))
                            {
                                pageCount = pdfDocument.PageCount;

                                for (int i = 0; i < pageCount; i++)
                                {
                                    var size = pdfDocument.PageSizes[i];
                                    int width = (int)(size.Width / 72.0 * 300);
                                    int height = (int)(size.Height / 72.0 * 300);

                                    using (var bitmap = pdfDocument.Render(i, width, height, 300, 300, true))
                                    {
                                        using (var imageStream = new MemoryStream())
                                        {
                                            bitmap.Save(imageStream, System.Drawing.Imaging.ImageFormat.Png);
                                            byte[] pageBytes = imageStream.ToArray();

                                            using (var img = Pix.LoadFromMemory(pageBytes))
                                            using (var page = engine.Process(img))
                                            {
                                                // Append text with newlines to help regex parser
                                                resultText.AppendLine(page.GetText());
                                                totalConfidence += page.GetMeanConfidence();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // --- IMAGE HANDLING ---
                            pageCount = 1;
                            using (var img = Pix.LoadFromMemory(fileBytes))
                            using (var page = engine.Process(img))
                            {
                                resultText.Append(page.GetText());
                                totalConfidence = page.GetMeanConfidence();
                            }
                        }
                    }

                    string rawString = resultText.ToString();

                    // --- NEW: Extract Key-Value Pairs ---
                    var kvPairs = ExtractKeyValuePairs(rawString);

                    return Ok(new
                    {
                        FileName = file.FileName,
                        PageCount = pageCount,
                        AverageConfidence = pageCount > 0 ? (totalConfidence / pageCount) : 0,
                        KeyValuePairs = kvPairs, // Returns Dictionary<string, string>
                        RawText = rawString
                    });
                }
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"Internal Server Error: {ex.Message}");
            }
        }

        /// <summary>
        /// Parses raw text line-by-line looking for "Key: Value" patterns.
        /// </summary>
        private Dictionary<string, string> ExtractKeyValuePairs(string text)
        {
            var kvPairs = new Dictionary<string, string>();

            if (string.IsNullOrWhiteSpace(text))
                return kvPairs;

            // Split text into lines to process them individually
            var lines = text.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);

            // Regex explanation:
            // ^        -> Start of line
            // (.+?)    -> Group 1 (Key): Match 1 or more chars, lazy (stops at first colon)
            // \s*:\s* -> Separator: A colon surrounded by optional whitespace
            // (.+)     -> Group 2 (Value): Match the rest of the line
            // $        -> End of line
            var regex = new Regex(@"^(.+?)\s*[:]\s*(.+)$");

            foreach (var line in lines)
            {
                var cleanLine = line.Trim();
                var match = regex.Match(cleanLine);

                if (match.Success)
                {
                    var key = match.Groups[1].Value.Trim();
                    var value = match.Groups[2].Value.Trim();

                    // Basic filtering:
                    // 1. Ensure key isn't too long (likely garbage OCR)
                    // 2. Ensure key doesn't already exist
                    if (key.Length < 50 && !string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
                    {
                        if (!kvPairs.ContainsKey(key))
                        {
                            kvPairs.Add(key, value);
                        }
                    }
                }
            }

            return kvPairs;
        }
    }
}
