using Microsoft.AspNetCore.Mvc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using System.Data;
using System.Data.SqlClient;
using Dapper;

[ApiController]
[Route("api/[controller]")]
public class TokenScanController : ControllerBase
{
    private readonly IConfiguration _configuration;
    private readonly ILogger<TokenScanController> _logger;

    public TokenScanController(IConfiguration configuration, ILogger<TokenScanController> logger)
    {
        _configuration = configuration;
        _logger = logger;
    }

    // DTOs for request and response models
    public class TokenValidationRequest
    {
        public string TokenNumber { get; set; }
        public string AreaCode { get; set; }
        public string CustomerCode { get; set; }
        public string RandomNumber { get; set; }
        public string UserType { get; set; }
    }

    public class TokenValidationResponse
    {
        public bool IsValid { get; set; }
        public string Message { get; set; }
        public string TokenId { get; set; }
        public string ValidityDate { get; set; }
        public string ScannedBy { get; set; }
        public double TokenValue { get; set; }
        public double HandlingRate { get; set; }
        public double ScannerDeductionRate { get; set; }
        public double TokenEndValue { get; set; }
        public string ScannerMultiStatus { get; set; }
        public int ScannerMultiCount { get; set; }
        public int ScannerMultiAllowed { get; set; }
        public string UpdateIdActive { get; set; }
        public string UpdateIdMulti { get; set; }
        public string TokenDisplayValue { get; set; }
        public string BarcodeTokenType { get; set; }
        public string ExpiryFlag { get; set; }
        public string CvvNumber { get; set; }
    }

    public class TokenSubmissionRequest
    {
        public string AreaCode { get; set; }
        public string CustomerCode { get; set; }
        public string RandomNumber { get; set; }
        public string LoginId { get; set; }
        public string UserType { get; set; }
        public List<TokenDetail> Tokens { get; set; }
    }

    public class TokenDetail
    {
        public string TokenNumber { get; set; }
        public string InfluencerCode { get; set; }
        public string InfluencerName { get; set; }
        public string MobileNumber { get; set; }
        public string CvvNumber { get; set; }
    }

    public class TokenSubmissionResponse
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public string DocumentNumber { get; set; }
        public int ValidTokens { get; set; }
        public int InvalidTokens { get; set; }
        public int ExpiredTokens { get; set; }
        public int AlreadyScannedTokens { get; set; }
        public double TotalAmount { get; set; }
        public double HandlingAmount { get; set; }
        public double DeductionAmount { get; set; }
        public double NetAmount { get; set; }
    }

    // Validate a single token when QR code is scanned
    [HttpPost("validate")]
    public async Task<ActionResult<TokenValidationResponse>> ValidateToken([FromBody] TokenValidationRequest request)
    {
        try
        {
            using (var connection = new SqlConnection(_configuration.GetConnectionString("DefaultConnection")))
            {
                await connection.OpenAsync();
                
                // Check for duplicate entry in the same session
                var parameters = new DynamicParameters();
                parameters.Add("@TokenNumber", request.TokenNumber);
                parameters.Add("@AreaCode", request.AreaCode);
                parameters.Add("@CustomerCode", request.CustomerCode);
                parameters.Add("@RandomNumber", request.RandomNumber);
                
                // Call stored procedure or SQL query to validate token
                var sql = @"EXEC bwlive.dbo.dppToknProc 'jav01', @TokenNumber, 0;
                            SELECT 
                                bcTknTyp, tokenVal, handRate, scnrDdRt, tokEndVl, 
                                prodCode, updateId, dbActSts, exprFlag
                            FROM dpmTokenNos 
                            WHERE tokenNum = @TokenNumber;
                            
                            SELECT 
                                isActive, scnMlCnt, scnMlAlw, ISNULL(updateId, '')
                            FROM dpmToknMlSc 
                            WHERE tokenNum = @TokenNumber 
                            AND isActive='Y' 
                            AND scnMlCnt < scnMlAlw;
                            
                            SELECT dbo.dpfTknValDt(bcTknTyp, @AreaCode) as ValidityDate";
                
                using (var multi = await connection.QueryMultipleAsync(sql, parameters))
                {
                    var tokenDetails = await multi.ReadAsync<dynamic>();
                    var multiScanDetails = await multi.ReadAsync<dynamic>();
                    var validityDate = await multi.ReadFirstOrDefaultAsync<dynamic>();

                    if (tokenDetails == null || !tokenDetails.Any())
                    {
                        return new TokenValidationResponse
                        {
                            IsValid = false,
                            Message = "Token not found"
                        };
                    }

                    var token = tokenDetails.First();
                    var multiScan = multiScanDetails.FirstOrDefault();

                    // Check if token is expired
                    if (token.exprFlag == "Y")
                    {
                        return new TokenValidationResponse
                        {
                            IsValid = false,
                            Message = "Token has expired",
                            ExpiryFlag = "Y"
                        };
                    }

                    // Check if token is already scanned
                    if (token.dbActSts == "Z")
                    {
                        return new TokenValidationResponse
                        {
                            IsValid = false,
                            Message = $"Token already scanned by {token.updateId}",
                            TokenId = token.tokenIdn,
                            ScannedBy = token.updateId
                        };
                    }

                    // Check if token is in theft category
                    if (token.dbActSts == "T")
                    {
                        return new TokenValidationResponse
                        {
                            IsValid = false,
                            Message = "Token is in theft category. Please report to company officer."
                        };
                    }

                    // Check multi-scan restrictions
                    string scannerMultiStatus = "";
                    int scannerMultiCount = 0;
                    int scannerMultiAllowed = 0;

                    if (multiScan != null)
                    {
                        scannerMultiStatus = multiScan.isActive;
                        scannerMultiCount = multiScan.scnMlCnt;
                        scannerMultiAllowed = multiScan.scnMlAlw;

                        if (scannerMultiCount >= scannerMultiAllowed)
                        {
                            return new TokenValidationResponse
                            {
                                IsValid = false,
                                Message = "Token scan limit exceeded"
                            };
                        }
                    }

                    // Calculate token end value
                    double tokenEndValue = token.tokenVal + token.handRate - token.scnrDdRt;

                    return new TokenValidationResponse
                    {
                        IsValid = true,
                        Message = "Token is valid",
                        TokenId = token.tokenIdn,
                        ValidityDate = validityDate?.ValidityDate?.ToString("yyyy-MM-dd"),
                        ScannedBy = token.updateId,
                        TokenValue = token.tokenVal,
                        HandlingRate = token.handRate,
                        ScannerDeductionRate = token.scnrDdRt,
                        TokenEndValue = tokenEndValue,
                        ScannerMultiStatus = scannerMultiStatus,
                        ScannerMultiCount = scannerMultiCount,
                        ScannerMultiAllowed = scannerMultiAllowed,
                        UpdateIdActive = token.updateId,
                        UpdateIdMulti = multiScan?.updateId,
                        TokenDisplayValue = token.tokenVal.ToString("F2"),
                        BarcodeTokenType = token.bcTknTyp,
                        ExpiryFlag = token.exprFlag,
                        CvvNumber = token.cvvNo
                    };
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error validating token: {TokenNumber}", request.TokenNumber);
            return StatusCode(500, new TokenValidationResponse
            {
                IsValid = false,
                Message = "An error occurred while validating the token"
            });
        }
    }

    // Submit a batch of tokens for processing
    [HttpPost("submit")]
    public async Task<ActionResult<TokenSubmissionResponse>> SubmitTokens([FromBody] TokenSubmissionRequest request)
    {
        try
        {
            using (var connection = new SqlConnection(_configuration.GetConnectionString("DefaultConnection")))
            {
                await connection.OpenAsync();
                
                // Begin transaction
                using (var transaction = connection.BeginTransaction())
                {
                    try
                    {
                        // Generate document number
                        var docNumber = await GetDocumentNumber(connection, transaction, "TKN", request.AreaCode);
                        
                        // Update test table with random number
                        await connection.ExecuteAsync(
                            "UPDATE dptTknTestg SET docuNumb = @DocNumber WHERE uniqueId = @RandomNumber AND createDt > GETDATE()-1",
                            new { DocNumber = docNumber, RandomNumber = request.RandomNumber },
                            transaction);

                        // Process each token
                        int validTokens = 0;
                        int invalidTokens = 0;
                        int expiredTokens = 0;
                        int alreadyScannedTokens = 0;
                        double totalTokenValue = 0;
                        double totalHandlingAmount = 0;
                        double totalDeductionAmount = 0;

                        foreach (var token in request.Tokens)
                        {
                            // Get token details
                            var tokenDetails = await connection.QueryFirstOrDefaultAsync<dynamic>(
                                @"EXEC bwlive.dbo.dppToknProc 'jav01', @TokenNumber, 0;
                                  SELECT bcTknTyp, tokenVal, handRate, scnrDdRt, tokEndVl, prodCode, updateId, dbActSts, exprFlag
                                  FROM dpmTokenNos 
                                  WHERE tokenNum = @TokenNumber",
                                new { TokenNumber = token.TokenNumber },
                                transaction);

                            if (tokenDetails == null)
                            {
                                invalidTokens++;
                                continue;
                            }

                            // Check token status
                            if (tokenDetails.exprFlag == "Y")
                            {
                                expiredTokens++;
                                continue;
                            }

                            if (tokenDetails.dbActSts == "Z")
                            {
                                alreadyScannedTokens++;
                                continue;
                            }

                            // Insert into test table
                            await connection.ExecuteAsync(
                                @"INSERT INTO dpmTknTestg (docuNumb, tokenNum, mobileNo, influencerName, influencerCode, createId, createDt)
                                  VALUES (@DocNumber, @TokenNumber, @MobileNumber, @InfluencerName, @InfluencerCode, @LoginId, GETDATE())",
                                new
                                {
                                    DocNumber = docNumber,
                                    TokenNumber = token.TokenNumber,
                                    MobileNumber = token.MobileNumber,
                                    InfluencerName = token.InfluencerName,
                                    InfluencerCode = token.InfluencerCode,
                                    LoginId = request.LoginId
                                },
                                transaction);

                            // Update token status
                            var updateCount = await connection.ExecuteAsync(
                                @"UPDATE dpmTokenNos 
                                  SET isActive = 'Z', updateId = @LoginId, updateDt = GETDATE() 
                                  WHERE tokenNum = @TokenNumber 
                                  AND CASE WHEN GETDATE() > dbo.dpfTknValDt(@bcTknTyp, @AreaCode) 
                                           THEN CAST(GETDATE() - printgDt AS SMALLINT) 
                                           ELSE 1 END <= validDay + dbo.dpfTknValDy(@bcTknTyp, @AreaCode)
                                  AND isActive = 'Y'",
                                new
                                {
                                    TokenNumber = token.TokenNumber,
                                    LoginId = request.LoginId,
                                    bcTknTyp = tokenDetails.bcTknTyp,
                                    AreaCode = request.AreaCode
                                },
                                transaction);

                            // Insert into token details table
                            await connection.ExecuteAsync(
                                @"INSERT INTO dptTokenRecDtl (docuNumb, tokenNum, tokenVld, exprFlag, toknStat, bcTknTyp, tokenVal, handRate, tokEndVl, prodCode, influencerCode, statFlag, createId, createDt)
                                  VALUES (@DocNumber, @TokenNumber, @TokenValid, @ExpiryFlag, @TokenStatus, @BarcodeTokenType, @TokenValue, @HandlingRate, @TokenEndValue, @ProductCode, @InfluencerCode, 'A', @LoginId, GETDATE())",
                                new
                                {
                                    DocNumber = docNumber,
                                    TokenNumber = token.TokenNumber,
                                    TokenValid = "Y",
                                    ExpiryFlag = tokenDetails.exprFlag,
                                    TokenStatus = tokenDetails.dbActSts,
                                    BarcodeTokenType = tokenDetails.bcTknTyp,
                                    TokenValue = tokenDetails.tokenVal,
                                    HandlingRate = tokenDetails.handRate,
                                    TokenEndValue = tokenDetails.tokEndVl,
                                    ProductCode = tokenDetails.prodCode,
                                    InfluencerCode = token.InfluencerCode,
                                    LoginId = request.LoginId
                                },
                                transaction);

                            // Update totals
                            validTokens++;
                            totalTokenValue += tokenDetails.tokenVal;
                            totalHandlingAmount += tokenDetails.handRate;
                            totalDeductionAmount += tokenDetails.scnrDdRt;
                        }

                        // Calculate net amount
                        double netAmount = totalTokenValue + totalHandlingAmount - totalDeductionAmount;

                        // Insert into token receipt header
                        await connection.ExecuteAsync(
                            @"INSERT INTO cdtTokenRec (docuNumb, docuDate, tokenTyp, cdnDocTy, custCode, prodCode, recptQty, basTknAm, handAmnt, scnDedAm, payblAmt, statFlag, createId, createDt)
                              VALUES (@DocNumber, GETDATE(), 'BC', 'CRN', @CustomerCode, 0, @ValidTokens, @TotalTokenValue, @TotalHandlingAmount, @TotalDeductionAmount, @NetAmount, 'A', @LoginId, GETDATE())",
                            new
                            {
                                DocNumber = docNumber,
                                CustomerCode = request.CustomerCode,
                                ValidTokens = validTokens,
                                TotalTokenValue = totalTokenValue,
                                TotalHandlingAmount = totalHandlingAmount,
                                TotalDeductionAmount = totalDeductionAmount,
                                NetAmount = netAmount,
                                LoginId = request.LoginId
                            },
                            transaction);

                        // Commit transaction
                        transaction.Commit();

                        return new TokenSubmissionResponse
                        {
                            Success = true,
                            Message = "Tokens submitted successfully",
                            DocumentNumber = docNumber,
                            ValidTokens = validTokens,
                            InvalidTokens = invalidTokens,
                            ExpiredTokens = expiredTokens,
                            AlreadyScannedTokens = alreadyScannedTokens,
                            TotalAmount = totalTokenValue,
                            HandlingAmount = totalHandlingAmount,
                            DeductionAmount = totalDeductionAmount,
                            NetAmount = netAmount
                        };
                    }
                    catch (Exception)
                    {
                        transaction.Rollback();
                        throw;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error submitting tokens for user: {LoginId}", request.LoginId);
            return StatusCode(500, new TokenSubmissionResponse
            {
                Success = false,
                Message = "An error occurred while submitting tokens"
            });
        }
    }

    private async Task<string> GetDocumentNumber(IDbConnection connection, IDbTransaction transaction, string docType, string areaCode)
    {
        // This would typically call a stored procedure or sequence to get the next document number
        // For simplicity, we'll generate a formatted number
        var result = await connection.QueryFirstOrDefaultAsync<string>(
            "SELECT dbo.fnGetNextDocumentNumber(@DocType, @AreaCode)",
            new { DocType = docType, AreaCode = areaCode },
            transaction);
        
        return result ?? $"{docType}{areaCode}{DateTime.Now:yyyyMMddHHmmss}";
    }
}
