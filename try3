using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using PdfiumViewer;
using System;
using System.Collections.Generic;
using System.Drawing.Imaging; // For ImageFormat
using System.IO;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Tesseract;

// Resolve conflict between Tesseract.ImageFormat and System.Drawing.Imaging.ImageFormat
using SysDrawFmt = System.Drawing.Imaging.ImageFormat;

namespace ocr.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class OCRController : ControllerBase
    {
        private readonly IWebHostEnvironment _env;

        // --- CONFIGURATION ---
        // Port 8080 (As confirmed by your "ollama serve" logs)
        private const string OllamaEndpoint = "http://localhost:8080/api/generate";

        // Faster 1B Model (As downloaded)
        private const string OllamaModel = "qwen2.5:1.5b";

        // Increased timeout to 10 minutes to prevent "Task Canceled" errors on CPU
        private static readonly HttpClient _httpClient = new HttpClient
        {
            Timeout = TimeSpan.FromSeconds(600)
        };

        public OCRController(IWebHostEnvironment env)
        {
            _env = env;
        }

        [HttpPost("upload")]
        public async Task<IActionResult> UploadAndExtract(IFormFile file)
        {
            if (file == null || file.Length == 0) return BadRequest("Invalid file.");

            try
            {
                string tessDataPath = Path.Combine(_env.ContentRootPath, "tessdata");
                if (!Directory.Exists(tessDataPath))
                    return StatusCode(500, $"Server Error: 'tessdata' folder missing at: {tessDataPath}");

                // 1. Run Tesseract OCR
                var sbRawText = new StringBuilder();
                float totalConfidence = 0;
                int pageCount = 0;

                using (var engine = new TesseractEngine(tessDataPath, "eng", EngineMode.LstmOnly))
                {
                    engine.DefaultPageSegMode = PageSegMode.Auto;

                    using (var memoryStream = new MemoryStream())
                    {
                        await file.CopyToAsync(memoryStream);
                        byte[] fileBytes = memoryStream.ToArray();
                        memoryStream.Position = 0;

                        var extension = Path.GetExtension(file.FileName).ToLower();

                        if (extension == ".pdf")
                        {
                            try
                            {
                                using (var pdfDocument = PdfDocument.Load(memoryStream))
                                {
                                    pageCount = pdfDocument.PageCount;
                                    for (int i = 0; i < pageCount; i++)
                                    {
                                        // Render PDF to Image (300 DPI)
                                        var size = pdfDocument.PageSizes[i];
                                        int width = (int)(size.Width / 72.0 * 300);
                                        int height = (int)(size.Height / 72.0 * 300);

                                        using (var bitmap = pdfDocument.Render(i, width, height, 300, 300, true))
                                        using (var imageStream = new MemoryStream())
                                        {
                                            // Explicitly use System.Drawing.Imaging via alias
                                            bitmap.Save(imageStream, SysDrawFmt.Png);
                                            ProcessImage(engine, imageStream.ToArray(), sbRawText, ref totalConfidence);
                                        }
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                return BadRequest($"PDF Error: {ex.Message}. Ensure PdfiumViewer native DLLs are installed.");
                            }
                        }
                        else
                        {
                            // Image files
                            pageCount = 1;
                            ProcessImage(engine, fileBytes, sbRawText, ref totalConfidence);
                        }
                    }
                }

                string rawString = sbRawText.ToString();

                // 2. Extract Structured Data with AI
                Dictionary<string, string> kvPairs;
                try
                {
                    kvPairs = await ExtractKeyValuePairsWithOllama(rawString);
                }
                catch (Exception ex)
                {
                    kvPairs = new Dictionary<string, string> {
                        { "Error", "AI Extraction Failed" },
                        { "Details", ex.Message }
                    };
                }

                return Ok(new
                {
                    FileName = file.FileName,
                    PageCount = pageCount,
                    AverageConfidence = pageCount > 0 ? (totalConfidence / pageCount) : 0,
                    ExtractedData = kvPairs,
                    RawText = rawString
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"Internal Server Error: {ex.Message}");
            }
        }

        private async Task<Dictionary<string, string>> ExtractKeyValuePairsWithOllama(string text)
        {
            if (string.IsNullOrWhiteSpace(text)) return new Dictionary<string, string>();

            // Clean the text to help the 1B model understand it better
            string cleanText = text.Replace("\r", " ").Replace("\n", " ");
            while (cleanText.Contains("  ")) { cleanText = cleanText.Replace("  ", " "); }
            if (cleanText.Length > 2500) cleanText = cleanText.Substring(0, 2500);

            // --- SIMPLE "EXTRACT ALL" PROMPT ---
            var prompt = $@"
        Analyze the OCR text.
        Extract all meaningful data fields into a single JSON object.
        
        STRUCTURAL RULES:
        1. Return a FLAT object (Key: Value). 
        2. Do NOT use nested objects, arrays, or Schema.org formats.
        3. Values must be simple strings or numbers only.
        4. Use the exact labels found in the text as Keys where possible.

        OCR TEXT:
        {cleanText}
    ";

            var requestBody = new
            {
                model = OllamaModel,
                prompt = prompt,
                stream = false,
                format = "json",
                temperature = 0.1
            };

            var jsonContent = new StringContent(
                JsonSerializer.Serialize(requestBody),
                Encoding.UTF8,
                "application/json");

            var response = await _httpClient.PostAsync(OllamaEndpoint, jsonContent);
            response.EnsureSuccessStatusCode();

            var responseString = await response.Content.ReadAsStringAsync();

            using (JsonDocument doc = JsonDocument.Parse(responseString))
            {
                if (doc.RootElement.TryGetProperty("response", out var responseElement))
                {
                    string innerJson = responseElement.GetString();
                    innerJson = innerJson.Replace("```json", "").Replace("```", "").Trim();

                    // --- CRITICAL: Handle Dynamic Keys ---
                    // Since we don't know what keys the AI will invent, we must use <string, object>
                    // to catch numbers, booleans, and strings without crashing.
                    var safeDict = JsonSerializer.Deserialize<Dictionary<string, object>>(innerJson);

                    var resultDict = new Dictionary<string, string>();
                    foreach (var kvp in safeDict)
                    {
                        // Safely convert whatever the AI found into a string
                        resultDict[kvp.Key] = kvp.Value?.ToString();
                    }
                    return resultDict;
                }
            }

            return new Dictionary<string, string>();
        }

        private void ProcessImage(TesseractEngine engine, byte[] imageBytes, StringBuilder resultText, ref float totalConfidence)
        {
            try
            {
                using (var img = Pix.LoadFromMemory(imageBytes))
                using (var deskewed = img.Deskew())
                {
                    var imageToProcess = deskewed ?? img;
                    using (var page = engine.Process(imageToProcess))
                    {
                        var text = page.GetText();
                        var conf = page.GetMeanConfidence();

                        if (!string.IsNullOrWhiteSpace(text))
                        {
                            resultText.AppendLine(text);
                        }
                        if (conf > 0.0f)
                        {
                            totalConfidence += conf;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                resultText.AppendLine($"[Error: {ex.Message}]");
            }
        }
    }
}
