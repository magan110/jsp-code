import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';

class FirebaseAuthService {
  static final FirebaseAuthService _instance = FirebaseAuthService._internal();
  factory FirebaseAuthService() => _instance;
  FirebaseAuthService._internal();

  final FirebaseAuth _auth = FirebaseAuth.instance;

  /// Generate a unique app registration ID using Firebase
  Future<String> generateAppRegId(String userID) async {
    try {
      // Create anonymous user for generating unique token
      UserCredential userCredential = await _auth.signInAnonymously();

      // Get the ID token which serves as appRegId
      String? idToken = await userCredential.user?.getIdToken();

      if (idToken != null) {
        return idToken;
      } else {
        throw Exception('Failed to generate Firebase token');
      }
    } catch (e) {
      print('Firebase token generation failed: $e');
      // Fallback to timestamp-based ID
      return _generateFallbackAppRegId(userID);
    }
  }

  /// Verify if the appRegId (Firebase token) is valid
  Future<bool> verifyAppRegId(String appRegId) async {
    try {
      // Try to parse the token to check if it's valid
      if (appRegId.isEmpty) return false;

      // Check if current user exists and token is not expired
      User? currentUser = _auth.currentUser;
      if (currentUser != null) {
        String? currentToken = await currentUser.getIdToken(false);
        return currentToken == appRegId;
      }

      return false;
    } catch (e) {
      print('Token verification failed: $e');
      return false;
    }
  }

  /// Sign out and invalidate the current token
  Future<void> signOutAndInvalidateToken() async {
    try {
      await _auth.signOut();
    } catch (e) {
      print('Sign out failed: $e');
    }
  }

  /// Get current user's token
  Future<String?> getCurrentToken() async {
    try {
      User? currentUser = _auth.currentUser;
      if (currentUser != null) {
        return await currentUser.getIdToken();
      }
      return null;
    } catch (e) {
      print('Get current token failed: $e');
      return null;
    }
  }

  /// Refresh current token
  Future<String?> refreshToken() async {
    try {
      User? currentUser = _auth.currentUser;
      if (currentUser != null) {
        return await currentUser.getIdToken(true); // Force refresh
      }
      return null;
    } catch (e) {
      print('Refresh token failed: $e');
      return null;
    }
  }

  /// Fallback method to generate appRegId without Firebase
  String _generateFallbackAppRegId(String userID) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final random = DateTime.now().microsecond;
    return 'APP_${userID}_${timestamp}_$random';
  }

  /// Check if Firebase is initialized
  Future<bool> isFirebaseInitialized() async {
    try {
      return Firebase.apps.isNotEmpty;
    } catch (e) {
      return false;
    }
  }

  /// Initialize Firebase if not already initialized
  Future<void> initializeFirebase() async {
    try {
      if (Firebase.apps.isEmpty) {
        await Firebase.initializeApp();
      }
    } catch (e) {
      print('Firebase initialization failed: $e');
    }
  }
}


































import 'dart:async';

import 'package:flutter/material.dart';

import 'package:flutter_web_plugins/url_strategy.dart';
import 'package:firebase_core/firebase_core.dart';

import 'core/theme/theme.dart';

import 'core/di/service_locator.dart';

import 'core/navigation/app_router.dart';
import 'core/services/firebase_auth_service.dart';
import 'firebase_options.dart';

final RouteObserver<PageRoute> routeObserver = RouteObserver<PageRoute>();

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Keep hash URLs for Flutter Web (prevents 404s on hard refresh)
  setUrlStrategy(const HashUrlStrategy());

  // Global error handlers (surface real stack traces on web)
  FlutterError.onError = (FlutterErrorDetails details) {
    FlutterError.dumpErrorToConsole(details);
    // You can also send to your logger/telemetry here
  };

  await runZonedGuarded<Future<void>>(
    () async {
      // Initialize Firebase Auth Service
      await FirebaseAuthService().initializeFirebase();

      // Ensure services are ready before runApp
      await setupServiceLocator();

      runApp(const MyApp());
    },
    (error, stack) {
      debugPrint('Zoned error: $error');
      debugPrint('$stack');
    },
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      debugShowCheckedModeBanner: false,

      title: 'RAK Business Management',

      theme: AppTheme.lightTheme,

      themeMode: ThemeMode.light,

      routerConfig: AppRouter.router,
    );
  }
}



































// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyArL5abZZ-CmPwXoTNGVahTH3OR0YcSf40',
    appId: '1:929132248851:web:a8c293dbac7828737fa4e6',
    messagingSenderId: '929132248851',
    projectId: 'rak-test-e2762',
    authDomain: 'rak-test-e2762.firebaseapp.com',
    storageBucket: 'rak-test-e2762.firebasestorage.app',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyArL5abZZ-CmPwXoTNGVahTH3OR0YcSf40',
    appId: '1:929132248851:android:a8c293dbac7828737fa4e6',
    messagingSenderId: '929132248851',
    projectId: 'rak-test-e2762',
    storageBucket: 'rak-test-e2762.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyArL5abZZ-CmPwXoTNGVahTH3OR0YcSf40',
    appId: '1:929132248851:ios:a8c293dbac7828737fa4e6',
    messagingSenderId: '929132248851',
    projectId: 'rak-test-e2762',
    storageBucket: 'rak-test-e2762.firebasestorage.app',
    iosBundleId: 'com.example.rakWeb',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyArL5abZZ-CmPwXoTNGVahTH3OR0YcSf40',
    appId: '1:929132248851:ios:a8c293dbac7828737fa4e6',
    messagingSenderId: '929132248851',
    projectId: 'rak-test-e2762',
    storageBucket: 'rak-test-e2762.firebasestorage.app',
    iosBundleId: 'com.example.rakWeb',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyArL5abZZ-CmPwXoTNGVahTH3OR0YcSf40',
    appId: '1:929132248851:web:a8c293dbac7828737fa4e6',
    messagingSenderId: '929132248851',
    projectId: 'rak-test-e2762',
    authDomain: 'rak-test-e2762.firebaseapp.com',
    storageBucket: 'rak-test-e2762.firebasestorage.app',
  );
}




































import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import '../models/auth_models.dart';
import '../utils/app_logger.dart';
import 'firebase_auth_service.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);
  static final FirebaseAuthService _firebaseAuth = FirebaseAuthService();

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';
  static const String autoLoginEndpoint = '/api/Auth/auto-login';
  static const String logoutEndpoint = '/api/Auth/logout';
  static const String validateTokenEndpoint = '/api/Auth/validate-token';

  static const String _appRegIdKey = 'app_reg_id';
  static const String _userDataKey = 'user_data';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      // Generate Firebase-based appRegId if not provided
      String finalAppRegId;
      if (appRegId != null) {
        finalAppRegId = appRegId;
      } else {
        try {
          finalAppRegId = await _firebaseAuth.generateAppRegId(userID);
          _logger.info('Generated Firebase appRegId for user: $userID');
        } catch (e) {
          _logger.warning('Firebase appRegId generation failed, using fallback: $e');
          finalAppRegId = 'mobile_app_${DateTime.now().millisecondsSinceEpoch}';
        }
      }

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId: finalAppRegId,
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          // Store appRegId and user data locally
          await _storeAuthData(finalAppRegId, loginResponse.data);

          return {
            'success': true,
            'data': loginResponse,
            'appRegId': finalAppRegId,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    final result = await authenticateUser(userID: userId, password: password);
    if (result['success'] == true) {
      final loginResponse = result['data'] as LoginResponse;
      // Create a new UserData instance with the userID preserved
      final userDataWithId = UserData(
        emplName: loginResponse.data.emplName,
        areaCode: loginResponse.data.areaCode,
        roles: loginResponse.data.roles,
        pages: loginResponse.data.pages,
        userID: userId, // Preserve the original userID from login
      );
      AuthManager.setUser(userDataWithId);
      return true;
    }
    return false;
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final storedAppRegId = prefs.getString(_appRegIdKey);

      if (storedAppRegId != null) {
        // Call logout API
        try {
          final uri = Uri.parse('$baseUrl$logoutEndpoint');
          final response = await http.post(
            uri,
            headers: {'Content-Type': 'application/json'},
            body: jsonEncode({'appRegId': storedAppRegId}),
          ).timeout(_defaultTimeout);

          _logger.info('Logout API called with status: ${response.statusCode}');
        } catch (e) {
          _logger.warning('Logout API call failed: $e');
        }

        // Sign out from Firebase
        try {
          await _firebaseAuth.signOutAndInvalidateToken();
          _logger.info('Firebase sign out successful');
        } catch (e) {
          _logger.warning('Firebase sign out failed: $e');
        }
      }

      // Clear local storage
      await _clearAuthData();
      _logger.info('Local auth data cleared');
    } catch (e) {
      _logger.error('Error during logout: $e');
    }

    AuthManager.clearUser();
    await Future.delayed(const Duration(milliseconds: 500));
  }

  /// Auto login using stored appRegId
  static Future<Map<String, dynamic>> autoLogin() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final storedAppRegId = prefs.getString(_appRegIdKey);

      if (storedAppRegId == null) {
        _logger.info('No stored appRegId found');
        return {
          'success': false,
          'error': 'No stored credentials',
        };
      }

      // Verify Firebase token first
      bool isValidToken = await _firebaseAuth.verifyAppRegId(storedAppRegId);
      if (!isValidToken) {
        _logger.warning('Stored Firebase token is invalid');
        await _clearAuthData();
        return {
          'success': false,
          'error': 'Token expired',
        };
      }

      final uri = Uri.parse('$baseUrl$autoLoginEndpoint');
      final response = await http.post(
        uri,
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({'appRegId': storedAppRegId}),
      ).timeout(_defaultTimeout);

      _logger.debug('Auto-login response status: ${response.statusCode}');
      _logger.debug('Auto-login response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        if (responseData['msg'] == 'Auto-login successful') {
          final userData = responseData['data'];

          // Update stored user data
          await _storeUserData(userData);

          // Set user in AuthManager
          final userDataModel = UserData(
            userID: userData['userID'],
            emplName: userData['emplName'],
            areaCode: userData['areaCode'],
            roles: List<String>.from(userData['roles'] ?? []),
            pages: List<String>.from(userData['pages'] ?? []),
          );

          AuthManager.setUser(userDataModel);
          _logger.info('Auto-login successful for user: ${userData['userID']}');

          return {
            'success': true,
            'data': userDataModel,
            'appRegId': storedAppRegId,
          };
        }
      }

      // Clear invalid credentials
      await _clearAuthData();
      _logger.warning('Auto-login failed, cleared stored credentials');

      return {
        'success': false,
        'error': 'Auto-login failed',
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Auto-login error: $e');
      return {
        'success': false,
        'error': 'Auto-login failed: $e',
      };
    }
  }

  /// Check if user is logged in
  static Future<bool> isLoggedIn() async {
    final prefs = await SharedPreferences.getInstance();
    final storedAppRegId = prefs.getString(_appRegIdKey);

    if (storedAppRegId == null) return false;

    // Verify Firebase token
    return await _firebaseAuth.verifyAppRegId(storedAppRegId);
  }

  /// Store authentication data locally
  static Future<void> _storeAuthData(String appRegId, UserData userData) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_appRegIdKey, appRegId);
    await prefs.setString(_userDataKey, jsonEncode(userData.toJson()));
    _logger.debug('Stored auth data locally');
  }

  /// Store user data locally
  static Future<void> _storeUserData(Map<String, dynamic> userData) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_userDataKey, jsonEncode(userData));
    _logger.debug('Updated stored user data');
  }

  /// Clear all stored authentication data
  static Future<void> _clearAuthData() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_appRegIdKey);
    await prefs.remove(_userDataKey);
    _logger.debug('Cleared all stored auth data');
  }

  /// Validate token with server - utility method for testing
  static Future<Map<String, dynamic>> validateToken(String appRegId) async {
    try {
      final uri = Uri.parse('$baseUrl$validateTokenEndpoint');
      final response = await http.post(
        uri,
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({'appRegId': appRegId}),
      ).timeout(_defaultTimeout);

      _logger.debug('Validate token response status: ${response.statusCode}');
      _logger.debug('Validate token response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;
        return {
          'success': true,
          'firebaseValid': responseData['firebaseValid'] ?? false,
          'databaseValid': responseData['databaseValid'] ?? false,
          'isValid': responseData['isValid'] ?? false,
          'userID': responseData['userID'],
          'lastUpdate': responseData['lastUpdate'],
        };
      } else {
        return {
          'success': false,
          'error': 'Server responded with status ${response.statusCode}',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token validation error: $e');
      return {
        'success': false,
        'error': 'Token validation failed: $e',
      };
    }
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;
    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;
    _notifyAuthChanged();
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}



































import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'dart:async';
import '../core/services/auth_service.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with TickerProviderStateMixin {
  late AnimationController _fadeController;
  late AnimationController _scaleController;
  late AnimationController _slideController;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;
  late Animation<Offset> _slideAnimation;
  late AnimationController _particleController;
  late Animation<double> _particleAnimation;

  @override
  void initState() {
    super.initState();

    // Initialize animation controllers
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );

    _slideController = AnimationController(
      duration: const Duration(milliseconds: 1200),
      vsync: this,
    );

    _particleController = AnimationController(
      duration: const Duration(milliseconds: 3000),
      vsync: this,
    );

    // Define animations
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut),
    );

    _scaleAnimation = Tween<double>(begin: 0.5, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut),
    );

    _slideAnimation =
        Tween<Offset>(begin: const Offset(0, 0.5), end: Offset.zero).animate(
          CurvedAnimation(parent: _slideController, curve: Curves.easeOutCubic),
        );

    _particleAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _particleController, curve: Curves.easeInOut),
    );

    // Start animations
    _fadeController.forward();
    _scaleController.forward();
    _slideController.forward();
    _particleController.repeat();

    // Check for auto-login after animations start
    Timer(const Duration(milliseconds: 2000), () async {
      if (mounted) {
        await _checkAutoLogin();
      }
    });
  }

  Future<void> _checkAutoLogin() async {
    try {
      // Show loading message
      if (mounted) {
        setState(() {
          // Update loading text if needed
        });
      }

      // Attempt auto-login
      final result = await AuthService.autoLogin();

      if (!mounted) return;

      if (result['success'] == true) {
        // Auto-login successful, navigate to home
        context.go('/home');
      } else {
        // Auto-login failed, navigate to login
        context.go('/login-password');
      }
    } catch (e) {
      // On error, navigate to login
      if (mounted) {
        context.go('/login-password');
      }
    }
  }

  void _navigateToNextScreen() {
    // Navigate to login - let the router handle authentication logic
    context.go('/login-password');
  }

  @override
  void dispose() {
    _fadeController.dispose();
    _scaleController.dispose();
    _slideController.dispose();
    _particleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      body: Stack(
        children: [
          // Background gradient
          Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [
                  const Color(0xFFFFFFFF),
                  const Color(0xFFF5F7FA),
                  const Color(0xFFE9ECEF),
                ],
              ),
            ),
          ),

          // Animated particles background
          AnimatedBuilder(
            animation: _particleAnimation,
            builder: (context, child) {
              return CustomPaint(
                painter: ParticlePainter(_particleAnimation.value),
                size: Size.infinite,
              );
            },
          ),

          // Main content
          Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Logo/Icon container
                // Logo/Icon container
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: ScaleTransition(
                    scale: _scaleAnimation,
                    child: Container(
                      width: 140,
                      height: 140,
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          begin: Alignment.topLeft,
                          end: Alignment.bottomRight,
                          colors: [
                            const Color(0xFF2C5282),
                            const Color(0xFF2B6CB0),
                            const Color(0xFF3182CE),
                          ],
                        ),
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.3),
                            blurRadius: 20,
                            offset: const Offset(0, 10),
                          ),
                          BoxShadow(
                            color: const Color(0xFF3182CE).withOpacity(0.4),
                            blurRadius: 25,
                            offset: const Offset(0, 5),
                          ),
                        ],
                      ),
                      padding: const EdgeInsets.all(8),
                      child: Container(
                        decoration: BoxDecoration(
                          color: Colors.white,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.1),
                              blurRadius: 8,
                              offset: const Offset(0, 3),
                            ),
                          ],
                        ),
                        child: ClipOval(
                          child: Image.asset(
                            "assets/images/rak_logo.jpg",
                            fit: BoxFit.cover,
                            errorBuilder: (context, error, stackTrace) {
                              return const Icon(
                                Icons.business,
                                color: Color(0xFF2C5282),
                                size: 60,
                              );
                            },
                          ),
                        ),
                      ),
                    ),
                  ),
                ),

                const SizedBox(height: 40),

                // Company name
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: SlideTransition(
                    position: _slideAnimation,
                    child: Column(
                      children: [
                        Text(
                          'RAK',
                          style: TextStyle(
                            fontSize: 48,
                            fontWeight: FontWeight.bold,
                            color: const Color(0xFF2C5282),
                            letterSpacing: 3,
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'WHITE CEMENT',
                          style: TextStyle(
                            fontSize: 24,
                            fontWeight: FontWeight.w600,
                            color: const Color(0xFF4A5568),
                            letterSpacing: 2,
                          ),
                        ),
                        const SizedBox(height: 16),
                        Container(
                          width: 60,
                          height: 3,
                          decoration: BoxDecoration(
                            gradient: LinearGradient(
                              colors: [
                                const Color(0xFF3182CE),
                                const Color(0xFF2B6CB0),
                              ],
                            ),
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                        const SizedBox(height: 16),
                        Text(
                          'Construction Materials',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w400,
                            color: const Color(0xFF718096),
                            letterSpacing: 1,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: 60),

                // Loading indicator
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: Column(
                    children: [
                      SizedBox(
                        width: 40,
                        height: 40,
                        child: CircularProgressIndicator(
                          strokeWidth: 3,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            const Color(0xFF3182CE),
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'Loading...',
                        style: TextStyle(
                          fontSize: 14,
                          color: const Color(0xFF718096),
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),

          // Bottom footer
          Positioned(
            bottom: 30,
            left: 0,
            right: 0,
            child: FadeTransition(
              opacity: _fadeAnimation,
              child: Column(
                children: [
                  Text(
                    'Est. 1980',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Ras Al Khaimah, United Arab Emirates',
                    style: TextStyle(
                      fontSize: 12,
                      color: const Color(0xFFA0AEC0),
                      fontWeight: FontWeight.w400,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ParticlePainter extends CustomPainter {
  final double animationValue;

  ParticlePainter(this.animationValue);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()..color = Colors.blue.withOpacity(0.1);

    // Create floating particles
    for (int i = 0; i < 20; i++) {
      final x = (size.width / 20) * i + (animationValue * 50) % size.width;
      final y =
          size.height * 0.5 +
          (animationValue * 100 + i * 30) % size.height -
          size.height * 0.25;

      canvas.drawCircle(Offset(x, y), 2 + (animationValue * 2) % 3, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}


































plugins {
    // Add the dependency for the Google services Gradle plugin
    id("com.google.gms.google-services") version "4.4.3" apply false
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}

































plugins {
    id("com.android.application")
    id("kotlin-android")
    // Add the Google services Gradle plugin
    id("com.google.gms.google-services")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.rak_web"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.rak_web"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

dependencies {
    // Import the Firebase BoM
    implementation(platform("com.google.firebase:firebase-bom:34.3.0"))

    // Add the dependencies for Firebase products you want to use
    // When using the BoM, don't specify versions in Firebase dependencies
    implementation("com.google.firebase:firebase-analytics")
    implementation("com.google.firebase:firebase-auth")

    // Add the dependencies for any other desired Firebase products
    // https://firebase.google.com/docs/android/setup#available-libraries
}

flutter {
    source = "../.."
}




































{
  "project_info": {
    "project_number": "929132248851",
    "project_id": "rak-test-e2762",
    "storage_bucket": "rak-test-e2762.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:929132248851:android:a8c293dbac7828737fa4e6",
        "android_client_info": {
          "package_name": "com.example.rak_web"
        }
      },
      "oauth_client": [],
      "api_key": [
        {
          "current_key": "AIzaSyArL5abZZ-CmPwXoTNGVahTH3OR0YcSf40"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": []
        }
      }
    }
  ],
  "configuration_version": "1"
}








