import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_web_plugins/url_strategy.dart';
import 'package:firebase_core/firebase_core.dart';

import 'core/theme/theme.dart';
import 'core/di/service_locator.dart';
import 'core/navigation/app_router.dart';
import 'core/services/auth_service.dart';
import 'firebase_options.dart';

final RouteObserver<PageRoute> routeObserver = RouteObserver<PageRoute>();

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Keep hash URLs for Flutter Web (prevents 404s on hard refresh)
  setUrlStrategy(const HashUrlStrategy());

  // Global error handlers (surface real stack traces on web)
  FlutterError.onError = (FlutterErrorDetails details) {
    FlutterError.dumpErrorToConsole(details);
  };

  await runZonedGuarded<Future<void>>(
    () async {
      // Ensure services are ready before runApp
      await setupServiceLocator();

      // Initialize Firebase Auth state sync
      await AuthManager.initializeFirebaseSync();

      // Check for autologin
      await AuthService.checkAutologin();

      runApp(const MyApp());
    },
    (error, stack) {
      debugPrint('Zoned error: $error');
      debugPrint('$stack');
    },
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      debugShowCheckedModeBanner: false,

      title: 'RAK Business Management',

      theme: AppTheme.lightTheme,

      themeMode: ThemeMode.light,

      routerConfig: AppRouter.router,
    );
  }
}




































// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// IMPORTANT: Replace the placeholder values below with your actual Firebase project configuration.
/// To get these values:
/// 1. Go to Firebase Console -> Project Settings -> General
/// 2. Scroll to "Your apps" and select your platform
/// 3. Copy the configuration values
///
/// Or use FlutterFire CLI: `flutterfire configure`
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'YOUR_WEB_API_KEY',
    appId: 'YOUR_WEB_APP_ID',
    messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    authDomain: 'YOUR_PROJECT_ID.firebaseapp.com',
    storageBucket: 'YOUR_PROJECT_ID.appspot.com',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'YOUR_ANDROID_API_KEY',
    appId: 'YOUR_ANDROID_APP_ID',
    messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    storageBucket: 'YOUR_PROJECT_ID.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'YOUR_IOS_API_KEY',
    appId: 'YOUR_IOS_APP_ID',
    messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    storageBucket: 'YOUR_PROJECT_ID.appspot.com',
    iosBundleId: 'com.example.rakWeb',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'YOUR_MACOS_API_KEY',
    appId: 'YOUR_MACOS_APP_ID',
    messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    storageBucket: 'YOUR_PROJECT_ID.appspot.com',
    iosBundleId: 'com.example.rakWeb',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'YOUR_WINDOWS_API_KEY',
    appId: 'YOUR_WINDOWS_APP_ID',
    messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    authDomain: 'YOUR_PROJECT_ID.firebaseapp.com',
    storageBucket: 'YOUR_PROJECT_ID.appspot.com',
  );
}}







































import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/auth_models.dart';
import '../utils/app_logger.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';
  static const String autoLoginEndpoint = '/api/Auth/auto-login';
  static const String logoutEndpoint = '/api/Auth/logout';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final request = http.Request('POST', uri);
      request.headers.addAll(requestHeaders);
      request.body = requestBody;

      final client = http.Client();
      final streamedResponse = await client
          .send(request)
          .timeout(_defaultTimeout);
      final response = await http.Response.fromStream(streamedResponse);

      // Extract cookies from response headers for future requests
      final cookieHeader = response.headers['set-cookie'];
      if (cookieHeader != null) {
        _logger.debug('Received cookies: $cookieHeader');
      }

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password) async {
    try {
      print('üîê Starting login for userId: "$userId"');

      // First authenticate with backend to get user data
      final result = await authenticateUser(userID: userId, password: password);
      if (result['success'] == true) {
        final loginResponse = result['data'] as LoginResponse;

        print('üìä Backend login successful, proceeding with Firebase auth...');

        // Create user data
        final userDataWithId = UserData(
          emplName: loginResponse.data.emplName,
          areaCode: loginResponse.data.areaCode,
          roles: loginResponse.data.roles,
          pages: loginResponse.data.pages,
          userID: userId,
        );

        // Firebase Anonymous Authentication and get ID token
        final firebaseResult = await _firebaseSignInAnonymous(userDataWithId);
        if (firebaseResult['success'] == true) {
          print('‚úÖ Firebase anonymous authentication successful');

          // Get Firebase ID token to use as appRegId
          final idToken = await _getFirebaseIdToken();
          if (idToken != null) {
            // Store user data and Firebase token locally for autologin
            await _storeUserDataLocally(userDataWithId, idToken);
            print('üì± Firebase ID token stored for autologin');
          } else {
            // Fallback: store without token
            await _storeUserDataLocally(userDataWithId);
            print('‚ö†Ô∏è No Firebase token available, stored without token');
          }

          // Set user in AuthManager after Firebase auth succeeds
          AuthManager.setUser(userDataWithId);
          return true;
        } else {
          print('‚ùå Firebase authentication failed: ${firebaseResult['error']}');
          return false;
        }
      } else {
        print('‚ùå Backend authentication failed: ${result['error']}');
      }
      return false;
    } catch (e) {
      _logger.error('Login error', e);
      return false;
    }
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    try {
      // Get Firebase token before clearing
      final prefs = await SharedPreferences.getInstance();
      final firebaseToken = prefs.getString('firebase_token');

      // Call backend logout endpoint if we have a token
      if (firebaseToken != null) {
        final backendLogout = await _performBackendLogout(firebaseToken);
        if (backendLogout['success']) {
          print('‚úÖ Backend logout successful');
        } else {
          print('‚ö†Ô∏è Backend logout failed: ${backendLogout['error']}');
        }
      }

      // Firebase sign out
      await _firebaseSignOut();

      // Clear stored user data
      await _clearStoredUserData();

      // Clear user from AuthManager
      AuthManager.clearUser();

      await Future.delayed(const Duration(milliseconds: 500));
      print('‚úÖ Complete logout successful');
    } catch (e) {
      print('‚ùå Logout error: $e');
      // Still clear local data even if logout fails
      await _firebaseSignOut();
      await _clearStoredUserData();
      AuthManager.clearUser();
    }
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }

  // Session validation endpoint
  static Future<Map<String, dynamic>> validateSession() async {
    try {
      _logger.info('Validating user session');

      final uri = Uri.parse('$baseUrl/auth/me');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .get(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Session validation response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Session validation failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Session validation error', e);
      return {
        'success': false,
        'error': 'Network error during session validation',
        'statusCode': 0,
      };
    }
  }

  // Token refresh endpoint
  static Future<Map<String, dynamic>> refreshToken() async {
    try {
      _logger.info('Refreshing access token');

      final uri = Uri.parse('$baseUrl/auth/refresh');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Token refresh response: ${response.statusCode}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        return {
          'success': true,
          'data': responseData,
          'statusCode': response.statusCode,
        };
      } else {
        return {
          'success': false,
          'error': 'Token refresh failed',
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Token refresh error', e);
      return {
        'success': false,
        'error': 'Network error during token refresh',
        'statusCode': 0,
      };
    }
  }

  // Enhanced logout with server-side session clearing
  static Future<Map<String, dynamic>> logoutFromServer() async {
    try {
      _logger.info('Logging out from server');

      final uri = Uri.parse('$baseUrl/auth/logout');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final response = await http
          .post(uri, headers: requestHeaders)
          .timeout(const Duration(seconds: 10));

      _logger.debug('Server logout response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
      };
    } catch (e) {
      _logger.error('Server logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout',
        'statusCode': 0,
      };
    }
  }

  // Firebase Anonymous Authentication
  static Future<Map<String, dynamic>> _firebaseSignInAnonymous(
    UserData userData,
  ) async {
    try {
      print('üîê Attempting Firebase anonymous authentication for userID: ${userData.userID ?? "unknown"}');

      // Check if already signed in anonymously
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser != null && currentUser.isAnonymous) {
        print('‚úÖ Already signed in anonymously, updating profile');

        // Update user profile with display name and custom claims in local storage
        await currentUser.updateDisplayName(userData.emplName);
        return {'success': true, 'user': currentUser};
      }

      // Sign in anonymously
      final userCredential = await FirebaseAuth.instance.signInAnonymously();

      // Update user profile with display name
      await userCredential.user?.updateDisplayName(userData.emplName);

      print('‚úÖ Firebase anonymous sign in successful for: ${userData.userID ?? "unknown"}');
      return {'success': true, 'user': userCredential.user};
    } on FirebaseAuthException catch (e) {
      print('‚ùå Firebase anonymous sign in failed: ${e.message}');
      return {'success': false, 'error': 'Anonymous sign in failed: ${e.message}'};
    } catch (e) {
      print('‚ùå Firebase auth error: $e');
      return {'success': false, 'error': 'Firebase authentication failed: $e'};
    }
  }

  // Get Firebase ID token
  static Future<String?> _getFirebaseIdToken() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user != null) {
        final idToken = await user.getIdToken();
        return idToken;
      }
      return null;
    } catch (e) {
      print('‚ùå Failed to get Firebase ID token: $e');
      return null;
    }
  }

  // Store user data locally for autologin
  static Future<void> _storeUserDataLocally(UserData userData, [String? firebaseToken]) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('user_data', jsonEncode(userData.toJson()));
      await prefs.setString('user_id', userData.userID ?? '');
      await prefs.setBool('is_logged_in', true);

      if (firebaseToken != null) {
        await prefs.setString('firebase_token', firebaseToken);
      }

      print('üìä User data stored locally for autologin');
    } catch (e) {
      print('‚ùå Failed to store user data locally: $e');
    }
  }

  // Clear stored user data
  static Future<void> _clearStoredUserData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('user_data');
      await prefs.remove('user_id');
      await prefs.remove('firebase_token');
      await prefs.setBool('is_logged_in', false);
      print('üóëÔ∏è Stored user data cleared');
    } catch (e) {
      print('‚ùå Failed to clear stored user data: $e');
    }
  }

  // Check for autologin on app start
  static Future<bool> checkAutologin() async {
    try {
      print('üîÑ Checking for autologin...');

      // Check if user is logged in with Firebase (anonymous)
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null || !currentUser.isAnonymous) {
        print('‚ùå No Firebase anonymous user found');
        return false;
      }

      // Get stored data
      final prefs = await SharedPreferences.getInstance();
      final isLoggedIn = prefs.getBool('is_logged_in') ?? false;
      final firebaseToken = prefs.getString('firebase_token');

      if (!isLoggedIn || firebaseToken == null) {
        print('‚ùå No stored session or Firebase token found');
        await FirebaseAuth.instance.signOut();
        return false;
      }

      // Try auto-login with backend using Firebase token
      final autoLoginResult = await _performBackendAutoLogin(firebaseToken);

      if (autoLoginResult['success'] == true) {
        final userData = autoLoginResult['userData'] as UserData;

        // Update stored user data (in case roles/pages changed)
        await _storeUserDataLocally(userData, firebaseToken);

        // Set user in AuthManager
        AuthManager.setUser(userData);
        print('‚úÖ Backend autologin successful for user: ${userData.userID ?? "unknown"}');
        return true;
      } else {
        print('‚ùå Backend autologin failed: ${autoLoginResult['error']}');
        await _clearStoredUserData();
        await FirebaseAuth.instance.signOut();
        return false;
      }
    } catch (e) {
      print('‚ùå Autologin failed: $e');
      await _clearStoredUserData();
      await FirebaseAuth.instance.signOut();
      return false;
    }
  }

  // Backend auto-login using Firebase token
  static Future<Map<String, dynamic>> _performBackendAutoLogin(String firebaseToken) async {
    try {
      _logger.info('Attempting backend auto-login with Firebase token');

      final uri = Uri.parse('$baseUrl$autoLoginEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode({'appRegId': firebaseToken});

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Auto-login response status: ${response.statusCode}');
      _logger.debug('Auto-login response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;
        final data = responseData['data'] as Map<String, dynamic>;

        // Create UserData from backend response
        final userData = UserData(
          emplName: data['emplName'] as String,
          areaCode: data['areaCode'] as String,
          roles: (data['roles'] as List<dynamic>).cast<String>(),
          pages: (data['pages'] as List<dynamic>).cast<String>(),
          userID: data['userID'] as String,
        );

        _logger.info('Backend auto-login successful');
        return {
          'success': true,
          'userData': userData,
          'statusCode': response.statusCode,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Auto-login failed';

        _logger.warning('Backend auto-login failed: $errorMessage');
        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Backend auto-login error', e);
      return {
        'success': false,
        'error': 'Network error during auto-login: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  // Backend logout using Firebase token
  static Future<Map<String, dynamic>> _performBackendLogout(String firebaseToken) async {
    try {
      _logger.info('Attempting backend logout with Firebase token');

      final uri = Uri.parse('$baseUrl$logoutEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode({'appRegId': firebaseToken});

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Backend logout response status: ${response.statusCode}');
      _logger.debug('Backend logout response body: ${response.body}');

      if (response.statusCode == 200) {
        _logger.info('Backend logout successful');
        return {
          'success': true,
          'statusCode': response.statusCode,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Backend logout failed';

        _logger.warning('Backend logout failed: $errorMessage');
        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } catch (e) {
      _logger.error('Backend logout error', e);
      return {
        'success': false,
        'error': 'Network error during logout: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  // Firebase Authentication Helper Methods
  static Future<Map<String, dynamic>> _firebaseSignIn(
    String email,
    String password,
  ) async {
    try {
      _logger.info('Attempting Firebase sign in for: $email');

      final userCredential = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      _logger.info('Firebase sign in successful');
      return {'success': true, 'user': userCredential.user};
    } on FirebaseAuthException catch (e) {
      _logger.warning('Firebase sign in failed: ${e.message}');
      return {'success': false, 'error': e.message ?? 'Unknown Firebase error'};
    } catch (e) {
      _logger.error('Firebase sign in error', e);
      return {'success': false, 'error': 'Firebase authentication failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> _firebaseSignOut() async {
    try {
      _logger.info('Signing out from Firebase');

      await FirebaseAuth.instance.signOut();

      _logger.info('Firebase sign out successful');
      return {'success': true};
    } catch (e) {
      _logger.error('Firebase sign out error', e);
      return {'success': false, 'error': 'Firebase sign out failed: $e'};
    }
  }

  static Future<Map<String, dynamic>> firebaseSignInWithPhone(
    String phoneNumber,
  ) async {
    try {
      _logger.info('Attempting Firebase phone sign in for: $phoneNumber');

      // Note: Phone auth requires reCAPTCHA setup in production
      // For now, this is a placeholder for future implementation
      return {'success': false, 'error': 'Phone authentication not configured yet'};
    } catch (e) {
      _logger.error('Firebase phone sign in error', e);
      return {
        'success': false,
        'error': 'Firebase phone authentication failed: $e',
      };
    }
  }

  // Helper method to validate email format
  static bool _isValidEmail(String email) {
    return RegExp(
      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
    ).hasMatch(email);
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);
  static bool _firebaseInitialized = false;

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  // Initialize Firebase auth state sync
  static Future<void> initializeFirebaseSync() async {
    if (_firebaseInitialized) return;

    try {
      // Set up Firebase auth state listener
      FirebaseAuth.instance.authStateChanges().listen((User? user) {
        print('Firebase auth state changed: ${user != null ? 'signed in' : 'signed out'}');

        if (user == null && _currentUser != null) {
          // User signed out, clear local data
          clearUser();
        }
      });

      _firebaseInitialized = true;
      print('‚úÖ Firebase auth state listener initialized');
    } catch (e) {
      print('‚ùå Failed to initialize Firebase sync: $e');
    }
  }

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;

    print('üë§ User set in AuthManager: ${userData.userID ?? "unknown"}');
    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;

    print('üóëÔ∏è User cleared from AuthManager');
    _notifyAuthChanged();
  }

  // Restore user session from Firebase auth state and local storage
  static Future<bool> restoreUserFromFirebase() async {
    try {
      print('üîÑ Checking Firebase auth state for session restoration...');

      final firebaseUser = FirebaseAuth.instance.currentUser;

      if (firebaseUser != null && firebaseUser.isAnonymous) {
        print('‚úÖ Firebase anonymous user found, checking local storage...');

        // Get stored user data from SharedPreferences
        final prefs = await SharedPreferences.getInstance();
        final userDataJson = prefs.getString('user_data');
        final isLoggedIn = prefs.getBool('is_logged_in') ?? false;

        if (isLoggedIn && userDataJson != null) {
          // Restore full user data from local storage
          final userDataMap = jsonDecode(userDataJson) as Map<String, dynamic>;
          final userData = UserData.fromJson(userDataMap);

          _currentUser = userData;
          _notifyAuthChanged();

          print('‚úÖ User session restored: ${userData.userID ?? "unknown"}');
          return true;
        } else {
          print('‚ùå No stored user data found, signing out Firebase user');
          await FirebaseAuth.instance.signOut();
        }
      } else {
        print('‚ùå No Firebase anonymous user found');
      }
    } catch (e) {
      print('‚ùå Failed to restore user from Firebase: $e');
    }

    return false;
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}





































import 'package:go_router/go_router.dart';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:rak_web/features/products/screens/incentive_scheme_form.dart';
import 'package:rak_web/features/products/screens/sampling_drive_form_screen.dart';
import 'package:rak_web/features/quality_control/screens/dashboard_screen.dart';

// Import AuthManager for authentication checks
import '../services/auth_service.dart';

// Auth Screens
import '../../features/auth/screens/login_screen_with_otp.dart';
import '../../features/auth/screens/login_with_password_screen.dart';

// Registration Screens
import '../../features/registration/screens/registration_type_screen.dart';
import '../../features/registration/screens/contractor_registration_screen.dart';
import '../../features/registration/screens/painter_registration_screen.dart';
import '../../features/registration/screens/registration_details_screen.dart';
import '../../features/registration/screens/success_screen.dart';

// Retail Screens
import '../../features/retail/screens/retailer_onboarding_screen.dart';

// Product Screens
import '../../features/products/screens/new_product_entry_screen.dart';
import '../../features/products/screens/sample_distribution_entry_screen.dart';

// Quality Control Screens
import '../../features/quality_control/screens/approval_dashboard_screen.dart';

// Activity Screens
import '../../features/activity/screens/activity_entry_screen.dart';

// Common Screens (to be moved later)
import '../../screens/splash_screen.dart';
import '../../screens/home_screen.dart';

import '../../screens/file_manager_screen.dart';

import '../../screens/camera_scanner_screen.dart';
import '../../screens/qr_input_screen.dart';

class AppRouter {
  static const String splash = '/';
  static const String loginPassword = '/login-password';
  static const String loginOtp = '/login-otp';
  static const String home = '/home';

  // Authentication redirect function
  static String? _handleRedirect(BuildContext context, GoRouterState state) {
    final isLoggedIn = AuthManager.isLoggedIn;
    final currentPath = state.uri.path;

    // List of public routes that don't require authentication
    final publicRoutes = [
      splash,
      loginPassword,
      loginOtp,
      registrationType,
      contractorRegistration,
      painterRegistration,
      registrationSuccess,
    ];

    // If user is logged in and on splash, redirect to home (autologin successful)
    if (isLoggedIn && currentPath == splash) {
      return home;
    }

    // If user is not logged in and trying to access a protected route
    if (!isLoggedIn && !publicRoutes.contains(currentPath)) {
      return loginPassword;
    }

    // If user is logged in and trying to access login pages, redirect to home
    if (isLoggedIn &&
        (currentPath == loginPassword || currentPath == loginOtp)) {
      return home;
    }

    // No redirect needed
    return null;
  }

  // Registration routes
  static const String registrationType = '/registration-type';
  static const String contractorRegistration = '/contractor-registration';
  static const String painterRegistration = '/painter-registration';
  static const String registrationDetails = '/registration-details';
  static const String registrationSuccess = '/success';
  static const String retailerRegistration = '/retailer-registration';

  // Retail routes
  static const String retailerOnboarding = '/retailer-onboarding';
  static const String retailerPlan = '/retailer-plan';
  static const String retailEntry = '/retail-entry';

  // Product routes
  static const String newProductEntry = '/new-product-entry';
  static const String sampleDistribution = '/sample-distribution';
  static const String samplingDriveForm = '/sampling-drive-form';
  static const String incentiveSchemeForm = '/incentive-scheme-form';
  static const String expertMeetClaim = '/expert-meet-claim';

  // Quality Control routes
  static const String approvalDashboard = '/approval-dashboard';
  static const String dashboard = '/dashboard';

  // Utility routes
  static const String fileManager = '/file-manager';
  static const String uploadTest = '/upload-test';
  static const String cameraScanner = '/camera-scanner';
  static const String qrInput = '/qr-input';

  // Activity routes
  static const String activityEntry = '/activity-entry';

  static final GoRouter router = GoRouter(
    initialLocation: splash,
    redirect: _handleRedirect,
    refreshListenable: AuthManager.authChangeNotifier,
    routes: [
      // Splash and Auth
      GoRoute(path: splash, builder: (context, state) => const SplashScreen()),
      GoRoute(
        path: loginPassword,
        builder: (context, state) => const LoginWithPasswordScreen(),
      ),
      GoRoute(
        path: loginOtp,
        builder: (context, state) => const LoginScreenWithOtp(),
      ),

      // Main App
      GoRoute(path: home, builder: (context, state) => const HomeScreen()),

      // Registration Feature
      GoRoute(
        path: registrationType,
        builder: (context, state) => const RegistrationTypeScreen(),
      ),
      GoRoute(
        path: contractorRegistration,
        builder: (context, state) => const ContractorRegistrationScreen(),
      ),
      GoRoute(
        path: painterRegistration,
        builder: (context, state) => const PainterRegistrationScreen(),
      ),
      GoRoute(
        path: '$registrationDetails/:id',
        builder: (context, state) {
          final id = state.pathParameters['id'];
          return RegistrationDetailsScreen(registrationId: id);
        },
      ),
      GoRoute(
        path: registrationSuccess,
        builder: (context, state) => const SuccessScreen(),
      ),

      // Retail Feature
      GoRoute(
        path: retailerOnboarding,
        builder: (context, state) => const RetailerOnboardingApp(),
      ),

      // Product Feature
      GoRoute(
        path: newProductEntry,
        builder: (context, state) => NewProductEntry(),
      ),
      GoRoute(
        path: sampleDistribution,
        builder: (context, state) => SampleDistributEntry(),
      ),
      GoRoute(
        path: samplingDriveForm,
        builder: (context, state) => SamplingDriveFormPage(),
      ),
      GoRoute(
        path: incentiveSchemeForm,
        builder: (context, state) => IncentiveSchemeFormPage(),
      ),

      // Quality Control Feature
      GoRoute(
        path: approvalDashboard,
        builder: (context, state) => const ApprovalDashboardScreen(),
      ),
      GoRoute(
        path: dashboard,
        builder: (context, state) => const DashboardScreen(),
      ),

      // Utilities
      GoRoute(
        path: fileManager,
        builder: (context, state) => const FileManagerScreen(),
      ),

      GoRoute(
        path: cameraScanner,
        builder: (context, state) => const CameraScannerScreen(),
      ),
      GoRoute(
        path: qrInput,
        builder: (context, state) => const QRInputScreen(),
      ),

      // Activity Feature
      GoRoute(
        path: activityEntry,
        builder: (context, state) => ActivityEntryScreen(),
      ),
    ],
  );
}
