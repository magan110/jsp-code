import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import '../models/auth_models.dart';
import '../utils/app_logger.dart';
import 'firebase_auth_service.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password, {bool rememberMe = false}) async {
    // First authenticate with your API
    final result = await authenticateUser(userID: userId, password: password);
    if (result['success'] == true) {
      final loginResponse = result['data'] as LoginResponse;
      // Create a new UserData instance with the userID preserved
      final userDataWithId = UserData(
        emplName: loginResponse.data.emplName,
        areaCode: loginResponse.data.areaCode,
        roles: loginResponse.data.roles,
        pages: loginResponse.data.pages,
        userID: userId, // Preserve the original userID from login
      );
      AuthManager.setUser(userDataWithId);

      // If remember me is enabled, create/sync with Firebase for persistence
      if (rememberMe) {
        await _createOrSignInFirebaseUser(userId, password, userDataWithId);
      }

      return true;
    }
    return false;
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    // Sign out from Firebase
    await FirebaseAuthService.signOut();

    // Clear local auth state
    AuthManager.clearUser();
    await Future.delayed(const Duration(milliseconds: 500));
  }

  /// Check for auto-login on app start
  static Future<bool> checkAutoLogin() async {
    return await FirebaseAuthService.checkAutoLogin();
  }

  /// Create or sign in to Firebase after successful API authentication
  static Future<void> _createOrSignInFirebaseUser(String userId, String password, UserData userData) async {
    try {
      _logger.info('Creating/signing in Firebase user for: $userId');

      // First try to sign in (user might already exist)
      var firebaseResult = await FirebaseAuthService.signInWithEmailPassword(
        email: userId,
        password: password,
        rememberMe: true,
      );

      if (firebaseResult['success'] == true) {
        _logger.info('Firebase sign-in successful for existing user: $userId');
        return;
      }

      // If sign-in failed, try to create account
      _logger.info('Firebase sign-in failed, attempting to create account for: $userId');
      firebaseResult = await FirebaseAuthService.createAccount(
        email: userId,
        password: password,
        displayName: userData.emplName,
        rememberMe: true,
      );

      if (firebaseResult['success'] == true) {
        _logger.info('Firebase account created successfully for: $userId');

        // Update Firestore with additional user data
        await FirebaseAuthService.updateUserProfile(
          displayName: userData.emplName,
          additionalData: {
            'areaCode': userData.areaCode,
            'roles': userData.roles,
            'pages': userData.pages,
            'userID': userData.userID,
          },
        );
      } else {
        _logger.warning('Firebase account creation failed: ${firebaseResult['error']}');
      }
    } catch (e) {
      _logger.warning('Error creating/signing in Firebase user: $e');
      // Don't fail the login if Firebase fails
    }
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;
    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;
    _notifyAuthChanged();
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}
