import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import '../models/auth_models.dart';
import '../utils/app_logger.dart';
import 'firebase_auth_service.dart';

class AuthService {
  static final AppLogger _logger = AppLogger();
  static const Duration _defaultTimeout = Duration(seconds: 30);

  static const String baseUrl = 'https://qa.birlawhite.com:55232';
  static const String authEndpoint = '/api/Auth/execute';

  static Future<Map<String, dynamic>> authenticateUser({
    required String userID,
    required String password,
    String? appRegId,
  }) async {
    try {
      _logger.info('Authenticating user: $userID');

      final loginRequest = LoginRequest(
        userID: userID,
        password: password,
        appRegId:
            appRegId ?? 'mobile_app_${DateTime.now().millisecondsSinceEpoch}',
      );

      final uri = Uri.parse('$baseUrl$authEndpoint');
      final requestHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      };

      final requestBody = jsonEncode(loginRequest.toJson());

      _logger.debug('Making POST request to: $uri');
      _logger.debug('Request headers: $requestHeaders');
      _logger.debug('Request body: $requestBody');

      final response = await http
          .post(uri, headers: requestHeaders, body: requestBody)
          .timeout(_defaultTimeout);

      _logger.debug('Response status: ${response.statusCode}');
      _logger.debug('Response headers: ${response.headers}');
      _logger.debug('Response body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body) as Map<String, dynamic>;

        try {
          final loginResponse = LoginResponse.fromJson(responseData);
          _logger.info('Authentication successful for user: $userID');

          return {
            'success': true,
            'data': loginResponse,
            'statusCode': response.statusCode,
          };
        } catch (e) {
          _logger.error('Failed to parse login response', e);
          return {
            'success': false,
            'error': 'Invalid response format from server',
            'statusCode': response.statusCode,
          };
        }
      } else if (response.statusCode == 401) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Authentication failed';

        _logger.warning(
          'Authentication failed for user: $userID - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      } else if (response.statusCode == 400) {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? response.body.isNotEmpty
            ? response.body
            : 'Invalid request parameters';

        _logger.warning('Bad request for user: $userID - $errorMessage');
        _logger.warning('Request was: $requestBody');

        return {
          'success': false,
          'error': 'Bad Request: $errorMessage',
          'statusCode': response.statusCode,
          'raw_response': response.body,
        };
      } else {
        final errorData = _safeJsonDecode(response.body);
        final errorMessage = errorData['error'] ?? 'Server error occurred';

        _logger.error(
          'Server error during authentication: ${response.statusCode} - $errorMessage',
        );

        return {
          'success': false,
          'error': errorMessage,
          'statusCode': response.statusCode,
        };
      }
    } on http.ClientException catch (e) {
      _logger.error('Network error during authentication', e);
      return {
        'success': false,
        'error':
            'Network connection failed. Please check your internet connection.',
        'statusCode': 0,
      };
    } on FormatException catch (e) {
      _logger.error('JSON parsing error during authentication', e);
      return {
        'success': false,
        'error': 'Invalid response from server',
        'statusCode': 0,
      };
    } catch (e) {
      _logger.error('Unexpected error during authentication', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
        'statusCode': 0,
      };
    }
  }

  static Future<bool> login(String userId, String password, {bool rememberMe = false}) async {
    // First authenticate with your API
    final result = await authenticateUser(userID: userId, password: password);
    if (result['success'] == true) {
      final loginResponse = result['data'] as LoginResponse;
      // Create a new UserData instance with the userID preserved
      final userDataWithId = UserData(
        emplName: loginResponse.data.emplName,
        areaCode: loginResponse.data.areaCode,
        roles: loginResponse.data.roles,
        pages: loginResponse.data.pages,
        userID: userId, // Preserve the original userID from login
      );
      AuthManager.setUser(userDataWithId);

      // If remember me is enabled, create/sync with Firebase for persistence
      if (rememberMe) {
        await _createOrSignInFirebaseUser(userId, password, userDataWithId);
      }

      return true;
    }
    return false;
  }

  static Future<bool> loginWithOtp(String mobile, String otp) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty && otp.isNotEmpty;
  }

  static Future<bool> sendOtp(String mobile) async {
    await Future.delayed(const Duration(seconds: 1));
    return mobile.isNotEmpty;
  }

  static Future<void> logout() async {
    // Sign out from Firebase
    await FirebaseAuthService.signOut();

    // Clear local auth state
    AuthManager.clearUser();
    await Future.delayed(const Duration(milliseconds: 500));
  }

  /// Check for auto-login on app start
  static Future<bool> checkAutoLogin() async {
    return await FirebaseAuthService.checkAutoLogin();
  }

  /// Create or sign in to Firebase after successful API authentication using username
  static Future<void> _createOrSignInFirebaseUser(String userId, String password, UserData userData) async {
    try {
      _logger.info('Creating/signing in Firebase user for username: $userId');

      // First try to sign in with username (user might already exist)
      var firebaseResult = await FirebaseAuthService.signInWithUsername(
        username: userId,
        password: password,
        rememberMe: true,
      );

      if (firebaseResult['success'] == true) {
        _logger.info('Firebase sign-in successful for existing username: $userId');
        return;
      }

      _logger.info('Firebase sign-in failed: ${firebaseResult['error']}');

      // If sign-in failed, try to create account with username
      _logger.info('Attempting to create Firebase account for username: $userId');
      firebaseResult = await FirebaseAuthService.createAccountWithUsername(
        username: userId,
        password: password,
        displayName: userData.emplName,
        rememberMe: true,
      );

      if (firebaseResult['success'] == true) {
        _logger.info('Firebase account created successfully for username: $userId');

        // Update Firestore with additional user data
        await FirebaseAuthService.updateUserProfile(
          displayName: userData.emplName,
          additionalData: {
            'areaCode': userData.areaCode,
            'roles': userData.roles,
            'pages': userData.pages,
            'userID': userData.userID,
          },
        );
      } else {
        _logger.warning('Firebase account creation failed: ${firebaseResult['error']}');
        _logger.warning('Error details: ${firebaseResult['errorCode']}');
      }
    } catch (e) {
      _logger.warning('Error creating/signing in Firebase user: $e');
      // Don't fail the login if Firebase fails
    }
  }

  static Future<Map<String, dynamic>> testConnection() async {
    try {
      _logger.info('Testing connection to auth server');

      final uri = Uri.parse('$baseUrl/health');
      final response = await http
          .get(uri, headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      _logger.debug('Health check response: ${response.statusCode}');

      return {
        'success': response.statusCode == 200,
        'statusCode': response.statusCode,
        'message': response.statusCode == 200
            ? 'Connection successful'
            : 'Server responded with status ${response.statusCode}',
      };
    } catch (e) {
      _logger.error('Connection test failed', e);
      return {
        'success': false,
        'statusCode': 0,
        'message': 'Connection failed: ${e.toString()}',
      };
    }
  }

  static Map<String, dynamic> _safeJsonDecode(String body) {
    try {
      final decoded = jsonDecode(body);
      return decoded is Map<String, dynamic>
          ? decoded
          : {'raw': decoded.toString()};
    } catch (_) {
      return {'raw': body};
    }
  }
}

class AuthManager {
  static UserData? _currentUser;
  static String? _authToken;
  static final _authChangeNotifier = ValueNotifier<int>(0);

  static UserData? get currentUser => _currentUser;
  static String? get authToken => _authToken;
  static bool get isLoggedIn => _currentUser != null;
  static ValueNotifier<int> get authChangeNotifier => _authChangeNotifier;

  static void setUser(UserData userData, {String? token}) {
    _currentUser = userData;
    _authToken = token;
    _notifyAuthChanged();
  }

  static void clearUser() {
    _currentUser = null;
    _authToken = null;
    _notifyAuthChanged();
  }

  static void Function()? _authChangeCallback;

  static void setAuthChangeCallback(void Function() callback) {
    _authChangeCallback = callback;
  }

  static void _notifyAuthChanged() {
    _authChangeCallback?.call();
    _authChangeNotifier.value++;
  }

  static bool hasRole(String role) {
    return _currentUser?.hasRole(role) ?? false;
  }

  static bool hasPage(String page) {
    return _currentUser?.hasPage(page) ?? false;
  }

  static bool hasAnyRole(List<String> roles) {
    return _currentUser?.hasAnyRole(roles) ?? false;
  }

  static bool hasAnyPage(List<String> pages) {
    return _currentUser?.hasAnyPage(pages) ?? false;
  }

  static List<String> getUserRoles() {
    return _currentUser?.roles ?? [];
  }

  static List<String> getUserPages() {
    return _currentUser?.pages ?? [];
  }

  static String getUserName() {
    return _currentUser?.emplName ?? '';
  }

  static String getUserAreaCode() {
    return _currentUser?.areaCode ?? '';
  }
}








































import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/auth_models.dart';
import '../utils/app_logger.dart';
import 'auth_service.dart';

class FirebaseAuthService {
  static final AppLogger _logger = AppLogger();
  static final FirebaseAuth _auth = FirebaseAuth.instance;
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  static const String _userCollectionName = 'users';
  static const String _lastLoginKey = 'last_login_time';
  static const String _rememberMeKey = 'remember_me';
  static const String _savedUserIdKey = 'saved_user_id';
  static const String _autoLoginKey = 'auto_login_enabled';

  /// Initialize Firebase Auth state listener
  static void initializeAuthListener() {
    _auth.authStateChanges().listen((User? user) {
      if (user != null) {
        _logger.info('Firebase user signed in: ${user.uid}');
        _loadUserFromFirestore(user.uid);
      } else {
        _logger.info('Firebase user signed out');
        AuthManager.clearUser();
      }
    });
  }

  /// Sign in anonymously and store username/password in Firestore
  static Future<Map<String, dynamic>> signInWithUsername({
    required String username,
    required String password,
    bool rememberMe = true,
  }) async {
    try {
      _logger.info('🔄 Starting signInWithUsername for: $username');
      _logger.info('🔄 This method uses Firebase Anonymous Auth, NOT email/password');

      // Check if user already exists in Firestore
      final existingUser = await _getUserByUsername(username);

      if (existingUser != null) {
        // User exists, verify password
        final storedPassword = existingUser['password'] as String?;
        if (storedPassword == password) {
          // Sign in anonymously and restore session
          final UserCredential userCredential = await _auth.signInAnonymously();

          if (userCredential.user != null) {
            await _handleSuccessfulUsernameSignIn(
              userCredential.user!,
              username,
              password,
              existingUser,
              rememberMe,
            );

            return {
              'success': true,
              'user': userCredential.user,
              'message': 'Sign in successful',
            };
          }
        } else {
          return {
            'success': false,
            'error': 'Invalid password',
            'errorCode': 'wrong-password',
          };
        }
      } else {
        return {
          'success': false,
          'error': 'User not found',
          'errorCode': 'user-not-found',
        };
      }

      return {
        'success': false,
        'error': 'Sign in failed',
      };
    } on FirebaseAuthException catch (e) {
      _logger.error('Firebase Auth Error: ${e.code} - ${e.message}');
      return {
        'success': false,
        'error': _getFirebaseErrorMessage(e.code),
        'errorCode': e.code,
      };
    } catch (e) {
      _logger.error('Unexpected error during Firebase sign in', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
      };
    }
  }

  /// Create account with username/password
  static Future<Map<String, dynamic>> createAccountWithUsername({
    required String username,
    required String password,
    required String displayName,
    bool rememberMe = true,
  }) async {
    try {
      _logger.info('🔄 Starting createAccountWithUsername for: $username');
      _logger.info('🔄 This method uses Firebase Anonymous Auth, NOT email/password');

      // Check if username already exists
      final existingUser = await _getUserByUsername(username);
      if (existingUser != null) {
        return {
          'success': false,
          'error': 'Username already exists',
          'errorCode': 'username-already-in-use',
        };
      }

      // Create anonymous user
      final UserCredential userCredential = await _auth.signInAnonymously();

      if (userCredential.user != null) {
        // Create user document in Firestore with username
        await _createUsernameUserDocument(
          userCredential.user!,
          username,
          password,
          displayName,
        );

        await _handleSuccessfulUsernameSignIn(
          userCredential.user!,
          username,
          password,
          {
            'username': username,
            'displayName': displayName,
            'password': password,
          },
          rememberMe,
        );

        return {
          'success': true,
          'user': userCredential.user,
          'message': 'Account created successfully',
        };
      }

      return {
        'success': false,
        'error': 'Account creation failed - no user returned',
      };
    } on FirebaseAuthException catch (e) {
      _logger.error('Firebase Auth Error: ${e.code} - ${e.message}');
      return {
        'success': false,
        'error': _getFirebaseErrorMessage(e.code),
        'errorCode': e.code,
      };
    } catch (e) {
      _logger.error('Unexpected error during account creation', e);
      return {
        'success': false,
        'error': 'An unexpected error occurred: ${e.toString()}',
      };
    }
  }

  /// Check if user is currently signed in and auto-login if enabled
  static Future<bool> checkAutoLogin() async {
    try {
      _logger.info('Starting auto-login check...');

      final prefs = await SharedPreferences.getInstance();
      final autoLoginEnabled = prefs.getBool(_autoLoginKey) ?? false;
      final rememberMe = prefs.getBool(_rememberMeKey) ?? false;
      final savedUsername = prefs.getString(_savedUserIdKey);

      if (!autoLoginEnabled || !rememberMe) {
        _logger.info('Auto-login disabled by user preference');
        return false;
      }

      final user = _auth.currentUser;
      if (user != null && savedUsername != null) {
        _logger.info('Auto-login successful for user: ${user.uid}');

        // Load user data from username collection
        final userData = await _getUserByUsername(savedUsername);
        if (userData != null) {
          final userDataObj = UserData(
            userID: savedUsername,
            emplName: userData['displayName'] ?? '',
            areaCode: userData['areaCode'] ?? 'DEFAULT',
            roles: List<String>.from(userData['roles'] ?? ['USER']),
            pages: List<String>.from(userData['pages'] ?? ['DASHBOARD']),
          );

          AuthManager.setUser(userDataObj);
          return true;
        }
      }

      _logger.info('No valid auto-login session found');
      return false;
    } catch (e) {
      _logger.error('Error during auto-login check', e);
      return false;
    }
  }

  /// Sign out and clear stored credentials
  static Future<void> signOut() async {
    try {
      await _auth.signOut();
      await _clearStoredCredentials();
      AuthManager.clearUser();
      _logger.info('User signed out successfully');
    } catch (e) {
      _logger.error('Error during sign out', e);
    }
  }

  /// Update user profile in Firestore
  static Future<void> updateUserProfile({
    required String displayName,
    Map<String, dynamic>? additionalData,
  }) async {
    try {
      final user = _auth.currentUser;
      if (user == null) return;

      await user.updateDisplayName(displayName);

      final userDoc = _firestore.collection(_userCollectionName).doc(user.uid);
      await userDoc.update({
        'displayName': displayName,
        'lastUpdated': FieldValue.serverTimestamp(),
        ...?additionalData,
      });

      _logger.info('User profile updated successfully');
    } catch (e) {
      _logger.error('Error updating user profile', e);
    }
  }

  /// Get current Firebase user
  static User? getCurrentUser() {
    return _auth.currentUser;
  }

  /// Check if user is signed in
  static bool isSignedIn() {
    return _auth.currentUser != null;
  }

  /// Handle successful sign in
  static Future<void> _handleSuccessfulSignIn(
    User user,
    String email,
    String password,
    bool rememberMe,
  ) async {
    try {
      final prefs = await SharedPreferences.getInstance();

      // Store login preferences
      await prefs.setBool(_rememberMeKey, rememberMe);
      await prefs.setBool(_autoLoginKey, rememberMe);
      await prefs.setString(_savedUserIdKey, email);
      await prefs.setString(_lastLoginKey, DateTime.now().toIso8601String());

      // Load user data from Firestore
      await _loadUserFromFirestore(user.uid);

      _logger.info('Successful sign in handling completed');
    } catch (e) {
      _logger.error('Error handling successful sign in', e);
    }
  }

  /// Load user data from Firestore and update AuthManager
  static Future<void> _loadUserFromFirestore(String uid) async {
    try {
      final userDoc = await _firestore.collection(_userCollectionName).doc(uid).get();

      if (userDoc.exists) {
        final data = userDoc.data()!;
        final userData = UserData(
          userID: data['email'] ?? '',
          emplName: data['displayName'] ?? '',
          areaCode: data['areaCode'] ?? 'DEFAULT',
          roles: List<String>.from(data['roles'] ?? ['USER']),
          pages: List<String>.from(data['pages'] ?? ['DASHBOARD']),
        );

        AuthManager.setUser(userData);
        _logger.info('User data loaded from Firestore');
      } else {
        // Create default user data if document doesn't exist
        final user = _auth.currentUser;
        if (user != null) {
          // For anonymous users, we can't create a default document
          // User data should be created during the login process
          _logger.warning('No user document found for anonymous user: $uid');
        }
      }
    } catch (e) {
      _logger.error('Error loading user from Firestore', e);
    }
  }

  /// Create user document in Firestore with username
  static Future<void> _createUsernameUserDocument(
    User user,
    String username,
    String password,
    String displayName,
  ) async {
    try {
      // Store user by username for lookup
      final usernameDoc = _firestore.collection('usernames').doc(username);
      await usernameDoc.set({
        'uid': user.uid,
        'username': username,
        'password': password, // In production, hash this
        'displayName': displayName,
        'areaCode': 'DEFAULT',
        'roles': ['USER'],
        'pages': ['DASHBOARD'],
        'createdAt': FieldValue.serverTimestamp(),
        'lastLogin': FieldValue.serverTimestamp(),
      });

      // Also store user data by UID
      final userDoc = _firestore.collection(_userCollectionName).doc(user.uid);
      await userDoc.set({
        'uid': user.uid,
        'username': username,
        'displayName': displayName,
        'areaCode': 'DEFAULT',
        'roles': ['USER'],
        'pages': ['DASHBOARD'],
        'createdAt': FieldValue.serverTimestamp(),
        'lastLogin': FieldValue.serverTimestamp(),
      });

      _logger.info('Username user document created in Firestore');
    } catch (e) {
      _logger.error('Error creating username user document', e);
    }
  }

  /// Get user by username
  static Future<Map<String, dynamic>?> _getUserByUsername(String username) async {
    try {
      final doc = await _firestore.collection('usernames').doc(username).get();
      if (doc.exists) {
        return doc.data();
      }
      return null;
    } catch (e) {
      _logger.error('Error getting user by username', e);
      return null;
    }
  }

  /// Handle successful username sign in
  static Future<void> _handleSuccessfulUsernameSignIn(
    User user,
    String username,
    String password,
    Map<String, dynamic> userData,
    bool rememberMe,
  ) async {
    try {
      final prefs = await SharedPreferences.getInstance();

      // Store login preferences
      await prefs.setBool(_rememberMeKey, rememberMe);
      await prefs.setBool(_autoLoginKey, rememberMe);
      await prefs.setString(_savedUserIdKey, username);
      await prefs.setString(_lastLoginKey, DateTime.now().toIso8601String());

      // Create UserData object
      final userDataObj = UserData(
        userID: username,
        emplName: userData['displayName'] ?? '',
        areaCode: userData['areaCode'] ?? 'DEFAULT',
        roles: List<String>.from(userData['roles'] ?? ['USER']),
        pages: List<String>.from(userData['pages'] ?? ['DASHBOARD']),
      );

      AuthManager.setUser(userDataObj);

      _logger.info('Successful username sign in handling completed');
    } catch (e) {
      _logger.error('Error handling successful username sign in', e);
    }
  }

  /// Clear stored credentials
  static Future<void> _clearStoredCredentials() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_rememberMeKey);
      await prefs.remove(_autoLoginKey);
      await prefs.remove(_savedUserIdKey);
      await prefs.remove(_lastLoginKey);

      _logger.info('Stored credentials cleared');
    } catch (e) {
      _logger.error('Error clearing stored credentials', e);
    }
  }

  /// Get user-friendly error messages
  static String _getFirebaseErrorMessage(String errorCode) {
    switch (errorCode) {
      case 'user-not-found':
        return 'No user found with this email address.';
      case 'wrong-password':
        return 'Incorrect password. Please try again.';
      case 'invalid-email':
        return 'Invalid email address format.';
      case 'user-disabled':
        return 'This account has been disabled.';
      case 'too-many-requests':
        return 'Too many failed attempts. Please try again later.';
      case 'email-already-in-use':
        return 'An account already exists with this email address.';
      case 'weak-password':
        return 'Password is too weak. Please choose a stronger password.';
      case 'network-request-failed':
        return 'Network error. Please check your internet connection.';
      default:
        return 'Authentication failed. Please try again.';
    }
  }

  /// Get stored login preferences
  static Future<Map<String, dynamic>> getLoginPreferences() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      return {
        'rememberMe': prefs.getBool(_rememberMeKey) ?? false,
        'autoLogin': prefs.getBool(_autoLoginKey) ?? false,
        'savedUserId': prefs.getString(_savedUserIdKey) ?? '',
        'lastLogin': prefs.getString(_lastLoginKey),
      };
    } catch (e) {
      _logger.error('Error getting login preferences', e);
      return {};
    }
  }

  /// Update auto-login preference
  static Future<void> setAutoLogin(bool enabled) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool(_autoLoginKey, enabled);
      await prefs.setBool(_rememberMeKey, enabled);

      _logger.info('Auto-login preference updated: $enabled');
    } catch (e) {
      _logger.error('Error updating auto-login preference', e);
    }
  }

  /// Reset password
  static Future<Map<String, dynamic>> resetPassword(String email) async {
    try {
      await _auth.sendPasswordResetEmail(email: email);
      return {
        'success': true,
        'message': 'Password reset email sent successfully.',
      };
    } on FirebaseAuthException catch (e) {
      return {
        'success': false,
        'error': _getFirebaseErrorMessage(e.code),
      };
    } catch (e) {
      return {
        'success': false,
        'error': 'Failed to send password reset email.',
      };
    }
  }
}
